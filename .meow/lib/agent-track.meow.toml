# ============================================================================
# MEOW Library: Agent Track Lifecycle
# ============================================================================
#
# Complete agent lifecycle: spawn → work → review → verify-clean → kill
# With Ralph Wiggum persistence monitor and context monitor running in parallel.
#
# This is the battle-tested pattern extracted from dual/quad agent workflows.
# Each agent works in isolation, self-reviews, ensures clean git state, then exits.
# The RW monitor ensures agents don't get stuck by re-nudging on unexpected stops.
# The context monitor auto-compacts when context usage is high.
#
# ADAPTER SUPPORT:
#   Works with any adapter (claude, claude-opus, claude-sonnet, opencode, codex).
#   RW and context monitors only work with claude adapters (require hooks/screen-scraping).
#   For non-claude adapters, these monitors are automatically disabled.
#
# Variables:
#   agent_name   (required) - Unique agent identifier
#   track_name   (required) - Track name for logging/identification
#   workdir      (required) - Working directory (typically a worktree path)
#   task_prompt  (required) - The main task prompt for the agent
#   adapter      (default: "claude") - Agent adapter (claude, claude-opus, claude-sonnet, opencode, codex)
#   spawn_args   (default: "") - Extra CLI args passed to agent
#   enable_rw    (default: "true") - Enable Ralph Wiggum persistence monitor (claude only)
#   max_nudges   (default: "10") - RW safety limit before force-completing
#   enable_context_monitor (default: "true") - Enable context usage auto-compact (claude only)
#   context_threshold (default: "70") - Context % to trigger /compact
#
# Usage:
#   [[main.steps]]
#   id = "worker-1"
#   executor = "expand"
#   template = "lib/agent-track"
#   variables = {
#     agent_name = "agent-1",
#     track_name = "feature-x",
#     workdir = "{{setup-worktree.create.outputs.path}}",
#     task_prompt = "Implement feature X...",
#     adapter = "claude-opus"
#   }
#
# ============================================================================

[main]
name = "agent-track"
description = "Complete agent lifecycle with work, review, cleanup, and parallel monitors"

[main.variables]
agent_name = { required = true, description = "Unique agent identifier" }
track_name = { required = true, description = "Track name for identification" }
workdir = { required = true, description = "Working directory path" }
task_prompt = { required = true, description = "Main task prompt" }
adapter = { default = "claude", description = "Agent adapter (claude, claude-opus, claude-sonnet, opencode, codex)" }
spawn_args = { default = "", description = "Extra CLI args passed to agent" }
enable_rw = { default = "true", description = "Enable Ralph Wiggum persistence monitor (claude adapters only)" }
max_nudges = { default = "10", description = "Max nudges before force-completing (Ralph Wiggum safety limit)" }
enable_context_monitor = { default = "true", description = "Enable context usage monitor with auto-compact (claude adapters only)" }
context_threshold = { default = "70", description = "Context % to trigger auto-compact (0-100)" }

# ============================================================================
# Step 1: Setup Hooks (for agent-stopped events, claude adapters only)
# ============================================================================

[[main.steps]]
id = "setup-hooks"
executor = "branch"
condition = "echo '{{adapter}}' | grep -q '^claude'"

[main.steps.on_true]
template = "lib/claude-events#setup-stop-hook"
variables = { worktree = "{{workdir}}" }

[main.steps.on_false]
inline = [{ id = "skip", executor = "shell", command = "echo 'Hooks not available for {{adapter}} adapter - RW monitor will be disabled'" }]

# ============================================================================
# Step 2: Spawn Agent
# ============================================================================

[[main.steps]]
id = "spawn"
executor = "spawn"
agent = "{{agent_name}}"
adapter = "{{adapter}}"
workdir = "{{workdir}}"
spawn_args = "{{spawn_args}}"
needs = ["setup-hooks"]

# ============================================================================
# Step 3: Ralph Wiggum Persistence Monitor (runs in parallel, claude only)
# ============================================================================
#
# Monitors for unexpected agent stops and re-injects nudge prompts.
# Runs in parallel with work/review/verify-clean steps.
# Self-terminates when verify-clean completes.
# Only works with claude adapters (requires Stop hook events).
# Disable with enable_rw = "false"

[[main.steps]]
id = "persistence"
executor = "branch"
condition = "test '{{enable_rw}}' = 'true' && echo '{{adapter}}' | grep -q '^claude'"
needs = ["spawn"]

[main.steps.on_true]
template = "lib/agent-persistence#monitor"
variables = { agent = "{{agent_name}}", check_step = "verify-clean", max_loops = "{{max_nudges}}", nudge_prompt = "You stopped unexpectedly. Continue with your assigned task for {{track_name}}.\n\nRemember:\n- Complete your current work\n- Run tests to verify\n- Commit your changes\n- When fully done, run: `meow done`" }

[main.steps.on_false]
inline = [{ id = "skip", executor = "shell", command = "echo 'RW persistence monitor skipped (enable_rw={{enable_rw}}, adapter={{adapter}})'" }]

# ============================================================================
# Step 4: Context Monitor (runs in parallel, claude only)
# ============================================================================
#
# Monitors agent context usage and auto-compacts when above threshold.
# Runs in parallel with work/review/verify-clean steps.
# Self-terminates when agent tmux session is killed.
# Only works with claude adapters (screen-scrapes claude-specific format).
# Disable with enable_context_monitor = "false"

[[main.steps]]
id = "context-monitor"
executor = "branch"
condition = "test '{{enable_context_monitor}}' = 'true' && echo '{{adapter}}' | grep -q '^claude'"
needs = ["spawn"]

[main.steps.on_true]
template = "lib/claude-utils#context-monitor"
variables = { agent = "{{agent_name}}", threshold = "{{context_threshold}}" }

[main.steps.on_false]
inline = [
  { id = "skip", executor = "shell", command = "echo 'Context monitor skipped (enable_context_monitor={{enable_context_monitor}}, adapter={{adapter}})'" }
]

# ============================================================================
# Step 5: Main Work
# ============================================================================

[[main.steps]]
id = "work"
executor = "agent"
agent = "{{agent_name}}"
needs = ["spawn"]
prompt = "{{task_prompt}}"

# ============================================================================
# Step 6: Self-Review
# ============================================================================

[[main.steps]]
id = "review"
executor = "agent"
agent = "{{agent_name}}"
needs = ["work"]
prompt = """
# Self-Review: {{track_name}} Track

Take a step back and carefully reread your most recent code changes with fresh eyes.

## Review Checklist
1. **Read each file you modified** - look at the actual code, not your memory of it
2. **Check for obvious bugs** - nil pointer dereferences, off-by-one errors, typos
3. **Check for logical errors** - does the code actually do what it claims?
4. **Verify test coverage** - do tests actually test the important behavior?
5. **Check imports** - any unused imports? Missing imports that will cause build failures?
6. **Run tests** - `go test -short ./...`

## Actions
- Fix anything you spot without waiting for direction
- If you make fixes, commit them with message: "fix: self-review corrections for {{track_name}}"

## When Done
```
meow done
```
"""

# ============================================================================
# Step 7: Verify Clean Git State
# ============================================================================

[[main.steps]]
id = "verify-clean"
executor = "shell"
needs = ["review"]
command = """
cd "{{workdir}}"

# Check for uncommitted changes (excluding workflow metadata and beads daemon files)
# Excluded:
#   - .meow-branch: workflow metadata tracking current branch
#   - .beads/daemon.*: beads daemon lock/log files that change during operation
#   - .beads/issues.jsonl: beads database that syncs separately
CHANGES=$(git status --porcelain | grep -v -E '^\\?\\? \\.meow-branch$|^\\?\\? \\.beads/daemon\\.|^\\?\\? \\.beads/issues\\.jsonl$|^ M \\.beads/daemon\\.|^ M \\.beads/issues\\.jsonl$' || true)
if [ -n "$CHANGES" ]; then
    echo "ERROR: Uncommitted changes in {{track_name}} track!" >&2
    echo "$CHANGES" >&2
    exit 1
fi

echo "Track {{track_name}} is clean - all changes committed"
"""

# ============================================================================
# Step 8: Kill Agent
# ============================================================================
#
# Kill depends on review (not verify-clean) so agent cleanup always happens.
# This prevents agents from being left alive if verify-clean fails.

[[main.steps]]
id = "kill"
executor = "kill"
agent = "{{agent_name}}"
needs = ["review"]
graceful = true

# ============================================================================
# Step 9: Done Marker (for downstream dependencies)
# ============================================================================
#
# Done depends on BOTH kill and verify-clean.
# - kill ensures agent is cleaned up
# - verify-clean ensures no uncommitted changes
# If verify-clean fails, done fails, but agent is still killed.

[[main.steps]]
id = "done"
executor = "shell"
command = "echo '{{track_name}} track complete'"
needs = ["kill", "verify-clean"]


