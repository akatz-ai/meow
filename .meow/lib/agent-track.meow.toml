# ============================================================================
# MEOW Library: Agent Track Lifecycle
# ============================================================================
#
# Complete agent lifecycle: spawn → work → review → verify-clean → kill
# With Ralph Wiggum persistence monitor and context monitor running in parallel.
#
# This is the battle-tested pattern extracted from dual/quad agent workflows.
# Each agent works in isolation, self-reviews, ensures clean git state, then exits.
# The RW monitor ensures agents don't get stuck by re-nudging on unexpected stops.
# The context monitor auto-compacts when context usage is high.
#
# Variables:
#   agent_name   (required) - Unique agent identifier
#   track_name   (required) - Track name for logging/identification
#   workdir      (required) - Working directory (typically a worktree path)
#   task_prompt  (required) - The main task prompt for the agent
#   spec_file    (default: "none") - Spec file to read first, or "none" to skip
#   spawn_args   (default: "") - Extra CLI args for claude
#   enable_rw    (default: "true") - Enable Ralph Wiggum persistence monitor
#   max_nudges   (default: "10") - RW safety limit before force-completing
#   enable_context_monitor (default: "true") - Enable context usage auto-compact
#   context_threshold (default: "70") - Context % to trigger /compact
#
# Usage:
#   [[main.steps]]
#   id = "worker-1"
#   executor = "expand"
#   template = "lib/agent-track"
#   variables = {
#     agent_name = "agent-1",
#     track_name = "feature-x",
#     workdir = "{{setup-worktree.create.outputs.path}}",
#     task_prompt = "Implement feature X..."
#   }
#
# ============================================================================

[main]
name = "agent-track"
description = "Complete agent lifecycle with work, review, cleanup, and parallel monitors"

[main.variables]
agent_name = { required = true, description = "Unique agent identifier" }
track_name = { required = true, description = "Track name for identification" }
workdir = { required = true, description = "Working directory path" }
task_prompt = { required = true, description = "Main task prompt" }
spec_file = { default = "none", description = "Spec file to read first (or 'none' to skip - task prompts should be self-contained)" }
spawn_args = { default = "", description = "Extra CLI args for claude (e.g., --model opus)" }
enable_rw = { default = "true", description = "Enable Ralph Wiggum persistence monitor (true/false)" }
max_nudges = { default = "10", description = "Max nudges before force-completing (Ralph Wiggum safety limit)" }
enable_context_monitor = { default = "true", description = "Enable context usage monitor with auto-compact (true/false)" }
context_threshold = { default = "70", description = "Context % to trigger auto-compact (0-100)" }

# ============================================================================
# Step 1: Setup Hooks (for agent-stopped events)
# ============================================================================

[[main.steps]]
id = "setup-hooks"
executor = "expand"
template = "lib/claude-events#setup-stop-hook"
variables = { worktree = "{{workdir}}" }

# ============================================================================
# Step 2: Spawn Agent
# ============================================================================

[[main.steps]]
id = "spawn"
executor = "spawn"
agent = "{{agent_name}}"
workdir = "{{workdir}}"
spawn_args = "{{spawn_args}}"
needs = ["setup-hooks"]

# ============================================================================
# Step 3: Ralph Wiggum Persistence Monitor (runs in parallel, optional)
# ============================================================================
#
# Monitors for unexpected agent stops and re-injects nudge prompts.
# Runs in parallel with work/review/verify-clean steps.
# Self-terminates when verify-clean completes.
# Disable with enable_rw = "false"

[[main.steps]]
id = "persistence"
executor = "expand"
template = "lib/agent-persistence#optional-monitor"
needs = ["spawn"]

[main.steps.variables]
agent = "{{agent_name}}"
check_step = "verify-clean"
enable = "{{enable_rw}}"
max_loops = "{{max_nudges}}"
nudge_prompt = "You stopped unexpectedly. Continue with your assigned task for {{track_name}}.\n\nRemember:\n- Complete your current work\n- Run tests to verify\n- Commit your changes\n- When fully done, run: `meow done`"

# ============================================================================
# Step 4: Context Monitor (runs in parallel, optional)
# ============================================================================
#
# Monitors agent context usage and auto-compacts when above threshold.
# Runs in parallel with work/review/verify-clean steps.
# Self-terminates when agent tmux session is killed.
# Disable with enable_context_monitor = "false"

[[main.steps]]
id = "context-monitor"
executor = "branch"
condition = "test '{{enable_context_monitor}}' = 'true'"
needs = ["spawn"]

[main.steps.on_true]
template = "lib/claude-utils#context-monitor"
variables = { agent = "{{agent_name}}", threshold = "{{context_threshold}}" }

[main.steps.on_false]
inline = [
  { id = "skip", executor = "shell", command = "echo 'Context monitor disabled (enable_context_monitor=false)'" }
]

# ============================================================================
# Step 5: Main Work (with optional spec file)
# ============================================================================
#
# Uses branch to conditionally include spec file reading based on spec_file value.

[[main.steps]]
id = "check-spec"
executor = "branch"
condition = "test '{{spec_file}}' != 'none' && test -f '{{spec_file}}'"
needs = ["spawn"]

# Spec file exists - include it in the prompt
[main.steps.on_true]
template = ".work-with-spec"
variables = { agent_name = "{{agent_name}}", track_name = "{{track_name}}", task_prompt = "{{task_prompt}}", spec_file = "{{spec_file}}" }

# No spec file - work without it
[main.steps.on_false]
template = ".work-no-spec"
variables = { agent_name = "{{agent_name}}", track_name = "{{track_name}}", task_prompt = "{{task_prompt}}" }

# ============================================================================
# Step 6: Self-Review
# ============================================================================

[[main.steps]]
id = "review"
executor = "agent"
agent = "{{agent_name}}"
needs = ["check-spec"]
prompt = """
# Self-Review: {{track_name}} Track

Take a step back and carefully reread your most recent code changes with fresh eyes.

## Review Checklist
1. **Read each file you modified** - look at the actual code, not your memory of it
2. **Check for obvious bugs** - nil pointer dereferences, off-by-one errors, typos
3. **Check for logical errors** - does the code actually do what it claims?
4. **Verify test coverage** - do tests actually test the important behavior?
5. **Check imports** - any unused imports? Missing imports that will cause build failures?
6. **Run tests** - `go test -short ./...`

## Actions
- Fix anything you spot without waiting for direction
- If you make fixes, commit them with message: "fix: self-review corrections for {{track_name}}"

## When Done
```
meow done
```
"""

# ============================================================================
# Step 7: Verify Clean Git State
# ============================================================================

[[main.steps]]
id = "verify-clean"
executor = "shell"
needs = ["review"]
command = """
cd "{{workdir}}"

# Check for uncommitted changes (excluding workflow metadata and beads daemon files)
# Excluded:
#   - .meow-branch: workflow metadata tracking current branch
#   - .beads/daemon.*: beads daemon lock/log files that change during operation
#   - .beads/issues.jsonl: beads database that syncs separately
CHANGES=$(git status --porcelain | grep -v -E '^\?\? \.meow-branch$|^\?\? \.beads/daemon\.|^\?\? \.beads/issues\.jsonl$|^ M \.beads/daemon\.|^ M \.beads/issues\.jsonl$' || true)
if [ -n "$CHANGES" ]; then
    echo "ERROR: Uncommitted changes in {{track_name}} track!" >&2
    echo "$CHANGES" >&2
    exit 1
fi

echo "Track {{track_name}} is clean - all changes committed"
"""

# ============================================================================
# Step 8: Kill Agent
# ============================================================================

[[main.steps]]
id = "kill"
executor = "kill"
agent = "{{agent_name}}"
needs = ["verify-clean"]
graceful = true

# ============================================================================
# Step 9: Done Marker (for downstream dependencies)
# ============================================================================

[[main.steps]]
id = "done"
executor = "shell"
command = "echo '{{track_name}} track complete'"
needs = ["kill"]


# ============================================================================
# INTERNAL: Work step variants
# ============================================================================

[work-with-spec]
name = "work-with-spec"
description = "Internal: Work step that includes spec file reading"
internal = true

[work-with-spec.variables]
agent_name = { required = true }
track_name = { required = true }
task_prompt = { required = true }
spec_file = { required = true }

[[work-with-spec.steps]]
id = "work"
executor = "agent"
agent = "{{agent_name}}"
prompt = """
# {{track_name}} Agent Task

## FIRST: Read the Specification
Before doing ANY work, read the complete specification:

@{{spec_file}}

This is REQUIRED. The spec defines all types, patterns, and constraints you must follow.

---

{{task_prompt}}

---

## IMPORTANT CONSTRAINTS
- **ONLY** implement the work described above
- Do NOT work on unrelated beads or issues you might see
- Do NOT modify files outside your assignment scope
- If you discover related work needed, note it but do NOT implement it

## Workflow
1. If beads are referenced, run `bd show <bead-id>` for full requirements
2. Write tests first (TDD approach) when implementing code
3. Implement the minimum code to pass tests
4. Commit after each logical unit with a clear message
5. If beads are referenced, close them as you complete: `bd close <bead-id>`

## When Done
After ALL your assigned work is complete, run:

```
meow done
```
"""


[work-no-spec]
name = "work-no-spec"
description = "Internal: Work step without spec file"
internal = true

[work-no-spec.variables]
agent_name = { required = true }
track_name = { required = true }
task_prompt = { required = true }

[[work-no-spec.steps]]
id = "work"
executor = "agent"
agent = "{{agent_name}}"
prompt = """
# {{track_name}} Agent Task

{{task_prompt}}

---

## IMPORTANT CONSTRAINTS
- **ONLY** implement the work described above
- Do NOT work on unrelated beads or issues you might see
- Do NOT modify files outside your assignment scope
- If you discover related work needed, note it but do NOT implement it

## Workflow
1. If beads are referenced, run `bd show <bead-id>` for full requirements
2. Write tests first (TDD approach) when implementing code
3. Implement the minimum code to pass tests
4. Commit after each logical unit with a clear message
5. If beads are referenced, close them as you complete: `bd close <bead-id>`

## When Done
After ALL your assigned work is complete, run:

```
meow done
```
"""
