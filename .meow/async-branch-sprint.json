[
  {
    "name": "types-and-parser",
    "prompt": "# Task: Enhance BranchConfig and Template Parser (meow-95qc)\n\nYou are implementing the types layer for shell-as-sugar. This MUST be done before the orchestrator changes.\n\n## Read First\n\n```bash\nbd show meow-95qc\n```\n\n## Part 1: Update BranchConfig\n\nIn `internal/types/step.go`, add these fields to `BranchConfig`:\n\n```go\n// BranchConfig for executor: branch\ntype BranchConfig struct {\n    Condition string        `yaml:\"condition\" toml:\"condition\"` // Shell command, exit 0 = true\n    OnTrue    *BranchTarget `yaml:\"on_true,omitempty\" toml:\"on_true,omitempty\"`\n    OnFalse   *BranchTarget `yaml:\"on_false,omitempty\" toml:\"on_false,omitempty\"`\n    OnTimeout *BranchTarget `yaml:\"on_timeout,omitempty\" toml:\"on_timeout,omitempty\"`\n    Timeout   string        `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"` // Duration string\n    \n    // Shell-compatible fields for unified command execution\n    Workdir string                  `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env     map[string]string       `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    Outputs map[string]OutputSource `yaml:\"outputs,omitempty\" toml:\"outputs,omitempty\"`\n    OnError string                  `yaml:\"on_error,omitempty\" toml:\"on_error,omitempty\"` // continue | fail\n}\n```\n\n## Part 2: Update Template Parser\n\nIn `internal/template/parser.go`, ensure the TOML parser recognizes these new fields for branch steps.\n\nLook for how shell steps parse `workdir`, `env`, `outputs`, `on_error` and apply similar logic to branch steps.\n\n## Part 3: Update Template Baker\n\nIn `internal/template/baker.go`, update `setBranchConfig` (or equivalent) to handle the new fields when baking steps.\n\n## Testing\n\n```bash\ngo build ./...\ngo test -short ./internal/types/...\ngo test -short ./internal/template/...\n```\n\nMake sure existing tests pass.\n\n## When Done\n\nCommit with message:\n```\nfeat(types): Add shell-compatible fields to BranchConfig\n\nAdd Workdir, Env, Outputs, OnError fields to enable shell-as-sugar.\nBranch can now capture command outputs like shell.\n```\n\nThen:\n```bash\nbd close meow-95qc\nmeow done\n```",
    "beads": "meow-95qc"
  },
  {
    "name": "orchestrator-async-core",
    "prompt": "# Task: Implement Async Command Execution Core\n\nYou are implementing the async execution infrastructure in orchestrator.go.\n\n## Read ALL These Beads First\n\n```bash\nbd show meow-fh5t  # pendingCommands tracking\nbd show meow-2jtq  # handleBranch refactor  \nbd show meow-fut5  # executeBranchConditionAsync\nbd show meow-qfap  # cancelPendingCommands\nbd show meow-8ahz  # signal integration\n```\n\n## Implementation Order\n\n### Step 1: Add pendingCommands field (meow-fh5t)\n\nIn Orchestrator struct, add:\n```go\npendingCommands sync.Map  // Key: stepID (string), Value: context.CancelFunc\n```\n\n### Step 2: Refactor handleBranch (meow-2jtq)\n\n```go\nfunc (o *Orchestrator) handleBranch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Branch == nil {\n        return fmt.Errorf(\"branch step %s missing config\", step.ID)\n    }\n    if err := step.Start(); err != nil {\n        return fmt.Errorf(\"starting step: %w\", err)\n    }\n    \n    cfg := step.Branch\n    condition := o.resolveOutputRefs(wf, cfg.Condition)\n    \n    // Capture IDs by value for goroutine\n    workflowID := wf.ID\n    stepID := step.ID\n    \n    // Create cancellable context\n    condCtx, cancel := context.WithCancel(ctx)\n    if cfg.Timeout != \"\" {\n        timeout, err := time.ParseDuration(cfg.Timeout)\n        if err != nil {\n            cancel()\n            return fmt.Errorf(\"invalid timeout: %w\", err)\n        }\n        condCtx, cancel = context.WithTimeout(ctx, timeout)\n    }\n    \n    // Track for cleanup\n    o.pendingCommands.Store(stepID, cancel)\n    \n    // Launch async\n    o.wg.Add(1)\n    go func() {\n        defer o.wg.Done()\n        o.executeBranchConditionAsync(condCtx, workflowID, stepID, condition, cfg)\n    }()\n    \n    return nil  // Step stays running\n}\n```\n\n### Step 3: Add executeBranchConditionAsync (meow-fut5)\n\nNew function that:\n1. Removes from pendingCommands on completion\n2. Executes condition command\n3. Captures stdout, stderr, exit_code\n4. Determines outcome (true/false/timeout)\n5. Calls completeBranchCondition (we'll add this next)\n\n### Step 4: Add cancelPendingCommands (meow-qfap)\n\n```go\nfunc (o *Orchestrator) cancelPendingCommands() {\n    o.pendingCommands.Range(func(key, value any) bool {\n        if cancel, ok := value.(context.CancelFunc); ok {\n            cancel()\n        }\n        return true\n    })\n}\n```\n\n### Step 5: Integrate with signals (meow-8ahz)\n\nIn the Run() method's signal handling, add:\n```go\ncase sig := <-sigChan:\n    o.logger.Info(\"received signal\", \"signal\", sig)\n    o.cancelPendingCommands()  // NEW: Cancel in-flight commands\n    o.wg.Wait()\n    // ... rest of cleanup\n```\n\n## Testing After Each Step\n\n```bash\ngo build ./...\ngo test -short ./internal/orchestrator/...\n```\n\n## Commits\n\nCommit after each step:\n- `feat(orchestrator): Add pendingCommands sync.Map`\n- `feat(orchestrator): Make handleBranch async`\n- `feat(orchestrator): Add executeBranchConditionAsync`\n- `feat(orchestrator): Add cancelPendingCommands helper`\n- `feat(orchestrator): Integrate cancellation with signal handling`\n\n## When Done\n\n```bash\nbd close meow-fh5t meow-2jtq meow-fut5 meow-qfap meow-8ahz\nmeow done\n```",
    "beads": "meow-fh5t meow-2jtq meow-fut5 meow-qfap meow-8ahz"
  },
  {
    "name": "orchestrator-completion",
    "prompt": "# Task: Implement Completion Handler and Shell Delegation\n\nYou are implementing the completion handler and shell-as-sugar delegation.\n\n## Read These Beads First\n\n```bash\nbd show meow-ikbm  # completeBranchCondition\nbd show meow-0g52  # recovery update\nbd show meow-fmur  # handleShell delegation\n```\n\n## Implementation Order\n\n### Step 1: Implement completeBranchCondition (meow-ikbm)\n\nThis is the critical completion handler. Add to orchestrator.go:\n\n```go\n// completeBranchCondition finalizes a branch/shell step after command completes.\n// Called from goroutine - acquires mutex for thread-safe state mutation.\nfunc (o *Orchestrator) completeBranchCondition(\n    ctx context.Context,\n    workflowID string,\n    stepID string,\n    outcome BranchOutcome,\n    target *types.BranchTarget,\n    result *ShellResult,\n    cfg *types.BranchConfig,\n) {\n    o.wfMu.Lock()\n    defer o.wfMu.Unlock()\n    \n    // Re-fetch workflow (CRITICAL - avoid overwriting concurrent changes)\n    wf, err := o.store.Get(ctx, workflowID)\n    if err != nil || wf == nil || wf.Status.IsTerminal() {\n        return\n    }\n    \n    step, ok := wf.GetStep(stepID)\n    if !ok || step.Status != types.StepStatusRunning {\n        return\n    }\n    \n    // Expand target if present (branch semantics)\n    if target != nil {\n        if err := o.expandBranchTarget(ctx, wf, step, target); err != nil {\n            step.Fail(&types.StepError{Message: err.Error()})\n            o.store.Save(ctx, wf)\n            return\n        }\n    }\n    \n    // Build outputs\n    outputs := map[string]any{\n        \"outcome\":   string(outcome),\n        \"exit_code\": result.ExitCode,\n    }\n    \n    // Capture defined outputs (shell-as-sugar)\n    if cfg.Outputs != nil {\n        for name, source := range cfg.Outputs {\n            outputs[name], _ = captureOutput(source.Source, result)\n        }\n    }\n    \n    // Handle on_error for shell-as-sugar (no expansion targets)\n    if target == nil && result.ExitCode != 0 && cfg.OnError == \"fail\" {\n        step.Fail(&types.StepError{\n            Message: \"command failed\",\n            Code:    result.ExitCode,\n            Output:  result.Stderr,\n        })\n        o.store.Save(ctx, wf)\n        return\n    }\n    \n    // Complete or stay running\n    if len(step.ExpandedInto) > 0 {\n        step.Outputs = outputs  // Has children, stay running\n    } else {\n        step.Complete(outputs)\n    }\n    \n    o.store.Save(ctx, wf)\n}\n```\n\n### Step 2: Update Recover (meow-0g52)\n\nIn the Recover() function, add handling for in-flight branch/shell steps:\n\n```go\n// Reset in-flight branch/shell conditions to pending\nfor _, step := range wf.Steps {\n    if step.Status == types.StepStatusRunning {\n        if step.Executor == types.ExecutorBranch || step.Executor == types.ExecutorShell {\n            // If no expansion happened, reset to pending\n            if len(step.ExpandedInto) == 0 {\n                step.ResetToPending()\n            }\n        }\n    }\n}\n```\n\n### Step 3: Make handleShell delegate (meow-fmur)\n\n```go\nfunc (o *Orchestrator) handleShell(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Shell == nil {\n        return fmt.Errorf(\"shell step %s missing config\", step.ID)\n    }\n    \n    // Convert shell config to branch config\n    step.Branch = &types.BranchConfig{\n        Condition: step.Shell.Command,\n        Workdir:   step.Shell.Workdir,\n        Env:       step.Shell.Env,\n        Outputs:   step.Shell.Outputs,\n        OnError:   step.Shell.OnError,\n        // No on_true/on_false = shell semantics\n    }\n    step.Shell = nil\n    \n    // Delegate to async branch handler\n    return o.handleBranch(ctx, wf, step)\n}\n```\n\n## Testing\n\n```bash\ngo build ./...\ngo test -short ./internal/orchestrator/...\n```\n\n## Commits\n\n- `feat(orchestrator): Add completeBranchCondition with output capture`\n- `feat(orchestrator): Update Recover for async command steps`\n- `feat(orchestrator): Make handleShell delegate to handleBranch`\n\n## When Done\n\n```bash\nbd close meow-ikbm meow-0g52 meow-fmur\nmeow done\n```",
    "beads": "meow-ikbm meow-0g52 meow-fmur"
  }
]
