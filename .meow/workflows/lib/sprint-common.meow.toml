# ============================================================================
# MEOW Library: Sprint Common Templates
# ============================================================================
#
# Shared templates for sprint workflows (parallel and sequential).
# These templates handle worktree setup, integration, and agent track wrapping.
#
# Available templates:
#   - setup: Creates worktrees and enriches task list
#   - integration: Merges all task branches
#   - agent-track-wrapper: Wraps lib/agent-track with spec handling
#
# ============================================================================


# ============================================================================
# SETUP (Public)
# ============================================================================
#
# Creates worktrees for each task and an integration worktree.
# Parses JSON tasks format and detects task system (beads, jira, etc.)
#
# Variables:
#   tasks (required) - JSON array: [{"name": "track1", "<task_system>": ["id1", "id2"]}]
#
# Outputs (via files):
#   .meow/worktrees/.enriched-tasks.json - Tasks with task_system, task_ids, workdir, branch
#   .meow/worktrees/.track-dirs - Comma-separated list of track directories
#   .meow/worktrees/.integration-path - Path to integration worktree
#
# Usage:
#   [[main.steps]]
#   id = "setup"
#   executor = "expand"
#   template = "lib/sprint-common#setup"
#   variables = { tasks = "{{tasks}}" }

[setup]
name = "sprint-setup"
description = "Create worktrees and prepare enriched task list"

[setup.variables]
tasks = { required = true, description = "JSON array: [{name, <task_system>: [ids]}]" }

# Step 1: Parse and validate tasks JSON using shared utils
[[setup.steps]]
id = "parse-tasks"
executor = "expand"
template = "lib/utils#parse-tasks"
variables = { tasks = "{{tasks}}", output_file = ".meow/worktrees/.parsed-tasks.json" }

# Step 2: Create worktrees from parsed tasks
[[setup.steps]]
id = "create-worktrees"
executor = "shell"
description = "Create git worktrees for each parsed task"
needs = ["parse-tasks.done"]
command = """
set -e
mkdir -p .meow/worktrees

PARSED_FILE=".meow/worktrees/.parsed-tasks.json"
TASK_COUNT=$(jq 'length' "$PARSED_FILE")

echo "Creating $TASK_COUNT worktrees..." >&2

# Build enriched tasks array (adds workdir and branch to parsed tasks)
ENRICHED='[]'

for i in $(seq 0 $((TASK_COUNT - 1))); do
  # Read from parsed tasks
  NAME=$(jq -r '.['$i'].name' "$PARSED_FILE")
  TASK_SYSTEM=$(jq -r '.['$i'].task_system' "$PARSED_FILE")
  TASK_IDS=$(jq -r '.['$i'].task_ids' "$PARSED_FILE")

  # Create worktree
  WORKTREE=".meow/worktrees/${NAME}-track"
  BRANCH="${NAME}-track-$(date +%s)"

  # Clean up any existing worktree
  if [ -d "$WORKTREE" ]; then
    echo "  Cleaning up existing worktree: $WORKTREE" >&2
    git worktree remove "$WORKTREE" --force 2>/dev/null || rm -rf "$WORKTREE"
  fi

  echo "  Creating worktree: $WORKTREE ($BRANCH) [$TASK_SYSTEM: $TASK_IDS]" >&2
  git worktree add -b "$BRANCH" "$WORKTREE" HEAD >&2

  # Add to enriched array (includes workdir and branch)
  ENRICHED=$(printf '%s' "$ENRICHED" | jq -c \
    --arg name "$NAME" \
    --arg task_system "$TASK_SYSTEM" \
    --arg task_ids "$TASK_IDS" \
    --arg workdir "$WORKTREE" \
    --arg branch "$BRANCH" \
    --argjson index "$i" \
    '. + [{
      "name": $name,
      "task_system": $task_system,
      "task_ids": $task_ids,
      "workdir": $workdir,
      "branch": $branch,
      "index": $index
    }]')
done

# Create integration worktree
INT_WORKTREE=".meow/worktrees/sprint-integration-track"
INT_BRANCH="sprint-integration-track-$(date +%s)"

if [ -d "$INT_WORKTREE" ]; then
  echo "  Cleaning up existing integration worktree" >&2
  git worktree remove "$INT_WORKTREE" --force 2>/dev/null || rm -rf "$INT_WORKTREE"
fi

echo "  Creating integration worktree: $INT_WORKTREE ($INT_BRANCH)" >&2
git worktree add -b "$INT_BRANCH" "$INT_WORKTREE" HEAD >&2

echo "Setup complete: $TASK_COUNT task worktrees + integration" >&2

# Write enriched tasks to file for downstream steps
printf '%s' "$ENRICHED" > .meow/worktrees/.enriched-tasks.json

# Write track dirs list
TRACK_DIRS=$(printf '%s' "$ENRICHED" | jq -r '[.[].name] | map(. + "-track") | join(", ")')
echo "$TRACK_DIRS" > .meow/worktrees/.track-dirs

# Write integration worktree path
echo ".meow/worktrees/sprint-integration-track" > .meow/worktrees/.integration-path

echo "Setup complete"
"""

[[setup.steps]]
id = "validate"
executor = "shell"
description = "Validate metadata files were created"
needs = ["create-worktrees"]
command = """
set -e

# Verify files exist
test -f .meow/worktrees/.enriched-tasks.json || { echo "ERROR: .enriched-tasks.json not found" >&2; exit 1; }
test -f .meow/worktrees/.track-dirs || { echo "ERROR: .track-dirs not found" >&2; exit 1; }
test -f .meow/worktrees/.integration-path || { echo "ERROR: .integration-path not found" >&2; exit 1; }

echo "Metadata validated:"
echo "  - Enriched tasks: $(jq 'length' .meow/worktrees/.enriched-tasks.json) tasks"
echo "  - Track dirs: $(cat .meow/worktrees/.track-dirs)"
"""

[[setup.steps]]
id = "done"
executor = "shell"
command = "echo 'Sprint setup complete'"
needs = ["validate"]


# ============================================================================
# INTEGRATION (Public)
# ============================================================================
#
# Spawns an integration agent to merge all task branches.
# Reads track directories from .meow/worktrees/.track-dirs.
#
# Variables:
#   spawn_args (optional) - Extra CLI args for spawned agent
#
# Usage:
#   [[main.steps]]
#   id = "integration"
#   executor = "expand"
#   template = "lib/sprint-common#integration"
#   variables = { spawn_args = "{{spawn_args}}" }

[integration]
name = "sprint-integration"
description = "Integration agent that merges all task branches"

[integration.variables]
spawn_args = { default = "", description = "Extra CLI args passed to agent" }
merge_adapter = { default = "opencode", description = "Agent adapter for merge/integration (opencode, claude, claude-opus, codex)" }
target_branch = { default = "main", description = "Target branch to merge into" }
skip_merge_to_target = { default = "false", description = "If true, skip final merge to target (just merge tracks)" }
enable_rw = { default = "true", description = "Enable Ralph Wiggum persistence monitor (claude only)" }
max_nudges = { default = "10", description = "Max nudges before force-completing" }

# Setup stop hook for RW monitoring (claude adapters only)
[[integration.steps]]
id = "setup-hooks"
executor = "branch"
condition = "echo '{{merge_adapter}}' | grep -q '^claude'"

[integration.steps.on_true]
template = "lib/claude-events#setup-stop-hook"
variables = { worktree = ".meow/worktrees/sprint-integration-track" }

[integration.steps.on_false]
inline = [{ id = "skip", executor = "shell", command = "echo 'Hooks not available for {{merge_adapter}} adapter'" }]

[[integration.steps]]
id = "spawn"
executor = "spawn"
agent = "agent-integration"
adapter = "{{merge_adapter}}"
workdir = ".meow/worktrees/sprint-integration-track"
spawn_args = "{{spawn_args}}"
needs = ["setup-hooks"]

# Ralph Wiggum persistence monitor (parallel with work/review, claude only)
[[integration.steps]]
id = "persistence"
executor = "branch"
condition = "test '{{enable_rw}}' = 'true' && echo '{{merge_adapter}}' | grep -q '^claude'"
needs = ["spawn"]

[integration.steps.on_true]
template = "lib/agent-persistence#monitor"
variables = { agent = "agent-integration", check_step = "review", max_loops = "{{max_nudges}}", nudge_prompt = "You stopped unexpectedly. Continue with your integration task.\n\nRemember:\n- Merge all track branches\n- Resolve any conflicts\n- Run tests to verify\n- Update local target branch (do NOT push to remote)\n- When fully done, run: `meow done`" }

[integration.steps.on_false]
inline = [{ id = "skip", executor = "shell", command = "echo 'RW persistence monitor skipped (enable_rw={{enable_rw}}, merge_adapter={{merge_adapter}})'" }]

[[integration.steps]]
id = "work"
executor = "agent"
agent = "agent-integration"
needs = ["spawn"]
prompt = """
# Integration Agent: Merge All Sprint Tracks

You are inside the integration worktree (`.meow/worktrees/sprint-integration-track`).
Resolve the sprint metadata paths relative to the parent worktrees directory.

```bash
WORKTREES_DIR="$(dirname "$PWD")"
TARGET_BRANCH=$(cat "$WORKTREES_DIR/.target-branch")
TASKS_FILE="$WORKTREES_DIR/.enriched-tasks.json"
echo "Worktrees dir: $WORKTREES_DIR"
echo "Merging to: $TARGET_BRANCH"
```

Your job is to merge all feature branches into the target branch stored in `$WORKTREES_DIR/.target-branch`.
When parallel agents work on the same files, conflicts are expected. Resolve them.

## Step 1: Get Target Branch and Feature Branch Names

The authoritative source for branch names is `$TASKS_FILE`:
```bash
# Read branch info from the enriched tasks file (created fresh each sprint)
cat "$TASKS_FILE" | jq -r '.[] | "\\(.name): \\(.branch)"'
```

This file contains the exact branch names created for this sprint run.

## Step 2: Merge Each Branch

For each track in the enriched tasks:
```bash
# Example: merge agent1-track branch
BRANCH=$(jq -r '.[] | select(.name == "agent1") | .branch' .meow/worktrees/.enriched-tasks.json)
git merge "$BRANCH" --no-edit -m "Merge: agent1-track"
```

Or loop through all:
```bash
for row in $(jq -c '.[]' "$TASKS_FILE"); do
  NAME=$(echo "$row" | jq -r '.name')
  BRANCH=$(echo "$row" | jq -r '.branch')
  echo "Merging $NAME ($BRANCH)..."
  git merge "$BRANCH" --no-edit -m "Merge: $NAME-track"
done
```

If the merge succeeds, continue to the next branch.

## If Conflicts Occur

When you see "CONFLICT" in the output:
1. Run `git status` to see conflicted files
2. For test file conflicts:
   - Both branches typically added content at the end
   - Keep BOTH sets of content (combine them)
   - Remove conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`)
3. For other conflicts:
   - Read both versions carefully
   - Combine logically (don't lose either side's changes)
4. Stage resolved files: `git add <file>`
5. Complete the merge: `git commit -m "Merge: <track-name> (conflicts resolved)"`
6. Continue with the next branch

## Step 3: Verify Build and Tests

Check CLAUDE.md or AGENTS.md for project-specific build/test commands, then:
1. Run the project's build command to verify compilation passes
2. Run the project's test command to verify tests pass
3. If tests fail, fix the issues and commit

## Step 4: Update Local Target Branch

After all merges pass tests, update the local target branch:
```bash
WORKTREES_DIR="$(dirname "$PWD")"
TARGET_BRANCH=$(cat "$WORKTREES_DIR/.target-branch")

# Update local target branch to point to current HEAD (with all merges)
# This works even if target branch is checked out elsewhere
git branch -f "$TARGET_BRANCH" HEAD
```

**IMPORTANT: Do NOT push to remote.** This workflow uses ephemeral local branches.
The target branch is updated locally only. Pushing happens separately if needed.

When local target branch is updated: `meow done`
"""

[[integration.steps]]
id = "review"
executor = "agent"
agent = "agent-integration"
needs = ["work"]
prompt = """
# Integration Review

All tracks should be merged to the local target branch. Final verification:

```bash
WORKTREES_DIR="$(dirname "$PWD")"
TARGET_BRANCH=$(cat "$WORKTREES_DIR/.target-branch")
```

1. `git log --oneline -20` - verify all merges present
2. `git status` - verify clean state
3. Verify local target branch was updated:
   ```bash
   INTEGRATION_HEAD=$(git rev-parse HEAD)
   TARGET_HEAD=$(git rev-parse "$TARGET_BRANCH")
   echo "Integration HEAD: $INTEGRATION_HEAD"
   echo "Target $TARGET_BRANCH: $TARGET_HEAD"
   [ "$INTEGRATION_HEAD" = "$TARGET_HEAD" ] && echo "✓ Target branch updated" || echo "✗ Target branch NOT updated - run: git branch -f $TARGET_BRANCH HEAD"
   ```

**IMPORTANT: Do NOT push to remote or fetch from origin.** This is a local-only workflow.

If the target branch wasn't updated, run: `git branch -f "$TARGET_BRANCH" HEAD`

When verified: `meow done`
"""

[[integration.steps]]
id = "kill"
executor = "kill"
agent = "agent-integration"
needs = ["review"]
graceful = true

[[integration.steps]]
id = "done"
executor = "shell"
command = "echo 'Integration complete - all tracks merged successfully'"
needs = ["kill"]


# ============================================================================
# AGENT TRACK WRAPPER (Public)
# ============================================================================
#
# Wraps lib/agent-track for sprint foreach iterations.
# Passes task object and protocol to agent-track for protocol-based execution.
#
# Variables:
#   task (required) - Task object with {name, task_system, task_ids, workdir, branch, optional protocol}
#   i (required) - Task index (for agent naming)
#   protocol (default: "tdd") - Default protocol (can be overridden by task.protocol)
#   + all the standard agent track options
#
# Usage:
#   [[main.steps]]
#   id = "agent"
#   executor = "expand"
#   template = "lib/sprint-common#agent-track-wrapper"
#   variables = { task = "{{task}}", i = "{{i}}", protocol = "tdd", adapter = "claude-opus", ... }

[agent-track-wrapper]
name = "agent-track-wrapper"
description = "Wrapper for agent track - passes task object and protocol to agent-track"

[agent-track-wrapper.variables]
task = { required = true, description = "Task object with name, task_system, task_ids, workdir, optional protocol" }
i = { required = true, description = "Task index for agent naming" }
protocol = { default = "tdd", description = "Default protocol (can be overridden by task.protocol)" }
adapter = { default = "claude", description = "Agent adapter (claude, claude-opus, claude-sonnet, opencode, codex)" }
spawn_args = { default = "", description = "Extra CLI args passed to agent" }
enable_rw = { default = "true", description = "Enable Ralph Wiggum persistence monitor (claude only)" }
max_nudges = { default = "10", description = "Max nudges before force-completing" }
enable_context_monitor = { default = "true", description = "Enable context usage auto-compact (claude only)" }
context_threshold = { default = "80", description = "Context % to trigger /compact" }

# Step 1: Resolve protocol - task.protocol overrides default if present
[[agent-track-wrapper.steps]]
id = "resolve-protocol"
executor = "shell"
description = "Check if task has protocol override"
command = """
# Check if task has protocol override
TASK_PROTOCOL=$(echo '{{task}}' | jq -r '.protocol // empty' 2>/dev/null || echo "")
if [ -n "$TASK_PROTOCOL" ]; then
  echo "$TASK_PROTOCOL"
else
  echo "{{protocol}}"
fi
"""

[agent-track-wrapper.steps.outputs]
resolved_protocol = { source = "stdout" }

# Step 2: Expand agent-track with resolved protocol
[[agent-track-wrapper.steps]]
id = "track"
executor = "expand"
template = "lib/agent-track"
needs = ["resolve-protocol"]

[agent-track-wrapper.steps.variables]
agent_name = "agent-{{i}}"
track_name = "{{task.name}}"
workdir = "{{task.workdir}}"
task = "{{task}}"
protocol = "{{resolve-protocol.outputs.resolved_protocol}}"
adapter = "{{adapter}}"
spawn_args = "{{spawn_args}}"
enable_rw = "{{enable_rw}}"
max_nudges = "{{max_nudges}}"
enable_context_monitor = "{{enable_context_monitor}}"
context_threshold = "{{context_threshold}}"

# Done marker that downstream can reference
[[agent-track-wrapper.steps]]
id = "done"
executor = "shell"
command = "echo 'Track {{task.name}} complete'"
needs = ["track.done"]


# ============================================================================
# CLEANUP (Public)
# ============================================================================
#
# Cleans up sprint worktrees. Call this on success or manual cleanup.
#
# Usage:
#   [[main.steps]]
#   id = "cleanup"
#   executor = "expand"
#   template = "lib/sprint-common#cleanup"

[cleanup]
name = "sprint-cleanup"
description = "Clean up sprint worktrees"

[[cleanup.steps]]
id = "remove"
executor = "shell"
command = """
echo "Cleaning up sprint worktrees..."

# Parse task names from enriched file and remove each worktree
for name in $(jq -r '.[].name' .meow/worktrees/.enriched-tasks.json 2>/dev/null || echo ""); do
  git worktree remove ".meow/worktrees/${name}-track" --force 2>/dev/null || rm -rf ".meow/worktrees/${name}-track"
done

# Remove integration worktree
git worktree remove .meow/worktrees/sprint-integration-track --force 2>/dev/null || rm -rf .meow/worktrees/sprint-integration-track

# Clean up temp files
rm -f .meow/worktrees/.enriched-tasks.json .meow/worktrees/.tasks.json .meow/worktrees/.track-dirs .meow/worktrees/.integration-path

echo "Cleanup complete"
"""


# ============================================================================
# FINAL SUMMARY (Public)
# ============================================================================
#
# Prints summary of completed sprint.
#
# Variables:
#   target_branch - Target branch for final merge
#   skip_merge_to_target - Whether merge was skipped
#
# Usage:
#   [[main.steps]]
#   id = "summary"
#   executor = "expand"
#   template = "lib/sprint-common#summary"

[summary]
name = "sprint-summary"
description = "Print sprint completion summary"

[summary.variables]
target_branch = { default = "main", description = "Target branch" }
skip_merge_to_target = { default = "false", description = "Whether merge was skipped" }

[[summary.steps]]
id = "print"
executor = "shell"
command = """
echo "=============================================="
echo "  SPRINT COMPLETE"
echo "=============================================="
echo ""
echo "Tasks completed:"
jq -r '.[] | "  - \\(.name): \\(.branch)"' .meow/worktrees/.enriched-tasks.json
echo ""
TARGET_BRANCH=$(cat .meow/worktrees/.target-branch 2>/dev/null || echo "{{target_branch}}")
echo "Target branch: $TARGET_BRANCH"
echo "Skip merge mode: {{skip_merge_to_target}}"
echo "=============================================="
"""
