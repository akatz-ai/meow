# ============================================================================
# MEOW Library: Utility Templates
# ============================================================================
#
# Common utility templates for parsing, validation, and other reusable operations.
#
# Available templates:
#   - parse-tasks: Parse and validate JSON task format
#
# ============================================================================


# ============================================================================
# PARSE-TASKS (Public)
# ============================================================================
#
# Parses and validates JSON task format, detecting the task system automatically.
# Can be run standalone for testing or used by other templates.
#
# Input format:
#   [{"name": "track1", "<task_system>": ["id1", "id2"]}, ...]
#
# Where <task_system> is any key like: beads, jira, linear, github, etc.
#
# Variables:
#   tasks (required) - JSON array of task objects
#   output_file (optional) - Path to write parsed output (default: stdout only)
#
# Output format (written to output_file if specified):
#   [
#     {"name": "track1", "task_system": "beads", "task_ids": "id1 id2", "index": 0},
#     ...
#   ]
#
# Standalone usage:
#   meow run lib/utils#parse-tasks --var tasks='[{"name":"impl","beads":["b1","b2"]}]'
#
# Template usage:
#   [[main.steps]]
#   id = "parse"
#   executor = "expand"
#   template = "lib/utils#parse-tasks"
#   variables = { tasks = "{{tasks}}", output_file = ".meow/worktrees/.parsed-tasks.json" }
#
# ============================================================================

[parse-tasks]
name = "parse-tasks"
description = "Parse and validate JSON task format with automatic task system detection"

[parse-tasks.variables]
tasks = { required = true, description = "JSON array: [{name, <task_system>: [ids]}]" }
output_file = { default = "", description = "Optional file to write parsed output" }

[[parse-tasks.steps]]
id = "parse"
executor = "shell"
description = "Parse and validate tasks JSON"
command = """
set -e

# Write tasks to temp file for jq processing
TEMP_FILE=$(mktemp)
trap 'rm -f "$TEMP_FILE"' EXIT

cat > "$TEMP_FILE" << 'TASKS_EOF'
{{tasks}}
TASKS_EOF

# ============================================================================
# Validation
# ============================================================================

# 1. Validate JSON format
if ! jq -e '.' "$TEMP_FILE" >/dev/null 2>&1; then
  echo "ERROR: Invalid JSON format for tasks variable" >&2
  echo 'Expected: [{"name": "track1", "<task_system>": ["id1", "id2"]}]' >&2
  exit 1
fi

# 2. Validate it's an array
if ! jq -e 'type == "array"' "$TEMP_FILE" >/dev/null 2>&1; then
  echo "ERROR: tasks must be a JSON array" >&2
  echo "Got: $(jq -c 'type' "$TEMP_FILE")" >&2
  exit 1
fi

# 3. Validate non-empty
TASK_COUNT=$(jq 'length' "$TEMP_FILE")
if [ "$TASK_COUNT" -eq 0 ]; then
  echo "ERROR: No tasks provided (empty array)" >&2
  exit 1
fi

echo "Parsing $TASK_COUNT task(s)..." >&2

# ============================================================================
# Parse each task
# ============================================================================

PARSED='[]'

for i in $(seq 0 $((TASK_COUNT - 1))); do
  # Extract name
  NAME=$(jq -r '.['$i'].name' "$TEMP_FILE")

  if [ -z "$NAME" ] || [ "$NAME" = "null" ]; then
    echo "ERROR: Task $i missing required 'name' field" >&2
    exit 1
  fi

  # Detect task system by finding the key that's not "name" and has an array value
  # This finds keys like "beads", "jira", "linear", "github", etc.
  TASK_SYSTEM=$(jq -r '.['$i'] | to_entries | map(select(.key != "name" and (.value | type) == "array")) | .[0].key // empty' "$TEMP_FILE")

  if [ -z "$TASK_SYSTEM" ]; then
    echo "ERROR: Task '$NAME' missing task system key (e.g., 'beads', 'jira')" >&2
    echo 'Expected format: {"name": "...", "<task_system>": ["id1", "id2"]}' >&2
    echo "Got: $(jq -c '.['$i']' "$TEMP_FILE")" >&2
    exit 1
  fi

  # Extract task IDs as space-separated string
  TASK_IDS=$(jq -r '.['$i'].'$TASK_SYSTEM' | join(" ")' "$TEMP_FILE")

  if [ -z "$TASK_IDS" ]; then
    echo "ERROR: Task '$NAME' has empty $TASK_SYSTEM array" >&2
    exit 1
  fi

  echo "  [$i] $NAME: $TASK_SYSTEM = $TASK_IDS" >&2

  # Add to parsed array
  PARSED=$(printf '%s' "$PARSED" | jq -c \
    --arg name "$NAME" \
    --arg task_system "$TASK_SYSTEM" \
    --arg task_ids "$TASK_IDS" \
    --argjson index "$i" \
    '. + [{
      "name": $name,
      "task_system": $task_system,
      "task_ids": $task_ids,
      "index": $index
    }]')
done

echo "" >&2
echo "Successfully parsed $TASK_COUNT task(s)" >&2

# ============================================================================
# Output
# ============================================================================

OUTPUT_FILE="{{output_file}}"

if [ -n "$OUTPUT_FILE" ]; then
  mkdir -p "$(dirname "$OUTPUT_FILE")"
  printf '%s' "$PARSED" > "$OUTPUT_FILE"
  echo "Output written to: $OUTPUT_FILE" >&2
fi

# Always output to stdout for inspection/debugging
printf '%s\n' "$PARSED" | jq .
"""

[[parse-tasks.steps]]
id = "done"
executor = "shell"
command = "echo 'Task parsing complete'"
needs = ["parse"]
