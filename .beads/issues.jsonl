{"id":"meow-00g","title":"Define standard label conventions for tiers","description":"Define label conventions for beads. Per SPEC-ADDENDUM, the Tier field is now primary for tier detection.\n\n## Reduced Scope\n\nLabels are now OPTIONAL metadata, not the primary tier mechanism. The explicit `Tier` field handles tier filtering.\n\n## Standard Labels (Optional)\n\n| Label | Purpose |\n|-------|---------|\n| `meow:workflow:{id}` | Track which workflow instance created this bead |\n| `meow:ephemeral` | Mark for cleanup after workflow completion |\n\n## What Changed\n\n- **Removed**: `meow:wisp` and `meow:orchestrator` labels as tier indicators\n- **Added**: Explicit `Tier` field on Bead struct (handled by meow-bba)\n- Labels are now for grouping/filtering, not tier determination\n\n## File Location\nModify: `internal/types/bead.go` (label constants if any)\n\n## Acceptance Criteria\n- [ ] Document label conventions in code comments\n- [ ] Remove any code that computes tier from labels\n- [ ] Workflow ID label helper function if needed","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:53.186807739-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:14:05.917253075-05:00","closed_at":"2026-01-07T18:14:05.917253075-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Label conventions are part of the unified filtering implementation.","dependencies":[{"issue_id":"meow-00g","depends_on_id":"meow-bba","type":"blocks","created_at":"2026-01-07T16:39:46.693798695-05:00","created_by":"ubuntu"}]}
{"id":"meow-0h7","title":"Implement agent state tracking","description":"# Implement Agent State Tracking\n\n## File: internal/orchestrator/agents.go\n\n## Purpose\n\nTrack agent state including:\n- tmux session name\n- Working directory (for file_path validation)\n- Current step (for meow prime queries)\n- Status (active/idle/dead)\n\n## Implementation\n\n\\`\\`\\`go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os/exec\"\n    \"sync\"\n)\n\n// AgentState tracks runtime state for an agent.\ntype AgentState struct {\n    ID          string \\`yaml:\"id\"\\`\n    TmuxSession string \\`yaml:\"tmux_session\"\\`\n    Workdir     string \\`yaml:\"workdir\"\\`\n    CurrentStep string \\`yaml:\"current_step,omitempty\"\\`\n    Status      string \\`yaml:\"status\"\\`  // active, idle\n}\n\n// AgentManager tracks all agents in a workflow.\ntype AgentManager struct {\n    mu     sync.RWMutex\n    agents map[string]*AgentState\n}\n\n// NewAgentManager creates a manager.\nfunc NewAgentManager() *AgentManager {\n    return \u0026AgentManager{\n        agents: make(map[string]*AgentState),\n    }\n}\n\n// Register adds a new agent after spawn.\nfunc (m *AgentManager) Register(agent *AgentState) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    m.agents[agent.ID] = agent\n}\n\n// Get retrieves an agent's state.\nfunc (m *AgentManager) Get(id string) (*AgentState, bool) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    agent, ok := m.agents[id]\n    return agent, ok\n}\n\n// SetCurrentStep updates the agent's current step.\nfunc (m *AgentManager) SetCurrentStep(agentID, stepID string) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    if agent, ok := m.agents[agentID]; ok {\n        agent.CurrentStep = stepID\n        agent.Status = \"active\"\n    }\n}\n\n// SetIdle marks the agent as idle (no current step).\nfunc (m *AgentManager) SetIdle(agentID string) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    if agent, ok := m.agents[agentID]; ok {\n        agent.CurrentStep = \"\"\n        agent.Status = \"idle\"\n    }\n}\n\n// GetWorkdir returns the agent's working directory.\nfunc (m *AgentManager) GetWorkdir(agentID string) (string, bool) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    if agent, ok := m.agents[agentID]; ok {\n        return agent.Workdir, true\n    }\n    return \"\", false\n}\n\n// IsRunning checks if agent's tmux session exists.\nfunc (m *AgentManager) IsRunning(ctx context.Context, agentID string) (bool, error) {\n    m.mu.RLock()\n    agent, ok := m.agents[agentID]\n    m.mu.RUnlock()\n    \n    if !ok {\n        return false, nil\n    }\n    \n    // Check if tmux session exists\n    cmd := exec.CommandContext(ctx, \"tmux\", \"has-session\", \"-t\", agent.TmuxSession)\n    err := cmd.Run()\n    return err == nil, nil\n}\n\n// Remove deletes an agent after kill.\nfunc (m *AgentManager) Remove(agentID string) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    delete(m.agents, agentID)\n}\n\n// All returns all agent states.\nfunc (m *AgentManager) All() []*AgentState {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    \n    result := make([]*AgentState, 0, len(m.agents))\n    for _, agent := range m.agents {\n        result = append(result, agent)\n    }\n    return result\n}\n\n// ForAgent returns the agent state for IPC requests (meow prime).\nfunc (m *AgentManager) ForAgent(agentID string) (*AgentState, error) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    \n    agent, ok := m.agents[agentID]\n    if !ok {\n        return nil, fmt.Errorf(\"unknown agent: %s\", agentID)\n    }\n    return agent, nil\n}\n\\`\\`\\`\n\n## Workflow Integration\n\nThe Workflow struct also stores agent state for persistence:\n\n\\`\\`\\`go\n// In types/workflow.go\ntype Workflow struct {\n    // ... existing fields ...\n    \n    // Active agents with their state\n    Agents map[string]*AgentInfo \\`yaml:\"agents,omitempty\"\\`\n}\n\ntype AgentInfo struct {\n    TmuxSession string \\`yaml:\"tmux_session\"\\`\n    Status      string \\`yaml:\"status\"\\`\n    Workdir     string \\`yaml:\"workdir\"\\`\n    CurrentStep string \\`yaml:\"current_step,omitempty\"\\`\n}\n\\`\\`\\`\n\n## Usage\n\n\\`\\`\\`go\n// In spawn executor\nfunc (e *SpawnExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    agent := \u0026AgentState{\n        ID:          step.Spawn.Agent,\n        TmuxSession: fmt.Sprintf(\"meow-%s-%s\", wf.ID, step.Spawn.Agent),\n        Workdir:     step.Spawn.Workdir,\n        Status:      \"active\",\n    }\n    \n    e.agents.Register(agent)\n    \n    // Also persist to workflow for crash recovery\n    wf.Agents[agent.ID] = \u0026types.AgentInfo{\n        TmuxSession: agent.TmuxSession,\n        Status:      agent.Status,\n        Workdir:     agent.Workdir,\n    }\n    \n    // ... start tmux session ...\n}\n\n// In meow prime handler\nfunc (o *Orchestrator) handlePrimeRequest(agentID string) (string, error) {\n    agent, err := o.agents.ForAgent(agentID)\n    if err != nil {\n        return \"\", err\n    }\n    \n    if agent.CurrentStep == \"\" {\n        // Agent is idle, no prompt\n        return \"\", nil\n    }\n    \n    step, ok := o.workflow.GetStep(agent.CurrentStep)\n    if !ok {\n        return \"\", nil\n    }\n    \n    // Check step status and mode\n    // ...\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] AgentState struct with all fields\n- [ ] AgentManager with thread-safe operations\n- [ ] Register/Get/Remove operations\n- [ ] SetCurrentStep/SetIdle for step tracking\n- [ ] GetWorkdir for file_path validation\n- [ ] IsRunning checks tmux session\n- [ ] Workflow.Agents for persistence\n- [ ] Integration with spawn executor\n- [ ] Integration with meow prime handler\n- [ ] Integration with crash recovery\n- [ ] Unit tests for AgentManager","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T20:29:27.397948955-05:00","created_by":"ubuntu","updated_at":"2026-01-08T20:29:27.397948955-05:00","dependencies":[{"issue_id":"meow-0h7","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T20:29:48.737979005-05:00","created_by":"ubuntu"}]}
{"id":"meow-0tx","title":"Implement attach_wisp processing","description":"Handle explicit wisp attachment via attach_wisp field. See IMPLEMENTATION-PLAN section meow-modules-baker-attach.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.987317851-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:13:20.118627958-05:00","closed_at":"2026-01-07T18:13:20.118627958-05:00","close_reason":"YAGNI - attach_wisp processing not needed. Auto-detection via ephemeral=true workflow property plus hooks_to for HookBead linking handles all real use cases. Can resurrect if a real use case emerges.","dependencies":[{"issue_id":"meow-0tx","depends_on_id":"meow-cxt","type":"blocks","created_at":"2026-01-07T16:39:47.339612162-05:00","created_by":"ubuntu"}]}
{"id":"meow-0x5","title":"Templates: Module Format Examples","description":"Create example templates using module format. Phase 4.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T16:38:26.126049796-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:38:26.126049796-05:00"}
{"id":"meow-1767859075881445643.check-setup-e1400b22","title":"Verify setup succeeded","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881471097-05:00","updated_at":"2026-01-08T03:03:02.969764215-05:00","closed_at":"2026-01-08T03:03:02.969764215-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767859075881445643.final-check-b8e93fc4","title":"Final verification","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881513221-05:00","updated_at":"2026-01-08T03:03:02.837518938-05:00","closed_at":"2026-01-08T03:03:02.837518938-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767859075881445643.setup-7bbb265a","title":"Setup test: integration","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881469714-05:00","updated_at":"2026-01-08T03:03:03.083696409-05:00","closed_at":"2026-01-08T03:03:03.083696409-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767859143521847187.do-task-5eca0980","title":"Manual task: Testing MEOW","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent","created_at":"2026-01-08T02:59:03.521869445-05:00","updated_at":"2026-01-08T03:02:00.041190337-05:00","closed_at":"2026-01-08T02:59:18.246773414-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767859176394229162.select-item-7ac2abd9","title":"Select an item","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent","created_at":"2026-01-08T02:59:36.394244608-05:00","updated_at":"2026-01-08T03:02:00.041190337-05:00","closed_at":"2026-01-08T02:59:57.757032872-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767859214219875123.do-task-46218984","title":"Manual task: Hook Test","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent","created_at":"2026-01-08T03:00:14.219899843-05:00","updated_at":"2026-01-08T03:03:02.718661421-05:00","closed_at":"2026-01-08T03:03:02.718661421-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767861713546410128.hello-task-629ae87d","title":"Say hello world","status":"in_progress","priority":0,"issue_type":"task","assignee":"test-hello","created_at":"2026-01-08T03:41:53.546432921-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861713546410128.start-agent-04136978","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello","created_at":"2026-01-08T03:41:53.546429546-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","closed_at":"2026-01-08T03:44:17.638700045-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861857019966617.hello-task-b9299e98","title":"Say hello world","status":"in_progress","priority":0,"issue_type":"task","assignee":"test-hello2","created_at":"2026-01-08T03:44:17.019993792-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861857019966617.start-agent-76192c8f","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello2","created_at":"2026-01-08T03:44:17.019990709-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","closed_at":"2026-01-08T03:44:18.150013333-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861974163875193.hello-task-4941d5fa","title":"Say hello world","status":"in_progress","priority":0,"issue_type":"task","assignee":"test-agent1","created_at":"2026-01-08T03:46:14.163899172-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861974163875193.start-agent-e0100869","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent1","created_at":"2026-01-08T03:46:14.163896247-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","closed_at":"2026-01-08T03:46:17.300082979-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861974163875193.verify-d4e5493e","title":"Verify test completed","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T03:46:14.163900255-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862037315936305.hello-task-6dcee4c3","title":"Say hello world","status":"in_progress","priority":0,"issue_type":"task","assignee":"hello1","created_at":"2026-01-08T03:47:17.315958926-05:00","updated_at":"2026-01-08T03:47:52.595423519-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862037315936305.start-agent-295e92a1","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"hello1","created_at":"2026-01-08T03:47:17.31595614-05:00","updated_at":"2026-01-08T03:47:52.595423519-05:00","closed_at":"2026-01-08T03:47:20.451867057-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862229223052455.hello-task-0a398443","title":"Say hello world","status":"in_progress","priority":0,"issue_type":"task","assignee":"hello2","created_at":"2026-01-08T03:50:29.223075246-05:00","updated_at":"2026-01-08T03:51:03.388502137-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862229223052455.start-agent-5f4790c4","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"hello2","created_at":"2026-01-08T03:50:29.22307204-05:00","updated_at":"2026-01-08T03:51:03.388502137-05:00","closed_at":"2026-01-08T03:50:32.359446604-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862412750392382.hello-task-dd0b9f2b","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"testx","created_at":"2026-01-08T03:53:32.750420123-05:00","updated_at":"2026-01-08T03:54:38.672099979-05:00","closed_at":"2026-01-08T03:54:38.672099979-05:00","close_reason":"Said hello world successfully","labels":["meow:ephemeral"]}
{"id":"meow-1767862412750392382.start-agent-2fbe8a64","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"testx","created_at":"2026-01-08T03:53:32.750416442-05:00","updated_at":"2026-01-08T03:53:53.068315074-05:00","closed_at":"2026-01-08T03:53:37.897172539-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862600737422288.hello-task-ab26b34d","title":"Say hello world","status":"in_progress","priority":0,"issue_type":"task","assignee":"tiertest","created_at":"2026-01-08T03:56:40.737449805-05:00","updated_at":"2026-01-08T03:57:10.905458818-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862600737422288.start-agent-cb852b6e","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"tiertest","created_at":"2026-01-08T03:56:40.737446232-05:00","updated_at":"2026-01-08T03:57:10.905458818-05:00","closed_at":"2026-01-08T03:56:45.858162975-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1ir","title":"Implement format detection logic","description":"Detect whether file is legacy ([meta]) or module format ([workflow-name]). See IMPLEMENTATION-PLAN section meow-modules-parser-detect.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T16:38:36.035558315-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:02:30.539825798-05:00","closed_at":"2026-01-08T02:02:30.539825798-05:00","close_reason":"No legacy format - only module format exists in MVP","dependencies":[{"issue_id":"meow-1ir","depends_on_id":"meow-8x2","type":"blocks","created_at":"2026-01-07T16:39:46.322602835-05:00","created_by":"ubuntu"}]}
{"id":"meow-1l1","title":"Add BeadTypeCollaborative for interactive agent-user steps","description":"Add new `collaborative` bead type per SPEC-ADDENDUM-WISPS-AND-MODULES.md (lines 241-326).\n\n## The Collaborative Type\n\nThe `collaborative` type enables **human-in-the-loop interaction** within an otherwise autonomous workflow. Unlike `task` which auto-continues via the Ralph Wiggum loop, `collaborative` pauses for conversation.\n\n```go\nconst (\n    // Agent-executable\n    BeadTypeTask          BeadType = \"task\"          // Agent does work, auto-continues\n    BeadTypeCollaborative BeadType = \"collaborative\" // Agent + human conversation, pauses\n    BeadTypeGate          BeadType = \"gate\"          // Human approval point (no assignee)\n    \n    // Orchestrator-executable\n    BeadTypeStart     BeadType = \"start\"\n    BeadTypeStop      BeadType = \"stop\"\n    BeadTypeCondition BeadType = \"condition\"\n    BeadTypeCode      BeadType = \"code\"\n    BeadTypeExpand    BeadType = \"expand\"\n)\n```\n\n## Type Behavior Summary\n\n| Type | Assignee | Auto-continue | Who closes | Use case |\n|------|----------|---------------|------------|----------|\n| `task` | Required | Yes (Ralph Wiggum) | Agent | Normal autonomous work |\n| `collaborative` | Required | No (pauses) | Agent | Design review, clarification |\n| `gate` | None | No | Human | Approval checkpoints |\n\n## How Collaborative Works\n\n1. Agent executes step (presents info, asks questions)\n2. Agent's stop hook fires, BUT...\n3. `meow prime --format prompt` returns **empty** for in-progress collaborative steps\n4. No prompt injection → Claude waits for user input\n5. User and agent converse freely\n6. Agent runs `meow close \u003cstep-id\u003e` when done\n7. Next stop hook fires, normal flow resumes\n\n## Validation Rules\n\n- **Must have assignee** - Unlike gate, collaborative needs an agent\n- **Tier detection** - Handled same as task (wisp if in ephemeral workflow)\n\n## File Location\nModify: `internal/types/bead.go`\n\n## Acceptance Criteria\n- [ ] BeadTypeCollaborative constant added\n- [ ] Valid() updated to include collaborative\n- [ ] Collaborative validation: must have assignee (like task)\n- [ ] Unit tests for collaborative type\n- [ ] Documentation updated","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T17:59:06.403106737-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:14:51.294256315-05:00","closed_at":"2026-01-07T18:14:51.294256315-05:00","close_reason":"Consolidated into meow-bba. The collaborative type is now part of the unified Bead struct changes task.","dependencies":[{"issue_id":"meow-1l1","depends_on_id":"meow-bba","type":"blocks","created_at":"2026-01-07T17:59:17.523010622-05:00","created_by":"ubuntu"}]}
{"id":"meow-40s","title":"Implement load context tracking","description":"LoadContext struct for current file, module, cycle detection. See IMPLEMENTATION-PLAN section meow-modules-loader-context.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.320905842-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:50:19.662932244-05:00","closed_at":"2026-01-08T02:50:19.662932244-05:00","close_reason":"Implemented LoadContext struct with cycle detection, child context creation, and comprehensive tests","dependencies":[{"issue_id":"meow-40s","depends_on_id":"meow-7x5","type":"blocks","created_at":"2026-01-07T16:40:07.258337447-05:00","created_by":"ubuntu"}]}
{"id":"meow-461","title":"Implement helpful error messages for loading","description":"Typed errors with context and hints for reference failures. See IMPLEMENTATION-PLAN section meow-modules-loader-errors.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.605093738-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:39:05.605093738-05:00","dependencies":[{"issue_id":"meow-461","depends_on_id":"meow-dvr","type":"blocks","created_at":"2026-01-07T16:39:47.066078331-05:00","created_by":"ubuntu"}]}
{"id":"meow-4wg","title":"vars.go: Code field not substituted in SubstituteStep()","description":"## Location\n`internal/template/vars.go:298-376`\n\n## Problem\nThe `SubstituteStep()` function substitutes many fields but NOT the `Code` field:\n\nSubstituted:\n- ✅ Description\n- ✅ Instructions\n- ✅ Condition\n- ✅ Template\n- ✅ Validation\n- ✅ Timeout\n- ✅ Variables\n- ✅ OnTrue, OnFalse, OnTimeout\n\nNOT substituted:\n- ❌ Code\n\n## Impact\nCode beads with variable references will NOT have variables replaced:\n```toml\n[[steps]]\nid = \"setup\"\ntype = \"code\"\ncode = \"echo {{agent}} \u003e /tmp/agent.txt\"  # {{agent}} stays literal!\n```\n\nThis breaks:\n- Worktree setup scripts\n- Session ID capture\n- Any dynamic shell code\n\n## Fix\nAdd Code field substitution in SubstituteStep():\n```go\nif result.Code != \"\" {\n    result.Code, err = c.Substitute(result.Code)\n    if err != nil {\n        return nil, fmt.Errorf(\"substitute code: %w\", err)\n    }\n}\n```\n\n## Severity\nHIGH - Code beads are essential for orchestration (worktree, sessions, git ops)","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T02:22:28.194025757-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:32:55.141969596-05:00","closed_at":"2026-01-08T02:32:55.141969596-05:00","close_reason":"Fixed: Added Code field substitution in SubstituteStep() with tests"}
{"id":"meow-58l","title":"Implement module validation","description":"Validate local references, detect cycles, check internal visibility. See IMPLEMENTATION-PLAN section meow-modules-parser-validate.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T16:38:36.217177591-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:28:57.191700574-05:00","closed_at":"2026-01-08T02:28:57.191700574-05:00","close_reason":"Implemented module validation: local reference validation, internal visibility checks, hooks_to validation, variable reference checking, type-specific validation rules. Added 40+ comprehensive tests.","dependencies":[{"issue_id":"meow-58l","depends_on_id":"meow-ao5","type":"blocks","created_at":"2026-01-07T16:39:46.506194238-05:00","created_by":"ubuntu"}]}
{"id":"meow-5d8","title":"Create implement-tdd module","description":"TDD workflow as part of work-loop module. See IMPLEMENTATION-PLAN.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.459141219-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:39:25.459141219-05:00","dependencies":[{"issue_id":"meow-5d8","depends_on_id":"meow-5u6","type":"blocks","created_at":"2026-01-07T16:39:48.083913963-05:00","created_by":"ubuntu"}]}
{"id":"meow-5tm","title":"baker.go: Start/Stop specs use unsubstituted assignee","description":"## Location\n`internal/template/baker.go:475-490`\n\n## Problem\nIn `setTypeSpec()`, the `StartSpec.Agent` and `StopSpec.Agent` use `step.Assignee` directly, but this is the raw template value (e.g., `{{agent}}`), not the substituted value.\n\nThe substituted assignee IS computed in `workflowStepToBead()` (lines 194-205), but it's never passed to `setTypeSpec()` - the function receives the original step.\n\n```go\ncase types.BeadTypeStart:\n    spec := \u0026types.StartSpec{\n        Agent: step.Assignee,  // Uses raw \"{{agent}}\", not substituted value\n    }\n```\n\n## Impact\n- Start beads will try to spawn agent literally named \"{{agent}}\"\n- Stop beads will try to kill agent literally named \"{{agent}}\"\n- Agent lifecycle management broken for any template using variable assignees\n\n## Fix\nEither:\n1. Pass the substituted assignee to `setTypeSpec()`, or\n2. Substitute within `setTypeSpec()`, or\n3. Create a modified step copy with substituted values before calling\n\n## Severity\nHIGH - Agent start/stop broken for templates with variable assignees","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T02:22:26.443811687-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:30:41.159025876-05:00","closed_at":"2026-01-08T02:30:41.159025876-05:00","close_reason":"Fixed: setTypeSpec() now uses bead.Assignee (substituted value) instead of step.Assignee (raw template value) for Start/Stop specs. Added test to verify variable substitution in Start/Stop steps."}
{"id":"meow-5u6","title":"Create work-loop module template","description":"Main loop: select work, implement, repeat. Module format example. See IMPLEMENTATION-PLAN section meow-modules-templates-workloop.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.337170169-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:39:25.337170169-05:00","dependencies":[{"issue_id":"meow-5u6","depends_on_id":"meow-74h","type":"blocks","created_at":"2026-01-07T16:40:07.961661718-05:00","created_by":"ubuntu"}]}
{"id":"meow-5yi","title":"Orchestrator: Tier-Aware Processing","description":"Update orchestrator for three-tier bead model. Phase 3.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.937979017-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:38:25.937979017-05:00"}
{"id":"meow-74b","title":"Create MEOW beads fork strategy and implementation","description":"Per SPEC-ADDENDUM-WISPS-AND-MODULES.md (lines 63-109), MEOW Stack requires a fork of the beads CLI/library.\n\n## Rationale\n\nThe upstream `beads` project is general-purpose issue tracking. MEOW requires:\n\n1. **New bead types** - `start`, `stop`, `condition`, `code`, `expand`, `gate` as first-class `IssueType` values\n2. **Tier field** - Explicit `Tier` enum on the Issue struct (not computed from labels)\n3. **Workflow metadata** - `HookBead`, `SourceWorkflow`, `WorkflowID` fields\n4. **Custom statuses** - Potentially workflow-specific status values\n5. **Output storage** - `Outputs map[string]any` for bead-to-bead data flow\n6. **Type-specific specs** - `ConditionSpec`, `StartSpec`, etc. on the Issue struct\n\n## Fork Strategy\n\n```\ngithub.com/anthropics/beads           # Upstream (general issue tracking)\ngithub.com/meow-stack/meow-beads      # Fork (workflow orchestration)\n```\n\n## Implementation Options\n\n**Option A: Internal Types (Current Approach)**\n- Define MEOW-specific types in `internal/types/bead.go`\n- Adapter layer to convert to/from upstream beads format\n- Pros: No fork maintenance, gradual adoption\n- Cons: Type conversion overhead, schema drift\n\n**Option B: True Fork**\n- Fork upstream beads to meow-beads repo\n- Extend Issue struct directly\n- Pros: Clean integration, single source of truth\n- Cons: Fork maintenance burden\n\n**Recommendation**: Start with Option A (internal types), evaluate fork if needed.\n\n## Current State\n\nThe existing `internal/types/bead.go` already defines MEOW-specific Bead struct. This task is to:\n1. Document the relationship to upstream beads\n2. Ensure type conversion works correctly\n3. Plan for potential future fork if internal types become unwieldy\n\n## Acceptance Criteria\n- [ ] Document fork strategy in ARCHITECTURE.md\n- [ ] Verify internal types cover all MEOW requirements\n- [ ] Add type conversion helpers if using upstream beads storage\n- [ ] Update meow-e8.1 (beads integration) with this context","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T17:53:04.241715524-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:13:01.044397277-05:00","closed_at":"2026-01-07T18:13:01.044397277-05:00","close_reason":"No fork needed - internal types in internal/types/bead.go already implement MEOW-specific fields. The beads CLI uses JSONL format which we can read/write directly. Document this decision in ARCHITECTURE.md as part of normal docs work."}
{"id":"meow-74h","title":"Implement meow close with output validation","description":"Validate required outputs before closing wisp steps per SPEC-ADDENDUM.\n\n## Usage\n\n```bash\n# Close with required outputs\nmeow close select-work \\\n    --output work_bead=gt-123 \\\n    --output rationale=\"Highest priority, unblocks 3 others\"\n\n# Or with JSON\nmeow close select-work --output-json '{\n    \"work_bead\": \"gt-123\",\n    \"rationale\": \"Highest priority, unblocks 3 others\"\n}'\n```\n\n## Validation\n\n```go\nfunc CloseWispStep(ctx context.Context, store Store, stepID string, outputs map[string]string) error {\n    step, _ := store.Get(ctx, stepID)\n    \n    // Validate outputs against TaskOutputSpec\n    if err := validateOutputs(step, outputs); err \\!= nil {\n        return err  // Reject close if outputs invalid\n    }\n    \n    step.Outputs = outputs\n    step.Status = StatusClosed  // Direct to closed, no 'hooked' intermediate\n    step.ClosedAt = time.Now()\n    \n    return store.Update(ctx, step)\n}\n```\n\n## Output Types (from types.TaskOutputType)\n\n| Type | Validation |\n|------|------------|\n| string | Non-empty |\n| bead_id | Bead exists in store |\n| number | Parseable as float |\n| boolean | \"true\" or \"false\" |\n| file_path | File exists |\n\n## Key Changes from Implementation Plan\n\n- **No hooked status** - Status goes directly from in_progress to closed\n- **bead_id validation** - Validates bead exists, not just string format\n\n## File Location\nModify: `cmd/meow/cmd/close.go`\n\n## Acceptance Criteria\n- [ ] Validates required outputs before close\n- [ ] bead_id type validates bead exists\n- [ ] Stores outputs on bead\n- [ ] Helpful error messages for missing/invalid outputs","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:25.095279763-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:02:52.881355561-05:00","closed_at":"2026-01-08T03:02:52.881355561-05:00","close_reason":"Verified working: meow close validates required outputs, bead_id type validates existence, stores outputs on bead, shows helpful error messages","dependencies":[{"issue_id":"meow-74h","depends_on_id":"meow-97m","type":"blocks","created_at":"2026-01-07T16:39:47.896983716-05:00","created_by":"ubuntu"}]}
{"id":"meow-7x5","title":"Maintain legacy format compatibility","description":"ParseAny() that handles both formats, Template.ToModule() conversion. See IMPLEMENTATION-PLAN section meow-modules-parser-legacy.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T16:38:36.313359455-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:01:10.077656269-05:00","closed_at":"2026-01-08T02:01:10.077656269-05:00","close_reason":"No legacy compatibility in pre-customer MVP - only one format exists","dependencies":[{"issue_id":"meow-7x5","depends_on_id":"meow-58l","type":"blocks","created_at":"2026-01-07T16:39:46.600180287-05:00","created_by":"ubuntu"}]}
{"id":"meow-8x2","title":"Define module-level parser types","description":"Define module-level parser types per SPEC-ADDENDUM-WISPS-AND-MODULES.md.\n\n## Types to Define\n\n```go\n// FileFormat indicates the template file format\ntype FileFormat int\n\nconst (\n    FormatLegacy FileFormat = iota  // [meta] + [[steps]]\n    FormatModule                     // [workflow-name] sections\n)\n\n// Module represents a parsed module file\ntype Module struct {\n    Path      string               // File path for error messages\n    Workflows map[string]*Workflow // Named workflows\n}\n\n// Workflow represents a single workflow within a module\ntype Workflow struct {\n    Name        string           `toml:\"name\"`\n    Description string           `toml:\"description,omitempty\"`\n    Ephemeral   bool             `toml:\"ephemeral,omitempty\"`\n    Internal    bool             `toml:\"internal,omitempty\"`\n    HooksTo     string           `toml:\"hooks_to,omitempty\"`    // Links wisps to this variable's bead ID\n    Variables   map[string]*Var  `toml:\"variables,omitempty\"`\n    Steps       []*Step          `toml:\"steps\"`\n}\n\n// Step type field accepts:\n// - task | collaborative | gate | condition | code | start | stop | expand\n```\n\n## Key Addition: HooksTo Property\n\nThe `HooksTo` field declares which variable contains the work bead ID that all wisps from this workflow should link to:\n\n```toml\n[implement]\nephemeral = true\nhooks_to = \"work_bead\"   # All wisps link to {{work_bead}}\n```\n\nThis replaces magic variable name detection with explicit declaration.\n\n## Step Type Validation\n\nValid step types per SPEC-ADDENDUM:\n- `task` - Agent work, auto-continues\n- `collaborative` - Agent + human conversation, pauses\n- `gate` - Human approval (no assignee)\n- `condition` - Branch/loop/wait\n- `code` - Shell execution\n- `start` - Spawn agent\n- `stop` - Kill agent\n- `expand` - Template expansion\n\n## File Location\nCreate: `internal/template/module.go`\n\n## Acceptance Criteria\n- [ ] FileFormat enum defined\n- [ ] Module struct with Workflows map\n- [ ] Workflow struct with HooksTo field\n- [ ] Step type validation includes all 8 types\n- [ ] Helper methods: GetWorkflow(), DefaultWorkflow(), IsInternal()\n- [ ] Unit tests for helper methods","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:35.94360773-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:43.81964419-05:00","closed_at":"2026-01-07T18:46:43.81964419-05:00","close_reason":"Implemented minimal viable slice: module parser, tier tracking, and meow prime command"}
{"id":"meow-97m","title":"Implement wisp-aware meow prime","description":"Show workflow progression, work bead, current step per SPEC-ADDENDUM. **Crucially, returns empty output for in-progress collaborative steps** to disable auto-continuation.\n\n## Output Format\n\n```\n═══════════════════════════════════════════════════════════════\nYour workflow: implement-tdd (step 2/4)\nWork bead: gt-123 \"Implement auth endpoint\"\n═══════════════════════════════════════════════════════════════\n\n  ✓ load-context\n  → write-tests [in_progress] ← YOU ARE HERE\n  ○ implement\n  ○ commit\n\n───────────────────────────────────────────────────────────────\nInstructions:\n  Write failing tests that define the expected behavior.\n  Tests MUST fail at this point.\n\nRequired outputs: (none)\n───────────────────────────────────────────────────────────────\n```\n\n## Implementation with Collaborative Support\n\n```go\nfunc Prime(ctx context.Context, store Store, agentID string, format string) (*PrimeOutput, error) {\n    // Check for in-progress collaborative step first\n    inProgress, _ := store.List(ctx, BeadFilter{\n        Tier:     TierWisp,\n        Assignee: agentID,\n        Status:   StatusInProgress,\n    })\n    \n    for _, step := range inProgress {\n        if step.Type == BeadTypeCollaborative {\n            // Collaborative step in progress - don't auto-continue!\n            if format == \"prompt\" {\n                return nil, nil  // Empty output = no injection\n            }\n            // For non-prompt format, show status with conversation mode flag\n            return \u0026PrimeOutput{\n                Workflow:         getWorkflowInfo(step),\n                WorkBead:         getHookBead(step),\n                ConversationMode: true,  // Signal to UI\n            }, nil\n        }\n    }\n    \n    // Normal flow: filter wisps for this agent (Tier field, not labels)\n    wispSteps, _ := store.List(ctx, BeadFilter{\n        Tier:     TierWisp,\n        Assignee: agentID,\n        Statuses: []BeadStatus{StatusOpen, StatusInProgress},\n    })\n    \n    // Get linked work bead via HookBead field\n    var workBead *types.Bead\n    if current.HookBead != \"\" {\n        workBead, _ = store.Get(ctx, current.HookBead)\n    }\n    // ...\n}\n```\n\n## Stop Hook Integration\n\nThe stop hook relies on empty output for collaborative steps:\n\n```bash\n#!/bin/bash\n# .claude/hooks/stop-hook.sh\n\noutput=$(meow prime --format prompt 2\u003e/dev/null)\n\nif [ -z \"$output\" ]; then\n    # Empty = collaborative mode OR no more work\n    exit 0\nfi\n\n# Normal task - inject the next prompt\necho \"$output\"\n```\n\n## Key Changes from Original Plan\n\n- **Collaborative check first** - Before finding next step, check for in-progress collaborative\n- **Empty output for collaborative** - `--format prompt` returns nothing\n- **ConversationMode flag** - Non-prompt formats can indicate conversation mode\n- **No hooked status** - Only open, in_progress, closed\n- **Filter on Tier field** - Not labels\n\n## File Location\nModify: `cmd/meow/cmd/prime.go`\n\n## Acceptance Criteria\n- [ ] Shows workflow progression (step N/M)\n- [ ] Shows linked work bead title\n- [ ] Shows current step instructions\n- [ ] Shows required outputs if any\n- [ ] Only shows agent's wisps (tier + assignee filter)\n- [ ] Returns empty for in-progress collaborative steps (--format prompt)\n- [ ] ConversationMode flag for non-prompt formats","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.846649317-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:49:51.266834913-05:00","closed_at":"2026-01-08T02:49:51.266834913-05:00","close_reason":"Completed: Added required outputs display to meow prime command with tests","dependencies":[{"issue_id":"meow-97m","depends_on_id":"meow-ym3","type":"blocks","created_at":"2026-01-07T16:40:07.83918555-05:00","created_by":"ubuntu"},{"issue_id":"meow-97m","depends_on_id":"meow-cac","type":"blocks","created_at":"2026-01-07T18:15:48.910620418-05:00","created_by":"ubuntu"}]}
{"id":"meow-a28","title":"baker.go: BakeInline() doesn't set Tier or Instructions fields","description":"## Location\n`internal/template/baker.go:522-603`\n\n## Problem\nInline beads created by `BakeInline()` are missing critical fields:\n\n```go\nbead := \u0026types.Bead{\n    ID:          beadID,\n    Type:        beadType,\n    Title:       description,\n    Description: instructions,\n    Status:      types.BeadStatusOpen,\n    Assignee:    b.Assignee,\n    Needs:       needs,\n    Parent:      parentBeadID,\n    CreatedAt:   b.Now(),\n    // Missing: Tier field (will be empty string)\n    // Missing: Instructions field (only Description is set)\n}\n```\n\n## Impact\n1. **Tier not set**: Inline beads have empty tier, breaking tier-based filtering\n   - `meow prime` may not show them correctly\n   - Orchestrator priority sorting affected (empty tier → default to work tier priority)\n\n2. **Instructions not set**: `meow prime` uses Instructions for display, will show empty\n\n## Fix\nAdd the missing fields:\n```go\nbead := \u0026types.Bead{\n    // ... existing fields ...\n    Tier:         types.TierWisp,  // Inline beads from conditions are wisps\n    Instructions: instructions,\n}\n```\n\n## Severity\nMEDIUM - Affects inline beads from condition branches","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:00.59265739-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:30:45.511135272-05:00","closed_at":"2026-01-08T02:30:45.511135272-05:00","close_reason":"Fixed: BakeInline() now sets Tier (TierWisp) and Instructions fields on created beads. Added test to verify both fields are correctly populated."}
{"id":"meow-a85","title":"Add filter types for tier-based queries","description":"Add filter types for tier-based queries. Per SPEC-ADDENDUM, filter on explicit Tier field, not labels.\n\n## Filter Structure\n\n```go\ntype BeadFilter struct {\n    // Existing filters...\n    Status     *BeadStatus\n    Assignee   *string\n    \n    // NEW: Tier-based filtering (explicit field, not labels)\n    Tier       *BeadTier      // Filter by tier: work, wisp, orchestrator\n    \n    // Workflow context\n    WorkflowID *string        // Filter by workflow instance\n    HookBead   *string        // Filter wisps for specific work bead\n    \n    // Exclusions\n    ExcludeTiers []BeadTier   // Exclude specific tiers\n}\n```\n\n## Key Design Decisions\n\n1. **Filter on Tier field** - O(1) comparison, not label scanning\n2. **ExcludeTiers** - For `bd ready` to exclude wisps/orchestrator beads\n3. **HookBead filter** - Find all wisps implementing a work bead\n\n## File Location\nModify: `internal/types/bead.go` or new `internal/types/filter.go`\n\n## Acceptance Criteria\n- [ ] BeadFilter struct with Tier field\n- [ ] ExcludeTiers slice for exclusion filtering\n- [ ] WorkflowID and HookBead filters\n- [ ] Unit tests for filter matching","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:53.281343266-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:14:08.211132779-05:00","closed_at":"2026-01-07T18:14:08.211132779-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Filter types are part of the unified filtering implementation.","dependencies":[{"issue_id":"meow-a85","depends_on_id":"meow-00g","type":"blocks","created_at":"2026-01-07T16:39:46.78803388-05:00","created_by":"ubuntu"}]}
{"id":"meow-ao5","title":"Implement module parsing","description":"Two-phase TOML parsing for dynamic [workflow-name] sections. See IMPLEMENTATION-PLAN section meow-modules-parser-parse.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:36.123911948-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:07:19.777005693-05:00","closed_at":"2026-01-08T02:07:19.777005693-05:00","close_reason":"Module parsing implementation is complete. Two-phase TOML parsing for dynamic [workflow-name] sections is fully implemented in internal/template/module.go with comprehensive tests in mvp_test.go. All 108 template tests pass.","dependencies":[{"issue_id":"meow-ao5","depends_on_id":"meow-8x2","type":"blocks","created_at":"2026-01-07T16:39:46.412519728-05:00","created_by":"ubuntu"}]}
{"id":"meow-b91","title":"Implement output validation with file_path scope","description":"# Implement Output Validation with file_path Scope\n\n## File: internal/orchestrator/validation.go\n\n## Purpose\n\nValidate agent outputs against their definitions. Key addition: file_path type validates against the agent's working directory.\n\n## Output Types\n\n| Type | Validation |\n|------|------------|\n| string | Non-empty string |\n| number | Parseable as int or float |\n| boolean | \\`true\\` or \\`false\\` (case-insensitive) |\n| json | Valid JSON |\n| file_path | File exists on filesystem |\n\n## File Path Validation Scope\n\n- **Absolute paths** are validated directly\n- **Relative paths** are resolved against the **agent's working directory**\n- The orchestrator tracks each agent's workdir from its spawn step\n\n## Implementation\n\n\\`\\`\\`go\npackage orchestrator\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n    \n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// OutputValidator validates agent outputs against their definitions.\ntype OutputValidator struct {\n    agentWorkdirs map[string]string // agent ID -\u003e working directory\n}\n\n// NewOutputValidator creates a validator.\nfunc NewOutputValidator() *OutputValidator {\n    return \u0026OutputValidator{\n        agentWorkdirs: make(map[string]string),\n    }\n}\n\n// SetAgentWorkdir records an agent's working directory.\n// Called when spawn step completes.\nfunc (v *OutputValidator) SetAgentWorkdir(agentID, workdir string) {\n    v.agentWorkdirs[agentID] = workdir\n}\n\n// ValidationError describes a validation failure.\ntype ValidationError struct {\n    Field   string\n    Type    string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"output %s (%s): %s\", e.Field, e.Type, e.Message)\n}\n\n// ValidateOutputs checks outputs against step's output definitions.\nfunc (v *OutputValidator) ValidateOutputs(\n    outputs map[string]any,\n    defs map[string]types.OutputDef,\n    agentID string,\n) []error {\n    var errs []error\n    \n    // Check required outputs are present\n    for name, def := range defs {\n        value, exists := outputs[name]\n        \n        if !exists {\n            if def.Required {\n                errs = append(errs, \u0026ValidationError{\n                    Field:   name,\n                    Type:    def.Type,\n                    Message: \"required output not provided\",\n                })\n            }\n            continue\n        }\n        \n        // Validate type\n        if err := v.validateType(name, value, def.Type, agentID); err != nil {\n            errs = append(errs, err)\n        }\n    }\n    \n    return errs\n}\n\nfunc (v *OutputValidator) validateType(name string, value any, typ string, agentID string) error {\n    strVal := fmt.Sprintf(\"%v\", value)\n    \n    switch typ {\n    case \"string\":\n        if strVal == \"\" {\n            return \u0026ValidationError{name, typ, \"empty string\"}\n        }\n        \n    case \"number\":\n        if _, err := strconv.ParseFloat(strVal, 64); err != nil {\n            return \u0026ValidationError{name, typ, \"not a valid number\"}\n        }\n        \n    case \"boolean\":\n        lower := strings.ToLower(strVal)\n        if lower != \"true\" \u0026\u0026 lower != \"false\" {\n            return \u0026ValidationError{name, typ, \"must be true or false\"}\n        }\n        \n    case \"json\":\n        var js json.RawMessage\n        if err := json.Unmarshal([]byte(strVal), \u0026js); err != nil {\n            return \u0026ValidationError{name, typ, \"invalid JSON: \" + err.Error()}\n        }\n        \n    case \"file_path\":\n        path := strVal\n        \n        // Resolve relative paths against agent's workdir\n        if !filepath.IsAbs(path) {\n            workdir, ok := v.agentWorkdirs[agentID]\n            if !ok {\n                return \u0026ValidationError{name, typ, \"no workdir known for agent \" + agentID}\n            }\n            path = filepath.Join(workdir, path)\n        }\n        \n        if _, err := os.Stat(path); err != nil {\n            if os.IsNotExist(err) {\n                return \u0026ValidationError{name, typ, \"file does not exist: \" + strVal}\n            }\n            return \u0026ValidationError{name, typ, \"cannot access file: \" + err.Error()}\n        }\n        \n    default:\n        // Unknown type - treat as string\n    }\n    \n    return nil\n}\n\n// FormatValidationErrors creates a user-friendly error message.\nfunc FormatValidationErrors(errs []error, defs map[string]types.OutputDef) string {\n    var sb strings.Builder\n    sb.WriteString(\"Error: Invalid outputs\\n\\n\")\n    \n    for _, err := range errs {\n        sb.WriteString(fmt.Sprintf(\"  ✗ %s\\n\", err.Error()))\n    }\n    \n    sb.WriteString(\"\\nRequired outputs:\\n\")\n    for name, def := range defs {\n        if def.Required {\n            sb.WriteString(fmt.Sprintf(\"  - %s (%s)\", name, def.Type))\n            if def.Description != \"\" {\n                sb.WriteString(\": \" + def.Description)\n            }\n            sb.WriteString(\"\\n\")\n        }\n    }\n    \n    return sb.String()\n}\n\\`\\`\\`\n\n## Integration with Orchestrator\n\n\\`\\`\\`go\n// In spawn executor\nfunc (e *SpawnExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    // ... spawn agent ...\n    \n    // Record workdir for file_path validation\n    e.validator.SetAgentWorkdir(step.Spawn.Agent, step.Spawn.Workdir)\n    \n    // ...\n}\n\n// In handleStepCompletion\nfunc (o *Orchestrator) handleStepCompletion(msg StepDoneMessage) {\n    step := wf.Steps[msg.Step]\n    \n    if step.Agent != nil \u0026\u0026 step.Agent.Outputs != nil {\n        errs := o.validator.ValidateOutputs(msg.Outputs, step.Agent.Outputs, msg.Agent)\n        if len(errs) \u003e 0 {\n            // Send error back to agent\n            errorMsg := FormatValidationErrors(errs, step.Agent.Outputs)\n            o.sendError(msg.Agent, errorMsg)\n            \n            // Keep step running (agent will retry)\n            step.Status = types.StepStatusRunning\n            return\n        }\n    }\n    \n    // Validation passed\n    step.Complete(msg.Outputs)\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] OutputValidator with type validation\n- [ ] string: non-empty check\n- [ ] number: ParseFloat validation\n- [ ] boolean: case-insensitive true/false\n- [ ] json: valid JSON check\n- [ ] file_path: existence check with workdir resolution\n- [ ] SetAgentWorkdir for file_path scope\n- [ ] FormatValidationErrors for user-friendly messages\n- [ ] Unit tests for each type\n- [ ] Unit tests for file_path with relative/absolute paths\n- [ ] Integration with step completion flow","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T20:28:55.908902702-05:00","created_by":"ubuntu","updated_at":"2026-01-08T20:28:55.908902702-05:00","dependencies":[{"issue_id":"meow-b91","depends_on_id":"pivot-104","type":"blocks","created_at":"2026-01-08T20:29:48.547456728-05:00","created_by":"ubuntu"},{"issue_id":"meow-b91","depends_on_id":"meow-0h7","type":"blocks","created_at":"2026-01-08T20:29:48.644275494-05:00","created_by":"ubuntu"}]}
{"id":"meow-bba","title":"Add wisp tracking fields to Bead struct","description":"Add workflow metadata fields AND new bead types to MEOW's internal Bead struct.\n\n**Context**: Per the overlay approach (no beads fork), MEOW defines its own `Bead` type in `internal/types/bead.go`. This type serializes to JSON and is written to the shared `.beads/issues.jsonl` file. Upstream `bd` CLI will preserve but ignore MEOW-specific fields.\n\n**CONSOLIDATED**: Now includes meow-1l1 (collaborative type) and meow-x9z (gate type).\n\n## Fields to Add\n\n```go\ntype Bead struct {\n    // ... existing fields ...\n    \n    // MEOW-specific: Explicit tier (ignored by upstream bd)\n    Tier          BeadTier       `json:\"tier,omitempty\"`           // work | wisp | orchestrator\n    \n    // MEOW-specific: Workflow tracking (ignored by upstream bd)\n    HookBead       string        `json:\"hook_bead,omitempty\"`      // Work bead this wisp implements\n    SourceWorkflow string        `json:\"source_workflow,omitempty\"` // Workflow that created this\n    WorkflowID     string        `json:\"workflow_id,omitempty\"`    // Unique workflow instance ID\n    \n    // Optional heartbeat\n    LastSeen       time.Time     `json:\"last_seen,omitempty\"`      // Agent heartbeat timestamp\n}\n\ntype BeadTier string\n\nconst (\n    TierWork        BeadTier = \"work\"        // Permanent deliverables  \n    TierWisp        BeadTier = \"wisp\"        // Agent workflow steps (ephemeral)\n    TierOrchestrator BeadTier = \"orchestrator\" // Infrastructure machinery (ephemeral)\n)\n```\n\n## Bead Types (8 total - was 6)\n\n```go\nconst (\n    // Agent-executable\n    BeadTypeTask          BeadType = \"task\"          // Agent does work, auto-continues\n    BeadTypeCollaborative BeadType = \"collaborative\" // Agent + human conversation, pauses\n    BeadTypeGate          BeadType = \"gate\"          // Human approval point (no assignee)\n    \n    // Orchestrator-executable  \n    BeadTypeStart     BeadType = \"start\"\n    BeadTypeStop      BeadType = \"stop\"\n    BeadTypeCondition BeadType = \"condition\"\n    BeadTypeCode      BeadType = \"code\"\n    BeadTypeExpand    BeadType = \"expand\"\n)\n```\n\n## Type-Specific Validation Rules\n\n**collaborative**:\n- MUST have assignee (agent runs the conversation)\n- Auto-continue: NO (meow prime returns empty for in-progress)\n- Tier: wisp (if in ephemeral workflow) or work\n\n**gate**:\n- MUST NOT have assignee (human-facing, not agent-facing)\n- Auto-continue: NO\n- Tier: always orchestrator\n\n## JSON Interoperability\n\nWhen serialized to `issues.jsonl`:\n```json\n{\n  \"id\": \"meow-abc.load-context\",\n  \"title\": \"Load context for bd-task-123\",\n  \"status\": \"open\",\n  \"tier\": \"wisp\",\n  \"hook_bead\": \"bd-task-123\",\n  \"source_workflow\": \"implement-tdd\",\n  \"workflow_id\": \"meow-abc\"\n}\n```\n\nUpstream `bd` will:\n- ✅ Read and display `id`, `title`, `status`\n- ✅ Preserve `tier`, `hook_bead`, etc. when modifying\n- ❌ Not understand MEOW-specific fields (but won't break)\n\n## File Location\nModify: `internal/types/bead.go`\n\n## Acceptance Criteria\n- [ ] BeadTier enum defined with work/wisp/orchestrator\n- [ ] Tier field added to Bead struct with `omitempty`\n- [ ] HookBead, SourceWorkflow, WorkflowID fields added with `omitempty`\n- [ ] BeadTypeCollaborative added with validation (must have assignee)\n- [ ] BeadTypeGate added with validation (must NOT have assignee)\n- [ ] Valid() updated for all 8 types\n- [ ] JSON round-trip test (serialize → deserialize preserves all fields)\n- [ ] Unit tests for tier and type validation","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:52.992979411-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:43.827822479-05:00","closed_at":"2026-01-07T18:46:43.827822479-05:00","close_reason":"Implemented minimal viable slice: module parser, tier tracking, and meow prime command"}
{"id":"meow-bc3","title":"orchestrator.go: expandInlineSteps() doesn't set Tier field","description":"## Location\n`internal/orchestrator/orchestrator.go:836-846`\n\n## Problem\nInline beads created by the orchestrator's `expandInlineSteps()` are missing the Tier field:\n\n```go\nbead := \u0026types.Bead{\n    ID:           beadID,\n    Type:         beadType,\n    Title:        step.Description,\n    Description:  step.Instructions,\n    Instructions: step.Instructions,\n    Status:       types.BeadStatusOpen,\n    Needs:        needs,\n    Parent:       parentBead.ID,\n    CreatedAt:    time.Now(),\n    // Missing: Tier field\n}\n```\n\n## Impact\n- Inline beads have empty tier string\n- Breaks tier-based filtering in `meow prime`\n- Affects orchestrator priority sorting (defaults to work tier priority)\n\n## Relationship\nSimilar to the BakeInline() issue in baker.go - both create inline beads without Tier.\n\n## Fix\nSet appropriate tier (likely TierWisp for inline condition beads):\n```go\nTier: types.TierWisp,\n```\n\n## Severity\nMEDIUM - Affects tier filtering for condition-generated beads","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:04.675626132-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:33:01.84401074-05:00","closed_at":"2026-01-08T02:33:01.84401074-05:00","close_reason":"Fixed in commit 5ea5226. Added Tier: types.TierWisp to bead struct in expandInlineSteps()."}
{"id":"meow-byi","title":"Implement meow handoff command","description":"## Current State\n\nThe `meow handoff` command is a stub that prints \"not yet implemented\".\n\n## Required Functionality\n\nRequest context refresh/handoff for an agent:\n\n```bash\nmeow handoff --notes \"Stopping for context refresh\"\n# Triggers handoff workflow:\n# 1. Saves current progress notes\n# 2. Triggers refresh template\n```\n\n## Per MVP Spec\n\nFrom handoff template pattern:\n1. Agent writes notes to current bead\n2. Agent triggers handoff\n3. Creates handoff record and stops session\n4. New session sees notes via meow prime\n\n## File\n`cmd/meow/cmd/handoff.go`\n\n## Acceptance Criteria\n- [ ] Updates current bead with handoff notes\n- [ ] Triggers refresh workflow if configured\n- [ ] Records handoff in agent state","status":"closed","priority":2,"issue_type":"task","assignee":"agent3","created_at":"2026-01-08T03:04:50.982975891-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:31.018182083-05:00","closed_at":"2026-01-08T03:27:31.018182083-05:00","close_reason":"Closed","labels":["agents","cli"]}
{"id":"meow-c32","title":"Add tier-based filtering to bead queries","description":"BeadStore methods for filtered queries by Tier field per SPEC-ADDENDUM.\n\n## Key Change: Tier Field, Not Labels\n\nFilter on explicit `Tier` field for O(1) comparison:\n\n```go\n// Filter by tier field directly\nfilter := BeadFilter{\n    Tier: TierWisp,\n    Assignee: agentID,\n}\n\n// NOT label scanning\n// BAD: Labels: []string{\"meow:wisp\"}\n```\n\n## Methods to Update\n\n```go\ntype BeadStore interface {\n    // Existing...\n    \n    // Add tier-aware filtering\n    ListByTier(ctx context.Context, tier BeadTier) ([]*types.Bead, error)\n    GetReadyByTier(ctx context.Context, tier BeadTier) ([]*types.Bead, error)\n    \n    // Generic filter with tier support\n    List(ctx context.Context, filter BeadFilter) ([]*types.Bead, error)\n}\n\ntype BeadFilter struct {\n    Tier         *BeadTier\n    ExcludeTiers []BeadTier\n    Status       *BeadStatus\n    Assignee     *string\n    WorkflowID   *string\n    HookBead     *string\n}\n```\n\n## Performance\n\n- **Before**: O(n * labels) to scan labels for tier\n- **After**: O(n) with direct field comparison\n\n## File Location\nModify: `internal/orchestrator/beadstore.go`\n\n## Acceptance Criteria\n- [ ] BeadFilter supports Tier field\n- [ ] ExcludeTiers for negative filtering\n- [ ] Direct field comparison (no label scanning)\n- [ ] Unit tests for tier filtering","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.607344386-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:14:11.143681356-05:00","closed_at":"2026-01-07T18:14:11.143681356-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Query implementation is part of the unified filtering implementation.","dependencies":[{"issue_id":"meow-c32","depends_on_id":"meow-d1h","type":"blocks","created_at":"2026-01-07T16:39:47.619473429-05:00","created_by":"ubuntu"}]}
{"id":"meow-cac","title":"CRITICAL: Minimal vertical slice - validate architecture end-to-end","description":"## Purpose\n\nValidate the three-tier architecture works end-to-end BEFORE implementing all edge cases. This is a focused integration test, not production code.\n\n## The Slice\n\nImplement the **smallest possible working flow**:\n\n```\nSimple module → Parse → Bake with tiers → meow prime shows wisps\n```\n\n### Input: Minimal Test Module\n\n```toml\n# test-slice.meow.toml\n\n[main]\nname = \"test-slice\"\ndescription = \"Minimal vertical slice test\"\nephemeral = true\nhooks_to = \"work_bead\"\n\n[main.variables]\nwork_bead = { required = true, type = \"bead_id\" }\nagent = { required = true, type = \"string\" }\n\n[[main.steps]]\nid = \"step-1\"\ntype = \"task\"\ntitle = \"First wisp step\"\nassignee = \"{{agent}}\"\ninstructions = \"Do the first thing\"\n\n[[main.steps]]\nid = \"step-2\" \ntype = \"task\"\ntitle = \"Second wisp step\"\nassignee = \"{{agent}}\"\nneeds = [\"step-1\"]\ninstructions = \"Do the second thing\"\n```\n\n### Expected Output from `meow prime`\n\n```\n═══════════════════════════════════════════════════════════════\nYour workflow: test-slice (step 1/2)\nWork bead: gt-test-123 \"Test work bead\"\n═══════════════════════════════════════════════════════════════\n\n  → step-1 [in_progress] ← YOU ARE HERE\n  ○ step-2\n\n───────────────────────────────────────────────────────────────\nInstructions:\n  Do the first thing\n───────────────────────────────────────────────────────────────\n```\n\n## Implementation Steps\n\n1. **Module parsing** (use existing parser, extend minimally)\n   - Detect module format (has workflow sections, no [meta])\n   - Parse [main] workflow with steps\n   - Parse variables and hooks_to\n\n2. **Baking with tiers** (extend Baker)\n   - Set Tier = TierWisp for tasks in ephemeral workflow\n   - Set HookBead from hooks_to variable\n   - Set SourceWorkflow and WorkflowID\n\n3. **meow prime output** (new implementation)\n   - Filter beads by Tier = TierWisp AND Assignee = current agent\n   - Format as workflow progression view\n   - Show linked work bead\n\n4. **Integration test**\n   - End-to-end test that:\n     a. Creates a work bead\n     b. Parses the test module\n     c. Bakes with work_bead variable\n     d. Verifies beads have correct tiers\n     e. Calls prime and verifies output format\n\n## What This Validates\n\n- [ ] Module format detection works\n- [ ] Workflow parsing captures ephemeral and hooks_to\n- [ ] Baker correctly sets Tier field based on ephemeral\n- [ ] Baker correctly sets HookBead from hooks_to\n- [ ] Prime filters by tier and formats correctly\n- [ ] Three-tier separation actually works\n\n## What This Does NOT Include\n\n- Legacy format support (separate task)\n- Local references (.implement syntax)\n- External references (file#workflow syntax)\n- Output validation\n- collaborative/gate types\n- Wisp burning/cleanup\n- Full CLI argument handling\n\n## Files to Create/Modify\n\n- `internal/template/module.go` - Minimal module parsing\n- `internal/template/baker.go` - Tier assignment\n- `cmd/meow/cmd/prime.go` - Wisp-aware output\n- `internal/orchestrator/beadstore.go` - Tier filtering\n- `internal/integration_test.go` - End-to-end test\n\n## Success Criteria\n\nThe integration test passes. That's it. This validates the architecture.\n\n## Why This Matters\n\nIf this slice doesn't work, we need to revisit the architecture before building out 40+ other tasks. Fail fast.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T18:15:23.71154853-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:43.829458144-05:00","closed_at":"2026-01-07T18:46:43.829458144-05:00","close_reason":"Implemented minimal viable slice: module parser, tier tracking, and meow prime command","dependencies":[{"issue_id":"meow-cac","depends_on_id":"meow-bba","type":"blocks","created_at":"2026-01-07T18:15:31.076044494-05:00","created_by":"ubuntu"},{"issue_id":"meow-cac","depends_on_id":"meow-8x2","type":"blocks","created_at":"2026-01-07T18:15:31.166052471-05:00","created_by":"ubuntu"}]}
{"id":"meow-cxt","title":"Apply tier labels and metadata","description":"Apply tier and metadata when baking beads. Set explicit Tier field as primary mechanism.\n\n## Tier Assignment Logic\n\n```go\nfunc (b *Baker) determineTier(step *Step, workflow *Workflow) BeadTier {\n    // Non-agent-executable types are always orchestrator\n    if step.Type != \"task\" \u0026\u0026 step.Type != \"collaborative\" \u0026\u0026 step.Type != \"gate\" {\n        return TierOrchestrator\n    }\n    \n    // Gates are orchestrator (human-facing, no agent assignee)\n    if step.Type == \"gate\" {\n        return TierOrchestrator\n    }\n    \n    // Tasks and collaborative in ephemeral workflow → wisp\n    if workflow.Ephemeral {\n        return TierWisp\n    }\n    \n    // Default: work bead\n    return TierWork\n}\n```\n\n## Metadata to Set\n\n1. **Tier** - From determineTier()\n2. **SourceWorkflow** - workflow.Name\n3. **WorkflowID** - Unique instance ID\n4. **HookBead** - From workflow.HooksTo variable (see meow-p84)\n\n## Key Changes from Original Plan\n\n- `collaborative` type handled same as `task` for tier purposes\n- Set `bead.Tier` field directly (not via labels)\n- Labels are optional (`meow:workflow:{id}` for grouping)\n- No `meow:wisp` or `meow:orchestrator` labels needed\n\n## File Location\nModify: `internal/template/baker.go`\n\n## Acceptance Criteria\n- [ ] determineTier() handles task, collaborative, gate correctly\n- [ ] SourceWorkflow set from workflow name\n- [ ] WorkflowID set from baker context\n- [ ] Unit tests for tier assignment including collaborative","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.891186647-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:17:22.229859276-05:00","closed_at":"2026-01-07T18:17:22.229859276-05:00","close_reason":"Covered by meow-cac (vertical slice). determineTier(), SourceWorkflow, WorkflowID are all part of the minimal baking implementation. Production hardening can happen incrementally after slice validates approach.","dependencies":[{"issue_id":"meow-cxt","depends_on_id":"meow-fxw","type":"blocks","created_at":"2026-01-07T16:39:47.245430398-05:00","created_by":"ubuntu"},{"issue_id":"meow-cxt","depends_on_id":"meow-x9z","type":"blocks","created_at":"2026-01-07T17:53:25.253459399-05:00","created_by":"ubuntu"},{"issue_id":"meow-cxt","depends_on_id":"meow-1l1","type":"blocks","created_at":"2026-01-07T17:59:22.839142317-05:00","created_by":"ubuntu"},{"issue_id":"meow-cxt","depends_on_id":"meow-cac","type":"blocks","created_at":"2026-01-07T18:16:51.776633061-05:00","created_by":"ubuntu"},{"issue_id":"meow-cxt","depends_on_id":"meow-bba","type":"blocks","created_at":"2026-01-07T18:16:51.874234617-05:00","created_by":"ubuntu"}]}
{"id":"meow-cy5","title":"Bug: meow run does not start orchestrator loop","description":"## Problem\n\nThe `meow run` command creates beads from a template but does NOT start the orchestrator loop to execute them. This means workflows never actually run.\n\n## Current Behavior\n\n```bash\nmeow run template.toml --var key=value\n# Output:\n# Created 3 beads from template: template.toml\n# Workflow ID: meow-12345\n# Run 'meow prime' to see your first task.\n# \u003c- Command exits here\n```\n\nThe orchestrator's `Run()` method is never called.\n\n## Expected Behavior\n\nOption A: `meow run` should start the orchestrator loop (blocking or background):\n```bash\nmeow run template.toml  # Starts orchestrator, processes beads\nmeow run template.toml --background  # Starts in background\n```\n\nOption B: Separate commands:\n```bash\nmeow bake template.toml   # Just creates beads (current behavior)\nmeow orchestrate          # Starts orchestrator loop\n```\n\n## Impact\n\n- Workflows don't execute automatically\n- `start` beads never spawn agents\n- `code` beads never execute\n- `condition` beads never evaluate\n- The entire orchestrator is unused\n\n## File\n`cmd/meow/cmd/run.go` - Lines 117-143\n\nThe code loads beads but never calls `orchestrator.Run()`\n\n## Acceptance Criteria\n- [ ] `meow run` actually runs the orchestrator\n- [ ] Orchestrator dispatches start/code/condition/expand beads\n- [ ] Task beads wait for agent to close them\n- [ ] Workflow completes when all beads closed","status":"closed","priority":0,"issue_type":"bug","assignee":"agent1","created_at":"2026-01-08T03:03:54.459815506-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:28:44.805591314-05:00","closed_at":"2026-01-08T03:28:44.805591314-05:00","close_reason":"Closed","labels":["cli","critical","orchestrator"]}
{"id":"meow-d1h","title":"Prioritize orchestrator beads in ready selection","description":"Update GetNextReady to prioritize by tier per SPEC-ADDENDUM.\n\n## Priority Order\n\n1. **Orchestrator beads** (start, stop, condition, code, expand, gate)\n2. **Wisp beads** (task beads with Tier=wisp)\n3. **Work beads** (task beads with Tier=work)\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) GetNextReady(ctx context.Context) (*types.Bead, error) {\n    ready, _ := o.store.GetReady(ctx, BeadFilter{\n        Statuses: []BeadStatus{StatusOpen},\n    })\n    \n    if len(ready) == 0 {\n        return nil, nil\n    }\n    \n    // Sort by tier priority (orchestrator first)\n    sort.Slice(ready, func(i, j int) bool {\n        return tierPriority(ready[i].Tier) \u003c tierPriority(ready[j].Tier)\n    })\n    \n    return ready[0], nil\n}\n\nfunc tierPriority(tier BeadTier) int {\n    switch tier {\n    case TierOrchestrator:\n        return 0  // Highest priority\n    case TierWisp:\n        return 1\n    case TierWork:\n        return 2\n    default:\n        return 3\n    }\n}\n```\n\n## Why Orchestrator First\n\nOrchestrator beads (start, stop, condition, expand) set up the environment for agent work. They must complete before agents see their tasks:\n- `start` spawns the agent\n- `expand` creates the wisps the agent will execute\n- `condition` determines branching before agent proceeds\n\n## File Location\nModify: `internal/orchestrator/orchestrator.go`\n\n## Acceptance Criteria\n- [ ] GetNextReady sorts by tier\n- [ ] Orchestrator beads processed before wisps\n- [ ] Wisps processed before work beads\n- [ ] Tie-breaker by creation time","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.359113179-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:14:12.377609908-05:00","closed_at":"2026-01-07T18:14:12.377609908-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Priority selection is part of the unified filtering implementation.","dependencies":[{"issue_id":"meow-d1h","depends_on_id":"meow-0tx","type":"blocks","created_at":"2026-01-07T16:40:07.589396447-05:00","created_by":"ubuntu"},{"issue_id":"meow-d1h","depends_on_id":"meow-p84","type":"blocks","created_at":"2026-01-07T16:40:07.714176873-05:00","created_by":"ubuntu"}]}
{"id":"meow-dax","title":"Implement tier-based bead filtering (consolidated)","description":"Consolidated task merging meow-00g, meow-a85, meow-c32.\n\n## Scope\n\nImplement complete tier-based filtering in one coherent piece:\n\n### 1. Label Conventions (was meow-00g)\nDefine standard labels:\n- `meow:tier:work` / `meow:tier:wisp` / `meow:tier:orchestrator`\n- `meow:workflow:{id}` for workflow instance tracking\n- `meow:ephemeral` (existing, keep for backward compat)\n\n### 2. Filter Types (was meow-a85)\n```go\ntype BeadFilter struct {\n    Tier       BeadTier   // Filter by tier\n    WorkflowID string     // Filter by workflow instance\n    Assignee   string     // Filter by agent\n    Status     BeadStatus // Filter by status\n    HookBead   string     // Filter by linked work bead\n}\n```\n\n### 3. Query Implementation (was meow-c32)\nAdd to BeadStore interface:\n```go\nListByTier(ctx, tier BeadTier) ([]*Bead, error)\nListWispsForAgent(ctx, agentID string) ([]*Bead, error)\nListOrchestrator(ctx, workflowID string) ([]*Bead, error)\n```\n\n### 4. Ready Selection Priority (was meow-d1h)\nOrchestrator beads processed before agent beads:\n```go\nfunc (o *Orchestrator) GetNextReady() *Bead {\n    // 1. Check orchestrator tier first (machinery)\n    // 2. Then wisp tier (agent workflow steps)\n    // 3. Never return work tier from here (agent selects those)\n}\n```\n\n## Files to Modify\n- `internal/types/bead.go` - BeadFilter struct\n- `internal/orchestrator/beadstore.go` - Query methods\n- `internal/orchestrator/orchestrator.go` - Priority selection\n\n## Acceptance Criteria\n- [ ] Label conventions documented\n- [ ] BeadFilter struct with tier field\n- [ ] ListByTier, ListWispsForAgent, ListOrchestrator methods\n- [ ] GetNextReady prioritizes orchestrator \u003e wisp\n- [ ] Unit tests for filtering","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T18:13:47.860295186-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:08:27.964792846-05:00","closed_at":"2026-01-08T02:08:27.964792846-05:00","close_reason":"Implemented tier-based bead filtering: BeadFilter with HookBead field, ListByTier/ListWispsForAgent/ListOrchestrator methods, tier-based priority in GetNextReady (orchestrator \u003e wisp \u003e work), and comprehensive unit tests","dependencies":[{"issue_id":"meow-dax","depends_on_id":"meow-bba","type":"blocks","created_at":"2026-01-07T18:14:04.228144733-05:00","created_by":"ubuntu"},{"issue_id":"meow-dax","depends_on_id":"meow-cac","type":"blocks","created_at":"2026-01-07T18:15:49.102576601-05:00","created_by":"ubuntu"}]}
{"id":"meow-db2","title":"Add hooked status for wisp beads","description":"New BeadStatusHooked for when agent claims wisp step. See IMPLEMENTATION-PLAN section meow-modules-types-status.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:53.088124645-05:00","created_by":"ubuntu","updated_at":"2026-01-07T17:50:04.45127359-05:00","closed_at":"2026-01-07T17:50:04.45127359-05:00","close_reason":"Spec refinement: No hooked status. The SPEC-ADDENDUM-WISPS-AND-MODULES.md explicitly removes the hooked status (lines 179-210). Three statuses only: open, in_progress, closed. Use LastSeen timestamp for heartbeat tracking if needed."}
{"id":"meow-dvr","title":"Implement external reference resolution","description":"Resolve file#workflow external references with cycle detection. See IMPLEMENTATION-PLAN section meow-modules-loader-external.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.509975604-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:17:49.635081236-05:00","dependencies":[{"issue_id":"meow-dvr","depends_on_id":"meow-m3k","type":"blocks","created_at":"2026-01-07T16:39:46.972207258-05:00","created_by":"ubuntu"}]}
{"id":"meow-e1","title":"Foundation: Project setup and core infrastructure","description":"Establish the foundational infrastructure for MEOW Stack including project\nstructure, core types, CLI skeleton, and build system.\n","notes":"## Why This Epic Matters\n\nA solid foundation prevents technical debt. Every component depends on\nthese core types and patterns. Getting this right saves refactoring later.\n\n## Deliverables\n1. Go project structure with modules\n2. Core types (Bead, Agent, Template, Config)\n3. CLI skeleton using Cobra\n4. Build system (Makefile)\n5. Basic configuration handling\n\n## Success Criteria\n- `go build` produces working `meow` binary\n- `meow --version` and `meow --help` work\n- Core types are defined and usable\n- Basic project structure matches architecture doc\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T05:07:01.620295717-05:00","closed_at":"2026-01-07T05:07:01.620295717-05:00","close_reason":"Foundation epic complete: Go project structure, core types (Bead/Agent/Config), CLI skeleton with Cobra, Makefile build system, config loading, structured logging, error types. All tests pass, binary builds and runs.","labels":["epic","foundation","phase-1"]}
{"id":"meow-e1.1","title":"Initialize Go project with module structure","description":"Create the Go project structure for MEOW Stack.","notes":"## Directory Structure\n```\nmeow-machine/\n├── cmd/meow/                  # CLI entry point\n├── internal/\n│   ├── config/               # Configuration handling\n│   ├── types/                # Core data types\n│   ├── orchestrator/         # Orchestrator engine\n│   ├── template/             # Template system\n│   ├── agent/                # Agent management\n│   └── primitive/            # Primitive handlers\n├── pkg/meow/                 # Public API (if needed)\n├── templates/                # Default templates (embedded)\n├── go.mod\n├── Makefile\n└── README.md\n```\n\n## Commands\n```bash\ngo mod init github.com/your-org/meow-machine\nmkdir -p cmd/meow internal/{config,types,orchestrator,template,agent,primitive}\n```\n\n## Acceptance Criteria\n- [ ] `go mod init` creates valid go.mod\n- [ ] Directory structure matches plan\n- [ ] `.gitignore` includes Go artifacts\n- [ ] Basic `main.go` compiles\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:21:57.587121961-05:00","closed_at":"2026-01-07T03:21:57.587121961-05:00","close_reason":"Go project initialized with module structure, .gitignore, and compiling main.go","labels":["foundation","setup"]}
{"id":"meow-e1.2","title":"Define core data types (Bead, Agent, Template, Config)","description":"Define the fundamental data structures used throughout MEOW.","notes":"## Types to Define\n\n### Bead (internal/types/bead.go)\n- BeadType enum (task, condition, stop, start, code, expand) - 6 primitives\n- BeadStatus enum (open, in_progress, closed)\n- Bead struct with all fields\n- Primitive-specific spec structs (ConditionSpec, StartSpec, CodeSpec, etc.)\n- OutputSpec for code bead outputs (stdout, file capture)\n- TaskOutputSpec for required/optional task outputs with types\n- EphemeralFlag for cleanup behavior\n\n### Agent (internal/types/agent.go)\n- AgentStatus enum (active, stopped)\n- Agent struct with session tracking\n- Session ID storage (for resume composition)\n\n### Config (internal/config/config.go)\n- Config struct for TOML loading\n- DefaultsConfig for default values\n- EphemeralCleanup settings\n\n## Design Decisions\n\n**Why 6 primitives instead of 8?**\ncheckpoint and resume are now composed from code + start:\n- checkpoint → code bead running `meow session-id`\n- resume → start bead with `resume_session` parameter\n\n**Why separate spec structs?**\nEach primitive has different fields. Using embedded structs keeps the\nmain Bead type clean while allowing type-safe access.\n\n## Acceptance Criteria\n- [ ] All types compile without errors\n- [ ] JSON marshaling/unmarshaling works correctly\n- [ ] OutputSpec handles stdout, stderr, file capture\n- [ ] TaskOutputSpec handles required/optional with types\n- [ ] Types have appropriate comments/godoc\n- [ ] Unit tests for marshaling edge cases\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:25:40.677515046-05:00","closed_at":"2026-01-07T03:25:40.677515046-05:00","close_reason":"Core types defined: Bead (6 primitives), Agent, Config with full test coverage","labels":["foundation","types"],"dependencies":[{"issue_id":"meow-e1.2","depends_on_id":"meow-e1.1","type":"blocks","created_at":"2026-01-07T03:14:29.867045093-05:00","created_by":"ubuntu"}]}
{"id":"meow-e1.3","title":"Create CLI skeleton with Cobra","description":"Set up the CLI framework using Cobra with stub commands.","notes":"## Commands to Stub\n\n### User Commands\n- `meow init` - Initialize .meow directory\n- `meow run \u003ctemplate\u003e` - Start workflow\n- `meow status` - Show current state\n- `meow approve [bead]` - Approve a gate\n- `meow reject [bead]` - Reject a gate\n\n### Agent Commands\n- `meow prime` - Show next task for agent\n- `meow close \u003cbead\u003e` - Close a task\n- `meow handoff` - Request context refresh\n\n### Debug Commands\n- `meow agents` - List agents\n- `meow trace` - Show execution trace\n- `meow validate \u003ctemplate\u003e` - Validate template\n\n## File Structure\n```\ncmd/meow/\n├── main.go\n├── root.go\n├── init.go\n├── run.go\n└── ...\n```\n\n## Acceptance Criteria\n- [ ] `meow --help` shows all commands\n- [ ] `meow \u003ccmd\u003e --help` shows command-specific help\n- [ ] `meow --version` shows version\n- [ ] Commands parse arguments correctly\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:36:45.583611903-05:00","closed_at":"2026-01-07T03:36:45.583611903-05:00","close_reason":"CLI skeleton with Cobra: init, run, status, approve, reject, prime, close, handoff, agents, trace, validate","labels":["cli","foundation"],"dependencies":[{"issue_id":"meow-e1.3","depends_on_id":"meow-e1.1","type":"blocks","created_at":"2026-01-07T03:14:29.973239873-05:00","created_by":"ubuntu"}]}
{"id":"meow-e1.4","title":"Create Makefile and build scripts","description":"Create build automation for the project.","notes":"## Makefile Targets\n- `build` - Build binary to bin/meow\n- `install` - Install to GOPATH/bin\n- `test` - Run all tests\n- `test-short` - Run short tests\n- `lint` - Run golangci-lint\n- `clean` - Remove artifacts\n- `generate` - Run go generate\n\n## Version Embedding\nUse ldflags to embed version from git tags:\n```makefile\nVERSION ?= $(shell git describe --tags --always --dirty)\nLDFLAGS := -ldflags \"-X main.version=$(VERSION)\"\n```\n\n## Acceptance Criteria\n- [ ] `make build` produces binary\n- [ ] `make test` runs tests\n- [ ] `make lint` runs linter\n- [ ] Version embedded correctly\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:03:38.056255802-05:00","closed_at":"2026-01-07T05:03:38.056255802-05:00","close_reason":"Makefile created with all targets: build, install, test, test-short, test-cover, lint, fmt, vet, tidy, generate, clean, run, version, check, help. Version embedding works via ldflags.","labels":["build","foundation"],"dependencies":[{"issue_id":"meow-e1.4","depends_on_id":"meow-e1.1","type":"blocks","created_at":"2026-01-07T03:14:30.059554844-05:00","created_by":"ubuntu"}]}
{"id":"meow-e1.5","title":"Implement configuration loading and defaults","description":"Implement configuration file loading and sensible defaults.","notes":"## Config File Locations (priority order)\n1. `.meow/config.toml` (project-local)\n2. `~/.config/meow/config.toml` (user global)\n3. Built-in defaults\n\n## Default Configuration\n```toml\nversion = \"1\"\n\n[paths]\ntemplate_dir = \".meow/templates\"\nbeads_dir = \".beads\"\nstate_dir = \".meow/state\"\n\n[defaults]\nagent = \"claude-1\"\nstop_grace_period = 10\ncondition_timeout = \"1h\"\n\n[orchestrator]\npoll_interval = \"100ms\"\nheartbeat_interval = \"30s\"\n\n[cleanup]\nephemeral = \"on_complete\"  # on_complete | manual | never\n\n[logging]\nlevel = \"info\"  # debug | info | warn | error\nformat = \"json\"  # json | text\nfile = \".meow/state/meow.log\"\n```\n\n## Acceptance Criteria\n- [ ] Default config works with no file present\n- [ ] Project-local config overrides defaults\n- [ ] Unknown fields ignored (forward compatibility)\n- [ ] Invalid config produces helpful error\n- [ ] Unit tests for config loading edge cases\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:02:16.005808874-05:00","closed_at":"2026-01-07T05:02:16.005808874-05:00","close_reason":"Configuration loading fully implemented with Load, LoadFromDir, Validate, path helpers, and comprehensive test coverage","labels":["config","foundation"],"dependencies":[{"issue_id":"meow-e1.5","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:30.149720604-05:00","created_by":"ubuntu"}]}
{"id":"meow-e1.6","title":"Implement structured logging infrastructure","description":"Set up structured logging for debugging and observability.","notes":"## Why Logging Matters\nMEOW orchestrates long-running workflows. When things go wrong, we need:\n- Clear timestamps for every action\n- Structured fields for filtering (agent, bead_id, action)\n- Log levels for verbosity control\n- File output for post-mortem analysis\n\n## Implementation\nUse zerolog or zap for structured JSON logging.\n\n## Log Levels\n- DEBUG: Variable substitution, bead state changes\n- INFO: Bead dispatch, agent spawn/stop, template expansion\n- WARN: Retries, timeouts, missing optional fields\n- ERROR: Validation failures, crashes, unrecoverable states\n\n## Log Fields (always include)\n```json\n{\n  \"ts\": \"2026-01-07T12:00:00Z\",\n  \"level\": \"info\",\n  \"msg\": \"Dispatching bead\",\n  \"bead_id\": \"bd-task-001\",\n  \"bead_type\": \"task\",\n  \"agent\": \"claude-1\",\n  \"workflow_id\": \"meow-run-001\"\n}\n```\n\n## Acceptance Criteria\n- [ ] Logger initialized from config\n- [ ] All major actions logged with context\n- [ ] Log rotation (max file size)\n- [ ] DEBUG level shows internal state\n- [ ] JSON format parseable by jq\n- [ ] Unit tests for log output format\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:06:33.648484168-05:00","closed_at":"2026-01-07T05:06:33.648484168-05:00","close_reason":"Structured logging infrastructure implemented: NewFromConfig for config-based initialization, file output with directory creation, JSON/text formats, level parsing, context helpers (WithWorkflow, WithBead, WithAgent), comprehensive test coverage","labels":["foundation","logging"],"dependencies":[{"issue_id":"meow-e1.6","depends_on_id":"meow-e1.5","type":"blocks","created_at":"2026-01-07T03:14:30.240051401-05:00","created_by":"ubuntu"}]}
{"id":"meow-e1.7","title":"Define error types and codes","description":"Define structured error types for consistent error handling.","notes":"## Error Categories\n- **ConfigError**: Invalid config, missing required fields\n- **TemplateError**: Parse error, validation error, missing template\n- **BeadError**: Invalid state transition, missing dependency, cycle\n- **AgentError**: Spawn failed, session not found, timeout\n- **OutputError**: Type mismatch, missing required, validation failed\n- **IOError**: File not found, permission denied, disk full\n\n## Error Structure\n```go\ntype MeowError struct {\n    Code    string   // \"TMPL_PARSE_001\"\n    Message string   // Human-readable\n    Details map[string]any  // Context\n    Cause   error    // Wrapped error\n}\n```\n\n## Error Codes\n```\nCONFIG_001: Missing required field\nCONFIG_002: Invalid value type\nTMPL_001: Parse error\nTMPL_002: Validation error - missing field\nTMPL_003: Validation error - cycle detected\nBEAD_001: Invalid status transition\nBEAD_002: Dependency not satisfied\nAGENT_001: Session spawn failed\nAGENT_002: Session not found\nOUTPUT_001: Missing required output\nOUTPUT_002: Type validation failed\nOUTPUT_003: Bead ID not found\n```\n\n## Acceptance Criteria\n- [ ] All error types defined\n- [ ] Errors include context (bead_id, template, etc.)\n- [ ] Errors are JSON-serializable\n- [ ] CLI shows human-readable messages\n- [ ] Unit tests for error formatting\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:05:11.408690241-05:00","closed_at":"2026-01-07T05:05:11.408690241-05:00","close_reason":"Error types defined: MeowError struct with Code/Message/Details/Cause, all error codes (CONFIG, TMPL, BEAD, AGENT, OUTPUT, IO), factory functions for each error type, JSON serialization, Is/Code helpers, comprehensive test coverage","labels":["errors","foundation"],"dependencies":[{"issue_id":"meow-e1.7","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:30.320856018-05:00","created_by":"ubuntu"}]}
{"id":"meow-e10","title":"CLI Completion: All commands","description":"Complete all CLI commands.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T03:12:48.457391798-05:00","labels":["cli","epic","phase-4"],"dependencies":[{"issue_id":"meow-e10","depends_on_id":"meow-e3","type":"blocks","created_at":"2026-01-07T03:14:35.199949701-05:00","created_by":"ubuntu"},{"issue_id":"meow-e10","depends_on_id":"meow-e4","type":"blocks","created_at":"2026-01-07T03:14:35.288380895-05:00","created_by":"ubuntu"},{"issue_id":"meow-e10","depends_on_id":"meow-e5","type":"blocks","created_at":"2026-01-07T03:14:35.379231928-05:00","created_by":"ubuntu"}]}
{"id":"meow-e10.1","title":"Implement meow init command","description":"Initialize .meow directory.","notes":"- Create directory structure\n- Copy default templates\n- Create config.toml\n- Setup Claude Code hooks\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T20:39:40.477442716-05:00","closed_at":"2026-01-07T20:39:40.477442716-05:00","close_reason":"Implemented meow init with embedded templates (simple, tdd), Claude Code hooks setup, .beads directory creation, and configurable flags (--hooks, --skip-templates).","labels":["cli","init"]}
{"id":"meow-e10.2","title":"Implement meow run command","description":"Start workflow execution.","notes":"Usage: meow run \u003ctemplate\u003e [--var key=value]...\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T19:29:21.045542964-05:00","closed_at":"2026-01-07T19:29:21.045542964-05:00","close_reason":"Implemented meow run command with template parsing, baking, and bead store integration. Supports --dry-run, --var, and --workflow flags.","labels":["cli","run"],"dependencies":[{"issue_id":"meow-e10.2","depends_on_id":"meow-e3.4","type":"blocks","created_at":"2026-01-07T03:14:35.470072244-05:00","created_by":"ubuntu"}]}
{"id":"meow-e10.3","title":"Implement meow prime command","description":"Show next task for agent with required outputs.","notes":"## Behavior\n1. Read $MEOW_AGENT to identify current agent\n2. Find assigned ready bead\n3. Output formatted context including:\n   - Task title and description\n   - **Required outputs with types and descriptions**\n   - Example close command\n   - Recently completed beads (optional context)\n\n## Output Format\n```\n=== YOUR CURRENT TASK ===\nBead: bd-select-001\nTitle: Select next task to work on\n\nInstructions:\n  Run: bv --robot-triage\n  Pick the highest priority ready task.\n\nREQUIRED OUTPUTS when closing:\n  work_bead (bead_id): The bead ID to implement\n  rationale (string): Why you chose this bead\n\nExample:\n  meow close bd-select-001 \\\n    --output work_bead=bd-task-XXX \\\n    --output rationale=\"...\"\n\nRECENTLY COMPLETED:\n  bd-task-000 \"Setup project\" (closed 5m ago)\n```\n\n## Acceptance Criteria\n- [ ] Reads agent from environment\n- [ ] Finds ready bead for agent\n- [ ] Shows task details\n- [ ] **Shows required outputs if defined**\n- [ ] Shows example close command\n- [ ] Shows recently completed beads (optional)\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T18:13:03.758900727-05:00","closed_at":"2026-01-07T18:13:03.758900727-05:00","close_reason":"Superseded by meow-97m (wisp-aware meow prime). Implementing basic prime first then rewriting for wisps is wasteful - go directly to wisp-aware version.","labels":["cli","prime"],"dependencies":[{"issue_id":"meow-e10.3","depends_on_id":"meow-e7.4","type":"blocks","created_at":"2026-01-07T03:14:35.560130626-05:00","created_by":"ubuntu"}]}
{"id":"meow-e10.4","title":"Implement meow close command","description":"Close a task bead with optional validated outputs.","notes":"## Usage\n```bash\nmeow close \u003cbead-id\u003e\nmeow close \u003cbead-id\u003e --notes \"...\"\nmeow close \u003cbead-id\u003e --output key=value --output key2=value2\nmeow close \u003cbead-id\u003e --output-json '{\"key\": \"value\"}'\n```\n\n## Output Validation\nIf the bead has required outputs defined, the close command must:\n1. Check all required outputs are provided\n2. Validate output types (string, bead_id, file_path, etc.)\n3. Return error with helpful message if validation fails\n4. Store validated outputs on the bead\n\n## Example Error\n```\nError: Cannot close bd-select-001 - missing required outputs\n\nRequired outputs:\n  ✗ work_bead (bead_id): Not provided\n  ✗ rationale (string): Not provided\n\nUsage:\n  meow close bd-select-001 --output work_bead=\u003cbead_id\u003e --output rationale=\u003cstring\u003e\n```\n\n## Acceptance Criteria\n- [ ] Closes bead with status update\n- [ ] Supports --notes flag\n- [ ] **Supports --output key=value flags**\n- [ ] **Supports --output-json for complex outputs**\n- [ ] **Validates required outputs before closing**\n- [ ] **Returns helpful error for missing/invalid outputs**\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T18:13:05.884935639-05:00","closed_at":"2026-01-07T18:13:05.884935639-05:00","close_reason":"Superseded by meow-74h (meow close with output validation). The wisp-aware version is the real target - no point implementing a simpler version first.","labels":["cli","close"]}
{"id":"meow-e10.5","title":"Implement meow status command","description":"Show comprehensive workflow status.","notes":"## Usage\n```bash\nmeow status                 # Current workflow status\nmeow status --verbose       # Include all beads\nmeow status --json          # JSON output for scripting\nmeow status --watch         # Live updates\n```\n\n## Output Format\n```\n=== MEOW WORKFLOW STATUS ===\nWorkflow: work-loop (started 2h ago)\nTemplate: work-loop.toml\n\nAGENTS:\n  claude-1        active     (running for 45m)\n  claude-1-worker stopped    (completed 10m ago)\n\nBEADS:\n  Total: 15  Open: 3  In Progress: 1  Closed: 11\n\n  Currently executing:\n    → bd-task-005 \"Implement auth endpoint\" (claude-1, 5m)\n\n  Ready to execute:\n    • bd-task-006 \"Write integration tests\"\n    • bd-task-007 \"Update documentation\"\n\n  Recently closed:\n    ✓ bd-task-004 \"Setup database\" (2m ago)\n    ✓ bd-task-003 \"Create models\" (15m ago)\n\nOUTPUTS (recent):\n  select-task.work_bead = \"bd-task-005\"\n  setup-worktree.path = \".meow/worktrees/worker\"\n\nHEALTH:\n  Orchestrator: running (heartbeat 5s ago)\n  Lock: held by PID 12345\n```\n\n## Acceptance Criteria\n- [ ] Shows agent status\n- [ ] Shows bead counts and states\n- [ ] Shows currently executing beads\n- [ ] Shows recent outputs\n- [ ] --json produces parseable output\n- [ ] --watch updates live\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["cli","status"]}
{"id":"meow-e10.6","title":"Implement debug commands","description":"agents, beads, trace, peek, clean commands.","notes":"## Commands\n- `meow agents [--active]` - List agents and states\n- `meow beads [--ready] [--include-ephemeral]` - List beads\n- `meow trace [--follow]` - Show execution trace\n- `meow peek \u003cagent\u003e` - Show agent's current output\n- `meow attach \u003cagent\u003e` - Attach to tmux session\n- `meow clean --ephemeral` - Clean up ephemeral beads\n\n## --include-ephemeral Flag\nBy default, beads with `meow:ephemeral` label are hidden.\nThis keeps focus on work beads, not workflow machinery.\n\n## Acceptance Criteria\n- [ ] All debug commands work\n- [ ] Ephemeral beads hidden by default\n- [ ] --include-ephemeral shows all beads\n- [ ] meow clean --ephemeral removes closed ephemeral beads\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["cli","debug"]}
{"id":"meow-e11","title":"Comprehensive Testing: Unit, Integration, and E2E","description":"Comprehensive test coverage including unit tests, integration tests, and\nend-to-end tests with mock Claude. This epic is CRITICAL for reliability.\n","notes":"## Why This Epic is Non-Negotiable\nMEOW orchestrates long-running AI workflows. Bugs can waste hours of compute\nand cause data loss. We need:\n- Unit tests for every component\n- Integration tests for component interactions\n- E2E tests simulating real workflows\n- Detailed logging for debugging test failures\n\n## Phased Testing Strategy\nTesting is NOT a Phase 4 afterthought. Tests are written alongside code:\n\n| Test Type | Phase | Dependencies |\n|-----------|-------|--------------|\n| Test infrastructure (e11.1) | Phase 2 | E1 (types) |\n| Unit tests (e11.2-e11.5) | Phase 2 | Respective components |\n| Integration tests (e11.6) | Phase 3 | Core primitives |\n| E2E tests (e11.7) | Phase 4 | CLI + full system |\n| Performance (e11.8) | Phase 4 | Full system |\n\n## Test Categories\n1. **Unit Tests**: Individual functions and types (write with component)\n2. **Integration Tests**: Component interactions (write after primitives)\n3. **E2E Tests**: Full workflow execution with mock Claude (write after CLI)\n4. **Stress Tests**: Performance under load (final phase)\n\n## Coverage Requirements\n- Minimum 80% line coverage\n- 100% coverage for critical paths (output validation, bead transitions)\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T03:12:48.457391798-05:00","labels":["critical","epic","testing"]}
{"id":"meow-e11.1","title":"Create test infrastructure and fixtures","description":"Set up testing infrastructure, fixtures, and helpers.","notes":"## Test Infrastructure\n\n### Directory Structure\n```\ninternal/testutil/\n├── fixtures.go      # Test data factories\n├── mock_tmux.go     # Mock tmux for agent tests\n├── mock_claude.go   # Mock Claude responses\n├── assertions.go    # Custom assertions\n├── logger.go        # Test logger that captures output\n└── cleanup.go       # Test cleanup helpers\n```\n\n### Test Fixtures\n```go\n// Create test beads\nfunc NewTestBead(t *testing.T, beadType string) *types.Bead\nfunc NewTestTemplate(t *testing.T, name string) *template.Template\nfunc NewTestConfig(t *testing.T) *config.Config\n\n// Create temp directories\nfunc NewTestWorkspace(t *testing.T) (path string, cleanup func())\n\n// Mock tmux\nfunc NewMockTmux(t *testing.T) *MockTmux\n```\n\n### Mock Claude\nScript that simulates Claude Code behavior:\n```bash\n#!/bin/bash\n# mock_claude.sh - Simulates Claude Code for testing\n# Reads meow prime, executes predefined responses, runs meow close\n\ncase \"$1\" in\n  --dangerously-skip-permissions)\n    # Enter mock REPL\n    while read -r line; do\n      if [[ \"$line\" == \"meow prime\" ]]; then\n        # Simulate Claude reading task and closing\n        BEAD_ID=$(meow prime --format json | jq -r .bead_id)\n        sleep 0.1\n        meow close \"$BEAD_ID\" --notes \"Mock completed\"\n      fi\n    done\n    ;;\nesac\n```\n\n### Test Logger\n```go\n// Captures structured logs for assertion\ntype TestLogger struct {\n    Entries []LogEntry\n}\n\nfunc (l *TestLogger) AssertContains(t *testing.T, msg string)\nfunc (l *TestLogger) AssertLevel(t *testing.T, level string, count int)\n```\n\n## Acceptance Criteria\n- [ ] Test fixtures create valid test data\n- [ ] Mock tmux simulates session lifecycle\n- [ ] Mock Claude script runs and responds\n- [ ] Test logger captures structured output\n- [ ] Cleanup removes all temp files\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T14:23:53.479373615-05:00","closed_at":"2026-01-07T14:23:53.479373615-05:00","close_reason":"Closed","labels":["infrastructure","phase-2","testing"],"dependencies":[{"issue_id":"meow-e11.1","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:35.647890862-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.10","title":"Create example workflows","description":"Complete example projects demonstrating MEOW capabilities.","notes":"## Example Projects\n```\nexamples/\n├── hello-world/           # Simplest possible workflow\n├── tdd-implementation/    # TDD with implement template\n├── multi-agent/           # Parent/child with call template\n├── human-approval/        # Human gate workflow\n└── context-aware/         # Context checking and refresh\n```\n\n## Each Example Includes\n- README with explanation\n- Complete template files\n- Expected output/trace\n- Troubleshooting tips\n\n## Acceptance Criteria\n- [ ] Each example runs standalone\n- [ ] Examples tested in CI\n- [ ] README explains what happens\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["docs","examples"]}
{"id":"meow-e11.2","title":"Unit tests for core types","description":"Unit tests for Bead, Agent, Config, and Template types.","notes":"## Test Files\n- internal/types/bead_test.go\n- internal/types/agent_test.go\n- internal/config/config_test.go\n- internal/template/template_test.go\n\n## Test Cases\n\n### Bead Tests\n- [ ] JSON marshaling/unmarshaling round-trip\n- [ ] Status transitions (open → in_progress → closed)\n- [ ] Invalid status transition errors\n- [ ] Output storage and retrieval\n- [ ] Ephemeral label detection\n- [ ] Dependency parsing\n\n### Agent Tests\n- [ ] State transitions (active → stopped)\n- [ ] Session ID storage\n- [ ] Environment variable generation\n\n### Config Tests\n- [ ] Default values applied\n- [ ] File override works\n- [ ] Unknown fields ignored\n- [ ] Invalid values error with context\n\n### Template Tests\n- [ ] TOML parsing\n- [ ] Variable definition parsing\n- [ ] Step dependency parsing\n- [ ] Output spec parsing\n\n## Acceptance Criteria\n- [ ] All types have \u003e90% coverage\n- [ ] Edge cases covered (empty, nil, max values)\n- [ ] Error messages tested\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:38:01.843420441-05:00","closed_at":"2026-01-08T01:38:01.843420441-05:00","close_reason":"Completed: Unit tests for core types with 100% coverage, plus review fixes for orchestrator and template","labels":["phase-2","testing","unit"],"dependencies":[{"issue_id":"meow-e11.2","depends_on_id":"meow-e11.1","type":"blocks","created_at":"2026-01-07T03:14:35.733868852-05:00","created_by":"ubuntu"},{"issue_id":"meow-e11.2","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:35.823298363-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.3","title":"Unit tests for template system","description":"Unit tests for template parsing, validation, and baking.","notes":"## Progress Summary\n\n### Coverage Achieved: 90.1% (target: \u003e90%)\n\n### New Tests Added\n\n#### parser_test.go\n- TestParseString_StepWithID_Empty\n- TestParseString_StepWithCode\n- TestParseString_StepWithAction\n- TestParseString_StepWithValidation\n- TestParseString_MetaFields\n- TestParseString_StepWithTimeout\n- TestParseString_StepWithAssignee\n- TestParseString_StepWithOnTimeout\n- TestParseString_InlineStepsInCondition\n- TestParseString_IntVariable\n- TestParseString_VariableWithDescription\n\n#### baker_test.go\n- TestBaker_BakeWorkflow_CodeStep\n- TestBaker_BakeWorkflow_StartStopSteps\n- TestBaker_BakeWorkflow_ExpandStep\n- TestBaker_BakeWorkflow_ConditionStep\n- TestBaker_BakeWorkflow_NilWorkflow\n- TestBaker_BakeWorkflow_MissingRequiredVariable\n- TestBaker_BakeWorkflow_DefaultVariable\n- TestBaker_BakeWorkflow_VariableOverride\n- TestBaker_BakeWorkflow_EphemeralStep\n- TestBaker_BakeWorkflow_UnknownDependency\n- TestBaker_determineBeadTypeFromString_AllTypes\n- TestBaker_BakeInline_InvalidType\n- TestBaker_BakeInline_ExternalDependency\n- TestBaker_ConditionWithOnTimeout\n\n#### vars_test.go\n- TestVarContext_Get\n- TestVarContext_EmptyPath\n- TestVarContext_NestedOutputAccess\n- TestVarContext_AccessFieldOnNonMap\n- TestVarContext_SubstituteMap_Error\n- TestVarContext_SubstituteStep_* (validation, timeout, ontimeout, all error paths)\n- TestVarContext_MaxDepthRecursion\n- TestVarContext_NonStringOutput\n- TestVarContext_OutputAccessOnNonMap\n\n#### validate_test.go\n- TestValidateFull_InvalidMetaType\n- TestValidateFull_ValidMetaType\n- TestValidateFull_OnTimeoutVariables\n- TestValidationResult_NoErrors\n- TestValidationResult_Add\n- TestValidationError_NoLocation\n- TestValidateFull_VariableInOnTimeoutTemplate\n- TestValidateFull_StepTypeInvalid\n- TestValidateFull_EmptyStepID\n\n#### mvp_test.go (module tests)\n- TestModule_DefaultWorkflow\n- TestWorkflow_IsInternal\n- TestDetectFormat\n- TestParseModuleString_Errors\n- TestWorkflow_Validate_Errors\n- TestParseModuleString_StepMissingID\n- TestParseModuleString_AllStepFields\n- TestParseModuleString_WorkflowAllFields\n\n### Key Coverage Improvements\n- vars.go SubstituteStep: 62.8% -\u003e 100%\n- baker.go setTypeSpec: 59.0% -\u003e 89.7%\n- baker.go BakeWorkflow: 78.6% -\u003e 96.4%\n- module.go functions: 0% -\u003e covered","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:13:43.131626427-05:00","closed_at":"2026-01-08T01:13:43.131626427-05:00","close_reason":"Unit tests for template system - achieved 90.1% coverage (target: \u003e90%)","labels":["phase-2","testing","unit"],"dependencies":[{"issue_id":"meow-e11.3","depends_on_id":"meow-e11.1","type":"blocks","created_at":"2026-01-07T03:14:35.910711208-05:00","created_by":"ubuntu"},{"issue_id":"meow-e11.3","depends_on_id":"meow-e2","type":"blocks","created_at":"2026-01-07T03:14:35.999393122-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.4","title":"Unit tests for primitive handlers","description":"Unit tests for all 6 primitive handlers.","notes":"## Test Files\n- internal/primitive/task_test.go\n- internal/primitive/condition_test.go\n- internal/primitive/code_test.go\n- internal/primitive/expand_test.go\n- internal/primitive/start_test.go\n- internal/primitive/stop_test.go\n\n## Test Cases\n\n### Task Handler Tests\n- [ ] Waits for bead to close\n- [ ] Validates required outputs\n- [ ] Rejects invalid output types\n- [ ] Stores validated outputs\n- [ ] Handles agent death\n\n### Condition Handler Tests\n- [ ] Exit 0 expands on_true\n- [ ] Exit non-0 expands on_false\n- [ ] Timeout expands on_timeout\n- [ ] Runs in goroutine (non-blocking)\n- [ ] Cancellation works\n\n### Code Handler Tests\n- [ ] Executes shell command\n- [ ] Captures stdout to output\n- [ ] Captures stderr to output\n- [ ] Reads file to output\n- [ ] Handles on_error: continue\n- [ ] Handles on_error: abort\n- [ ] Handles on_error: retry\n\n### Expand Handler Tests\n- [ ] Loads template\n- [ ] Substitutes variables\n- [ ] Resolves output references\n- [ ] Creates child beads\n- [ ] Sets ephemeral labels\n- [ ] Wires dependencies\n\n### Start Handler Tests\n- [ ] Creates tmux session\n- [ ] Sets workdir from output reference\n- [ ] Fresh start works\n- [ ] Resume with session_id works\n- [ ] Injects meow prime\n\n### Stop Handler Tests\n- [ ] Graceful stop sends interrupt\n- [ ] Force kill after timeout\n- [ ] Works if session doesn't exist\n- [ ] Updates agent state\n\n## Acceptance Criteria\n- [ ] Each handler has \u003e90% coverage\n- [ ] All error conditions tested\n- [ ] Mock tmux used (no real sessions)\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:13:14.021481967-05:00","closed_at":"2026-01-08T01:13:14.021481967-05:00","close_reason":"Added 40+ unit tests for all 6 primitive handlers in orchestrator_test.go. Coverage increased from 67% to 75.4%. Tests cover: Task (wait for close, dead agent), Condition (true/false/timeout/goroutine/cancel), Code (stdout/stderr/on_error modes), Expand (template/variables/parent/inline steps), Start (session/workdir/resume/prompt), Stop (graceful/force). Also added ephemeral cleanup test.","labels":["phase-2","testing","unit"],"dependencies":[{"issue_id":"meow-e11.4","depends_on_id":"meow-e11.1","type":"blocks","created_at":"2026-01-07T03:14:36.089044935-05:00","created_by":"ubuntu"},{"issue_id":"meow-e11.4","depends_on_id":"meow-e4","type":"blocks","created_at":"2026-01-07T03:14:36.178016699-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.5","title":"Unit tests for output binding","description":"Unit tests for output capture, storage, and resolution.","notes":"## Test Files\n- internal/output/capture_test.go\n- internal/output/storage_test.go\n- internal/output/resolver_test.go\n- internal/output/validator_test.go\n\n## Test Cases\n\n### Output Capture Tests\n- [ ] Captures stdout (trimmed)\n- [ ] Captures stderr (trimmed)\n- [ ] Reads file contents\n- [ ] Handles missing file gracefully\n- [ ] Handles empty output\n\n### Output Storage Tests\n- [ ] Stores outputs on bead\n- [ ] Persists across save/load\n- [ ] Visible in bd show\n\n### Output Resolver Tests\n- [ ] Resolves {{bead.outputs.field}}\n- [ ] Errors on non-existent bead\n- [ ] Errors on unclosed bead\n- [ ] Errors on missing field\n- [ ] Suggests similar beads on typo\n\n### Output Validator Tests\n- [ ] string type validation\n- [ ] number type validation\n- [ ] boolean type validation\n- [ ] bead_id type validation (checks existence)\n- [ ] file_path type validation (checks existence)\n- [ ] string[] type validation\n- [ ] json type validation\n- [ ] Error messages include expected type\n\n## Acceptance Criteria\n- [ ] All output types have validation tests\n- [ ] Error messages are helpful\n- [ ] Edge cases covered (empty, null, unicode)\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["outputs","phase-2","testing","unit"],"dependencies":[{"issue_id":"meow-e11.5","depends_on_id":"meow-e11.1","type":"blocks","created_at":"2026-01-07T03:14:36.269736743-05:00","created_by":"ubuntu"},{"issue_id":"meow-e11.5","depends_on_id":"meow-e7","type":"blocks","created_at":"2026-01-07T03:14:36.359893174-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.6","title":"Integration tests for orchestrator","description":"Integration tests for orchestrator main loop and state management.","notes":"## Test Files\n- internal/orchestrator/integration_test.go\n\n## Test Scenarios\n\n### Basic Execution\n- [ ] Simple linear workflow (3 code beads)\n- [ ] Workflow with dependencies (diamond pattern)\n- [ ] Workflow completes when all beads closed\n\n### State Management\n- [ ] State persists across loop iterations\n- [ ] Crash recovery resumes from last state\n- [ ] Lock prevents concurrent orchestrators\n- [ ] Heartbeat updates regularly\n\n### Bead Transitions\n- [ ] open → in_progress → closed\n- [ ] Dependency blocking works\n- [ ] Ready detection is correct\n\n### Logging\n- [ ] All dispatch actions logged\n- [ ] Log includes bead_id, agent, type\n- [ ] Errors logged with context\n\n## Test Setup\n```go\nfunc TestOrchestrator_LinearWorkflow(t *testing.T) {\n    workspace := testutil.NewTestWorkspace(t)\n    defer workspace.Cleanup()\n\n    // Create test beads\n    beads := []types.Bead{\n        testutil.NewCodeBead(\"step1\", \"echo hello\"),\n        testutil.NewCodeBead(\"step2\", \"echo world\", \"step1\"),\n        testutil.NewCodeBead(\"step3\", \"echo done\", \"step2\"),\n    }\n\n    // Run orchestrator\n    orch := orchestrator.New(testutil.NewTestConfig(t))\n    err := orch.Run(context.Background(), beads)\n\n    require.NoError(t, err)\n    // Assert all beads closed\n}\n```\n\n## Acceptance Criteria\n- [ ] All scenarios pass\n- [ ] No real tmux sessions created\n- [ ] Tests run in \u003c5s\n- [ ] Parallel test execution works\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T02:17:42.136127008-05:00","closed_at":"2026-01-08T02:17:42.136127008-05:00","close_reason":"Completed: Added comprehensive integration tests for orchestrator in internal/orchestrator/integration_test.go. Tests cover: linear workflows (3 sequential beads), diamond dependency patterns, state persistence across iterations, crash recovery (dead agent beads reset, live agent beads preserved), lock conflict prevention, bead status transitions, dependency blocking, ready detection, logging verification, mixed bead types workflow, parallel test execution safety. All 19 integration tests pass in \u003c0.2s. No real tmux sessions created.","labels":["integration","phase-3","testing"],"dependencies":[{"issue_id":"meow-e11.6","depends_on_id":"meow-e11.2","type":"blocks","created_at":"2026-01-07T03:14:36.452558633-05:00","created_by":"ubuntu"},{"issue_id":"meow-e11.6","depends_on_id":"meow-e11.4","type":"blocks","created_at":"2026-01-07T03:14:36.547568478-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.7","title":"E2E tests with mock Claude","description":"End-to-end tests simulating real workflows with mock Claude.","notes":"## E2E Test Framework\n\n### Mock Claude Script\n```bash\n# test/mock_claude.sh\n#!/bin/bash\nset -e\n\nLOG_FILE=\"${MEOW_TEST_LOG:-/tmp/mock_claude.log}\"\n\nlog() {\n    echo \"[$(date -Iseconds)] $*\" \u003e\u003e \"$LOG_FILE\"\n}\n\nlog \"Mock Claude started with args: $*\"\n\n# Simulate Claude startup\nsleep 0.2\necho \"Claude Code ready\"\n\n# Wait for prompts\nwhile IFS= read -r line; do\n    log \"Received: $line\"\n\n    if [[ \"$line\" == *\"meow prime\"* ]]; then\n        log \"Executing meow prime\"\n        PRIME_OUTPUT=$(meow prime --format json 2\u003e/dev/null || echo '{}')\n        BEAD_ID=$(echo \"$PRIME_OUTPUT\" | jq -r '.bead_id // empty')\n\n        if [[ -n \"$BEAD_ID\" ]]; then\n            log \"Found bead: $BEAD_ID\"\n\n            # Check for required outputs\n            OUTPUTS=$(echo \"$PRIME_OUTPUT\" | jq -r '.required_outputs // []')\n            OUTPUT_ARGS=\"\"\n\n            if [[ \"$OUTPUTS\" != \"[]\" ]]; then\n                # Generate mock outputs\n                for output in $(echo \"$OUTPUTS\" | jq -r '.[].name'); do\n                    OUTPUT_ARGS=\"$OUTPUT_ARGS --output $output=mock_value\"\n                done\n            fi\n\n            # Close the bead\n            log \"Closing bead: meow close $BEAD_ID $OUTPUT_ARGS\"\n            meow close \"$BEAD_ID\" --notes \"Mock completed\" $OUTPUT_ARGS\n        fi\n    fi\ndone\n```\n\n### E2E Test Scenarios\n```\ntest/e2e/\n├── simple_workflow_test.go      # Linear code beads\n├── condition_branching_test.go  # on_true/on_false\n├── output_passing_test.go       # Code outputs to start\n├── task_outputs_test.go         # Claude provides outputs\n├── parent_child_test.go         # Call template\n├── crash_recovery_test.go       # Kill and resume\n├── human_gate_test.go           # meow approve flow\n└── ephemeral_cleanup_test.go    # Ephemeral bead cleanup\n```\n\n### Test Structure\n```go\nfunc TestE2E_ParentChildOrchestration(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"Skipping E2E test\")\n    }\n\n    workspace := testutil.NewTestWorkspace(t)\n    defer workspace.Cleanup()\n\n    // Setup mock Claude\n    mockClaude := testutil.NewMockClaude(t)\n    mockClaude.OnTask(\"select-task\", func(b *types.Bead) {\n        return map[string]string{\"work_bead\": \"bd-task-001\"}\n    })\n\n    // Run workflow\n    result := runE2EWorkflow(t, \"work-loop\", map[string]string{\n        \"agent\": \"claude-1\",\n    })\n\n    // Assertions\n    assert.True(t, result.Completed)\n    assert.Equal(t, 3, result.BeadsExecuted)\n    assertLogContains(t, \"Resuming parent\")\n}\n```\n\n## Acceptance Criteria - Infrastructure\n- [ ] Mock Claude script works reliably\n- [ ] Test fixtures create valid test data\n- [ ] Tests complete in \u003c30s each\n- [ ] Detailed logging for debugging failures\n- [ ] No real Claude API calls\n- [ ] Cleanup removes all temp files/sessions\n\n## Acceptance Criteria - Core Scenarios\nEach of these scenarios must pass:\n\n### Simple Workflow (simple_workflow_test.go)\n- [ ] Linear code beads execute in order\n- [ ] Dependencies are respected\n\n### Condition Branching (condition_branching_test.go)\n- [ ] on_true path works\n- [ ] on_false path works\n- [ ] Nested conditions work\n\n### Output Binding (output_passing_test.go)\n- [ ] Code bead captures stdout to output\n- [ ] Start bead uses output reference for workdir\n- [ ] Output values flow correctly between beads\n\n### Task Output Validation (task_outputs_test.go)\n- [ ] Missing required outputs are rejected\n- [ ] Invalid bead_id outputs are rejected with helpful error\n- [ ] Valid outputs are stored and accessible\n- [ ] Subsequent beads can read outputs via {{bead.outputs.field}}\n\n### Parent/Child Orchestration (parent_child_test.go)\n- [ ] call template spawns child correctly\n- [ ] Parent session is saved\n- [ ] Child completes work\n- [ ] Parent resumes with context\n\n### Crash Recovery (crash_recovery_test.go)\n- [ ] Kill orchestrator mid-workflow\n- [ ] State is persisted to disk\n- [ ] Restart resumes from last state\n- [ ] In-progress beads from dead agents reset\n- [ ] No duplicate work done\n\n### Human Gate (human_gate_test.go)\n- [ ] Blocking condition waits for approval\n- [ ] meow approve unblocks correctly\n- [ ] meow reject triggers on_false path\n\n### Ephemeral Cleanup (ephemeral_cleanup_test.go)\n- [ ] Ephemeral beads get correct label\n- [ ] meow clean --ephemeral removes closed ephemeral beads\n- [ ] Non-ephemeral beads are preserved\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["critical","e2e","testing"],"dependencies":[{"issue_id":"meow-e11.7","depends_on_id":"meow-e11.6","type":"blocks","created_at":"2026-01-07T03:14:36.639894591-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.8","title":"Stress tests and performance benchmarks","description":"Performance tests and benchmarks for critical paths.","notes":"## Benchmark Tests\n```\ninternal/benchmark/\n├── template_parse_bench_test.go\n├── bead_dispatch_bench_test.go\n├── output_resolution_bench_test.go\n└── state_persistence_bench_test.go\n```\n\n## Performance Requirements\n| Operation | Target | Max |\n|-----------|--------|-----|\n| Template parse | \u003c1ms | 5ms |\n| Variable substitution | \u003c100µs | 500µs |\n| Bead dispatch | \u003c10ms | 50ms |\n| State save | \u003c50ms | 200ms |\n| Output resolution | \u003c1ms | 5ms |\n\n## Stress Tests\n- [ ] 1000 beads in single workflow\n- [ ] 100 concurrent output references\n- [ ] 50 nested template expansions\n- [ ] Rapid bead state transitions\n\n## Memory Profiling\n- [ ] No memory leaks in long-running workflows\n- [ ] Memory usage stable over 1000 iterations\n\n## Acceptance Criteria\n- [ ] All benchmarks meet targets\n- [ ] No degradation over time\n- [ ] Results logged for CI tracking\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["performance","testing"],"dependencies":[{"issue_id":"meow-e11.8","depends_on_id":"meow-e11.6","type":"blocks","created_at":"2026-01-07T03:14:36.732282858-05:00","created_by":"ubuntu"}]}
{"id":"meow-e11.9","title":"Write user documentation","description":"Comprehensive user documentation for MEOW Stack.","notes":"## Documentation Structure\n```\ndocs/\n├── getting-started.md      # Quick start guide\n├── concepts.md             # Core concepts (primitives, templates, outputs)\n├── template-authoring.md   # How to write templates\n├── cli-reference.md        # All CLI commands\n├── output-binding.md       # Output capture and references\n├── troubleshooting.md      # Common issues and solutions\n└── examples/\n    ├── simple-workflow.md\n    ├── parent-child.md\n    └── human-gate.md\n```\n\n## Content Requirements\n- All 6 primitives documented with examples\n- Output binding explained with diagrams\n- Task outputs and validation explained\n- Ephemeral beads explained\n- Error codes and recovery\n\n## Acceptance Criteria\n- [ ] Getting started takes \u003c10 min\n- [ ] All CLI commands documented\n- [ ] Examples are copy-paste runnable\n- [ ] Troubleshooting covers common errors\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["docs"]}
{"id":"meow-e2","title":"Template System: Parser, variables, and baking","description":"Parse TOML templates, substitute variables, validate structure, and \"bake\"\ntemplates into beads.\n","notes":"## Why This Epic Matters\n\nTemplates are the \"programs\" in MEOW. They define workflows using the 6\nprimitives. This epic makes templates usable.\n\n## Key Components\n1. TOML parser with template-specific handling\n2. Variable substitution engine (including output references)\n3. Template validation\n4. Baking (template → beads)\n5. Output reference resolution ({{bead.outputs.field}})\n6. Ephemeral flag handling\n\n## Success Criteria\n- Can parse any valid MEOW template\n- Variable substitution works with nesting\n- Output references ({{bead.outputs.field}}) resolve correctly\n- Ephemeral templates get proper labeling\n- Validation catches common errors\n- Baking creates correct beads with dependencies\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T05:09:35.376547788-05:00","closed_at":"2026-01-07T05:09:35.376547788-05:00","close_reason":"Template system complete: TOML parser (ParseFile, ParseString), variable substitution with nesting/output refs, template validation (cycles, deps, types), baker (template to beads), loader (multi-source with priority). All tests pass.","labels":["epic","phase-1","templates"],"dependencies":[{"issue_id":"meow-e2","depends_on_id":"meow-e1","type":"blocks","created_at":"2026-01-07T03:14:30.411886337-05:00","created_by":"ubuntu"}]}
{"id":"meow-e2.1","title":"Implement TOML template parser","description":"Parse MEOW template files from TOML format.","notes":"## Template Structure\n- [meta] section: name, version, description, etc.\n- [variables] section: variable definitions with types/defaults\n- [[steps]] array: workflow steps\n\n## Go Types\n- Template struct\n- TemplateMeta struct\n- VariableDef struct\n- TemplateStep struct\n- ExpansionTarget struct (for on_true/on_false)\n\n## Acceptance Criteria\n- [ ] Parse valid template without error\n- [ ] Return helpful error for invalid TOML\n- [ ] Handle all step types correctly\n- [ ] Support inline and template expansion targets\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T04:22:56.486778599-05:00","closed_at":"2026-01-07T04:22:56.486778599-05:00","close_reason":"Closed","labels":["parser","templates"],"dependencies":[{"issue_id":"meow-e2.1","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:30.502169754-05:00","created_by":"ubuntu"}]}
{"id":"meow-e2.2","title":"Implement variable substitution engine","description":"Implement {{variable}} substitution throughout templates.","notes":"## Substitution Types\n- Basic: {{task_id}} → value\n- Nested: {{output.step.field}} → nested value\n- **Output references: {{bead_id.outputs.field}} → captured output**\n- Builtins: {{agent}}, {{bead_id}}, {{timestamp}}, etc.\n\n## Output Reference Resolution\nWhen a template references {{some_bead.outputs.field}}:\n1. Find bead with matching ID in same workflow\n2. Look up outputs.field from bead's stored outputs\n3. Substitute the value\n\nThis enables dynamic data flow:\n- code bead captures stdout → subsequent bead uses it\n- task bead validates output → expand bead uses it\n\n## Edge Cases\n- Unset required variable → error\n- Unset optional with default → use default\n- Recursive substitution → detect and error\n- Missing output reference → error with helpful message\n\n## Acceptance Criteria\n- [ ] Basic {{var}} substitution works\n- [ ] Nested {{a.b.c}} access works\n- [ ] **Output references {{bead.outputs.field}} resolve correctly**\n- [ ] Built-in variables populated\n- [ ] Missing required variable errors clearly\n- [ ] Missing output reference errors with bead context\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T04:25:06.053744192-05:00","closed_at":"2026-01-07T04:25:06.053744192-05:00","close_reason":"Closed","labels":["templates","variables"],"dependencies":[{"issue_id":"meow-e2.2","depends_on_id":"meow-e2.1","type":"blocks","created_at":"2026-01-07T03:14:30.591582666-05:00","created_by":"ubuntu"}]}
{"id":"meow-e2.3","title":"Implement template validation","description":"Validate templates for correctness before baking.","notes":"## Validations\n- Structure: meta.name required, unique step IDs, valid types\n- Dependencies: needs references exist, no cycles, all reachable\n- Variables: all {{var}} references defined\n- Type-specific: condition has on_true/on_false, expand has template, etc.\n\n## Error Messages\nShould include:\n- Template name and step ID\n- What's wrong\n- Suggestions (\"did you mean X?\")\n\n## Acceptance Criteria\n- [ ] Catches missing required fields\n- [ ] Detects circular dependencies\n- [ ] Suggests corrections for typos\n- [ ] Returns all errors, not just first\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T04:27:42.235649522-05:00","closed_at":"2026-01-07T04:27:42.235649522-05:00","close_reason":"Closed","labels":["templates","validation"],"dependencies":[{"issue_id":"meow-e2.3","depends_on_id":"meow-e2.1","type":"blocks","created_at":"2026-01-07T03:14:30.678684394-05:00","created_by":"ubuntu"}]}
{"id":"meow-e2.4","title":"Implement template baking (template → beads)","description":"Transform a parsed, validated template into executable beads.","notes":"## Baking Process\n1. Load template\n2. Validate\n3. Substitute variables\n4. Generate bead IDs for each step\n5. Translate needs from step IDs to bead IDs\n6. Create beads\n\n## ID Generation\nFormat: {workflow_id}.{step_id}-{hash}\nExample: meow-run-001.load-context-a3f8\n\n## Handling Nested Structures\n- expand steps create placeholder beads (runtime expansion)\n- inline steps in conditions get baked immediately\n\n## Acceptance Criteria\n- [ ] Simple template bakes to correct beads\n- [ ] Dependencies translate correctly\n- [ ] Inline steps become child beads\n- [ ] Bead IDs are unique and traceable\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T04:30:15.770845963-05:00","closed_at":"2026-01-07T04:30:15.770845963-05:00","close_reason":"Closed","labels":["baking","templates"],"dependencies":[{"issue_id":"meow-e2.4","depends_on_id":"meow-e2.2","type":"blocks","created_at":"2026-01-07T03:14:30.78982717-05:00","created_by":"ubuntu"},{"issue_id":"meow-e2.4","depends_on_id":"meow-e2.3","type":"blocks","created_at":"2026-01-07T03:14:30.882377165-05:00","created_by":"ubuntu"}]}
{"id":"meow-e2.5","title":"Implement template loading from filesystem and embedded","description":"Load templates from multiple sources with precedence.","notes":"## Load Order\n1. Project: .meow/templates/{name}.toml\n2. User: ~/.config/meow/templates/{name}.toml\n3. Embedded: Built into binary\n\n## Embedded Templates\nUse Go embed directive:\n```go\n//go:embed templates/*.toml\nvar embeddedTemplates embed.FS\n```\n\n## Acceptance Criteria\n- [ ] Embedded templates load correctly\n- [ ] Project templates override embedded\n- [ ] Helpful error when template not found\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:09:11.349713229-05:00","closed_at":"2026-01-07T05:09:11.349713229-05:00","close_reason":"Template loading implemented: Loader with priority (project \u003e user \u003e embedded), Load() search with TemplateNotFoundError, List() for all available templates, support for embed.FS, comprehensive test coverage","labels":["loading","templates"],"dependencies":[{"issue_id":"meow-e2.5","depends_on_id":"meow-e2.1","type":"blocks","created_at":"2026-01-07T03:14:30.970749274-05:00","created_by":"ubuntu"}]}
{"id":"meow-e3","title":"Orchestrator Core: Main loop and state management","description":"The heart of MEOW. Main loop, bead readiness detection, state management,\nand recovery.\n","notes":"## Design Philosophy\n\u003e \"The orchestrator is dumb; the templates are smart.\"\n\nThe orchestrator knows ONLY the 6 primitives. Everything else—loops,\ngates, refresh, checkpoint/resume—is template composition.\n\n## Success Criteria\n- Main loop runs continuously\n- Correctly identifies ready beads\n- Dispatches to appropriate handlers (6 types)\n- Captures and stores outputs from code beads\n- Validates and stores outputs from task beads\n- Persists state for recovery\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T05:12:35.781453383-05:00","closed_at":"2026-01-07T05:12:35.781453383-05:00","close_reason":"Orchestrator core complete: main loop, bead readiness (BeadStore.GetNextReady), dispatch to all 6 handlers (task/condition/stop/start/code/expand), state persistence (StatePersister), crash recovery (StartOrResume), execution tracing. Tests pass.","labels":["epic","orchestrator","phase-1"],"dependencies":[{"issue_id":"meow-e3","depends_on_id":"meow-e1","type":"blocks","created_at":"2026-01-07T03:14:31.059165616-05:00","created_by":"ubuntu"},{"issue_id":"meow-e3","depends_on_id":"meow-e2","type":"blocks","created_at":"2026-01-07T03:14:31.149251566-05:00","created_by":"ubuntu"}]}
{"id":"meow-e3.1","title":"Implement orchestrator main loop","description":"Implement the core orchestrator loop.","notes":"## Loop Structure\n```go\nfor {\n    bead := getNextReadyBead()\n    if bead == nil {\n        if allDone() { return nil }\n        sleep and continue\n    }\n    dispatch(bead)\n    updateHeartbeat()\n}\n```\n\n## Dispatch by Type (6 primitives)\n```go\nswitch bead.Type {\ncase \"task\":      waitForClaudeToClose(bead)\ncase \"condition\": evalAndExpand(bead)  // may block!\ncase \"stop\":      killAgent(bead)\ncase \"start\":     spawnAgent(bead)  // handles resume_session\ncase \"code\":      execShell(bead)   // captures outputs\ncase \"expand\":    expandTemplate(bead)\n}\n```\n\n## Concurrency\nConditions run in goroutines to avoid blocking main loop.\n\n## Acceptance Criteria\n- [ ] Loop runs until no ready beads\n- [ ] Dispatches correctly to all 6 handlers\n- [ ] Conditions don't block main loop\n- [ ] Graceful shutdown on context cancel\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:30:08.194657253-05:00","closed_at":"2026-01-07T03:30:08.194657253-05:00","close_reason":"Orchestrator main loop with dispatch to all 6 primitives, condition concurrency, graceful shutdown","labels":["main-loop","orchestrator"],"dependencies":[{"issue_id":"meow-e3.1","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:31.236169907-05:00","created_by":"ubuntu"}]}
{"id":"meow-e3.2","title":"Implement bead readiness detection","description":"Determine which beads are ready for execution.","notes":"## Readiness Rules\nA bead is ready when:\n1. Status is `open`\n2. All beads in `needs` are `closed`\n3. Not already being processed\n\n## Priority Ordering\n1. Orchestrator beads first (condition, expand, code, stop, etc.)\n2. Then task beads\n3. Within type: earlier creation time\n\n## Change Detection\nWatch .beads/issues.jsonl for changes rather than polling.\n\n## Acceptance Criteria\n- [ ] Correctly identifies ready beads\n- [ ] Dependencies checked correctly\n- [ ] Priority ordering correct\n- [ ] File watching triggers re-check\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:32:27.47575877-05:00","closed_at":"2026-01-07T03:32:27.47575877-05:00","close_reason":"FileBeadStore with readiness detection, dependency checking, priority ordering","labels":["orchestrator","readiness"],"dependencies":[{"issue_id":"meow-e3.2","depends_on_id":"meow-e3.1","type":"blocks","created_at":"2026-01-07T03:14:31.32470772-05:00","created_by":"ubuntu"}]}
{"id":"meow-e3.3","title":"Implement orchestrator state persistence","description":"Persist orchestrator state for crash recovery.","notes":"## State Files\n- .meow/state/orchestrator.json - workflow state\n- .meow/agents.json - agent states\n- .meow/state/heartbeat.json - health check\n- .meow/state/orchestrator.lock - prevent concurrent\n\n## Atomic Writes\nWrite to temp file, then rename.\n\n## Lock File\nPrevent concurrent orchestrators via exclusive lock.\n\n## Acceptance Criteria\n- [ ] State persists across iterations\n- [ ] Atomic writes prevent corruption\n- [ ] Lock prevents concurrent instances\n- [ ] Stale lock detection works\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:33:59.374313708-05:00","closed_at":"2026-01-07T03:33:59.374313708-05:00","close_reason":"StatePersister with atomic writes, lock file, heartbeat, and crash detection","labels":["orchestrator","state"],"dependencies":[{"issue_id":"meow-e3.3","depends_on_id":"meow-e3.1","type":"blocks","created_at":"2026-01-07T03:14:31.416863508-05:00","created_by":"ubuntu"}]}
{"id":"meow-e3.4","title":"Implement orchestrator startup and crash recovery","description":"Handle orchestrator startup, including recovery from crashes.","notes":"## Startup Flow\n1. Acquire lock\n2. Check for existing state\n3. If exists: resume flow\n4. If not: fresh start flow\n\n## Recovery Flow\n1. Load orchestrator state\n2. Load agent states\n3. Reconcile with reality (check tmux sessions)\n4. Reset in-progress beads from dead agents\n5. Resume main loop\n\n## Acceptance Criteria\n- [ ] Fresh start creates beads and spawns agent\n- [ ] Resume loads existing state\n- [ ] Dead agents detected via tmux\n- [ ] In-progress beads from dead agents reset\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T04:53:57.888201817-05:00","closed_at":"2026-01-07T04:53:57.888201817-05:00","close_reason":"Implemented orchestrator startup and crash recovery with StartOrResume method, lock acquisition, fresh start flow, resume flow, and crash recovery (detects dead agents, resets orphaned beads). Added 7 comprehensive tests.","labels":["orchestrator","recovery"],"dependencies":[{"issue_id":"meow-e3.4","depends_on_id":"meow-e3.3","type":"blocks","created_at":"2026-01-07T03:14:31.504407164-05:00","created_by":"ubuntu"}]}
{"id":"meow-e3.5","title":"Implement execution trace logging","description":"Log all orchestrator actions for debugging and audit.","notes":"## Trace Format\nJSONL in .meow/state/trace.jsonl\nEach entry: timestamp, action, details\n\n## Actions to Log\n- start, bake, spawn, dispatch, condition_eval, expand, close\n\n## CLI Access\n`meow trace [--follow] [--json] [--since 1h]`\n\n## Acceptance Criteria\n- [ ] All dispatch actions logged\n- [ ] Trace survives crash\n- [ ] meow trace command works\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:11:51.573905298-05:00","closed_at":"2026-01-07T05:11:51.573905298-05:00","close_reason":"Execution trace logging implemented: Tracer with JSONL output, all action types (start/resume/bake/spawn/dispatch/condition_eval/expand/close/stop/shutdown/error), NullTracer for testing, comprehensive test coverage","labels":["logging","orchestrator"],"dependencies":[{"issue_id":"meow-e3.5","depends_on_id":"meow-e3.1","type":"blocks","created_at":"2026-01-07T03:14:31.594932116-05:00","created_by":"ubuntu"}]}
{"id":"meow-e3.6","title":"Implement graceful orchestrator shutdown","description":"Handle SIGTERM/SIGINT gracefully to prevent state corruption.","notes":"## Why This Task\nOrchestrator can be killed (Ctrl+C, systemd stop, etc.). Without graceful\nshutdown, we risk:\n- Corrupted state files (mid-write)\n- Orphaned tmux sessions\n- In-progress beads stuck forever\n\n## Shutdown Flow\n1. Receive SIGTERM or SIGINT\n2. Cancel main loop context\n3. Save orchestrator state immediately\n4. For each active agent:\n   - Send graceful stop (Ctrl+C to tmux)\n   - Wait up to grace_period (configurable, default 10s)\n   - Force kill if still running\n5. Update agent states to \"stopped\"\n6. Release lock file\n7. Exit cleanly\n\n## Implementation\n```go\nfunc (o *Orchestrator) setupSignalHandling(ctx context.Context) context.Context {\n    ctx, cancel := context.WithCancel(ctx)\n\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)\n\n    go func() {\n        sig := \u003c-sigChan\n        o.logger.Info(\"Received signal, shutting down gracefully\",\n            \"signal\", sig)\n\n        // Save state first\n        if err := o.saveState(); err != nil {\n            o.logger.Error(\"Failed to save state during shutdown\", \"error\", err)\n        }\n\n        // Stop all agents\n        for _, agent := range o.agentStore.ListByStatus(AgentActive) {\n            o.stopAgentGracefully(agent, o.cfg.StopGracePeriod)\n        }\n\n        // Release lock\n        o.lock.Release()\n\n        cancel()\n    }()\n\n    return ctx\n}\n```\n\n## Config\n```toml\n[orchestrator]\nstop_grace_period = 10  # seconds to wait for agent cleanup\n```\n\n## Acceptance Criteria\n- [ ] SIGTERM triggers graceful shutdown\n- [ ] SIGINT (Ctrl+C) triggers graceful shutdown\n- [ ] State is saved before agent cleanup\n- [ ] Active agents receive stop signal\n- [ ] Lock file is released\n- [ ] Exit code is 0 for clean shutdown\n- [ ] Integration test: kill -TERM during execution\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["orchestrator","reliability","shutdown"],"dependencies":[{"issue_id":"meow-e3.6","depends_on_id":"meow-e3.4","type":"blocks","created_at":"2026-01-07T03:14:31.684651471-05:00","created_by":"ubuntu"},{"issue_id":"meow-e3.6","depends_on_id":"meow-e5.3","type":"blocks","created_at":"2026-01-07T03:14:31.770870614-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4","title":"Primitive Handlers: All 6 primitive implementations","description":"Implement the handlers for all 6 primitive bead types.\n","notes":"## The 6 Primitives\n1. task - Wait for Claude to close (with output validation)\n2. condition - Evaluate shell, expand on_true/on_false\n3. stop - Kill tmux session\n4. start - Spawn tmux session (with optional resume_session)\n5. code - Execute shell script (with output capture)\n6. expand - Load and bake template (with ephemeral support)\n\n## Why 6 Instead of 8?\ncheckpoint and resume are now composed from code + start:\n- checkpoint → code bead with `meow session-id`\n- resume → start bead with `resume_session` parameter\n\n## Success Criteria\n- All 6 primitives have working handlers\n- Code beads capture and store outputs\n- Task beads validate required outputs\n- Start beads handle resume_session\n- Handlers are isolated and testable\n- Error handling is consistent\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T05:28:31.737025067-05:00","closed_at":"2026-01-07T05:28:31.737025067-05:00","close_reason":"All 6 primitive handlers completed with retry logic, timeout handling, ephemeral cleanup, and tmux agent manager","labels":["epic","phase-2","primitives"],"dependencies":[{"issue_id":"meow-e4","depends_on_id":"meow-e3","type":"blocks","created_at":"2026-01-07T03:14:31.85942527-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4.1","title":"Implement task primitive handler","description":"Handle task beads by waiting for Claude to close them with validated outputs.","notes":"## Behavior\n1. Verify assigned agent is running\n2. Mark bead in_progress\n3. Wait for bead status to become closed\n4. **Validate outputs if task has required outputs**\n5. Store validated outputs on bead\n6. Return (main loop finds next bead)\n\n## Task Outputs\nTasks can declare required/optional outputs:\n```yaml\noutputs:\n  required:\n    - name: \"work_bead\"\n      type: \"bead_id\"\n  optional:\n    - name: \"notes\"\n      type: \"string\"\n```\n\nClaude closes with: `meow close \u003cbead\u003e --output work_bead=bd-123`\n\n## Output Types\n- string, string[], number, boolean, json\n- bead_id (validated against .beads/)\n- file_path (validated file exists)\n\n## Agent runs `meow close` when done\n\n## Acceptance Criteria\n- [ ] Waits for agent to close bead\n- [ ] Marks bead in_progress\n- [ ] **Validates required outputs before accepting close**\n- [ ] **Stores outputs on bead for subsequent references**\n- [ ] Returns validation errors if outputs missing/invalid\n- [ ] Returns when bead is closed with valid outputs\n- [ ] Handles agent death gracefully\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:28:26.533955496-05:00","closed_at":"2026-01-07T05:28:26.533955496-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["primitives","task"],"dependencies":[{"issue_id":"meow-e4.1","depends_on_id":"meow-e3.2","type":"blocks","created_at":"2026-01-07T03:14:31.947185006-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4.2","title":"Implement condition primitive handler","description":"Handle condition beads by evaluating shell and expanding results.","notes":"## Behavior\n1. Mark in_progress\n2. Execute shell command (in goroutine - may block!)\n3. Based on exit code, expand on_true or on_false\n4. Close bead\n\n## Key Insight\nConditions can block indefinitely - human gates, CI waits, etc.\n\n## Acceptance Criteria\n- [ ] Shell command executes\n- [ ] Exit 0 → on_true\n- [ ] Exit ≠0 → on_false\n- [ ] Timeout → on_timeout\n- [ ] Bead auto-closes\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:28:26.541679877-05:00","closed_at":"2026-01-07T05:28:26.541679877-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["condition","primitives"],"dependencies":[{"issue_id":"meow-e4.2","depends_on_id":"meow-e3.2","type":"blocks","created_at":"2026-01-07T03:14:32.037137586-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4.3","title":"Implement code primitive handler","description":"Handle code beads by executing shell scripts with output capture.","notes":"## Behavior\n1. Execute code in shell\n2. Capture stdout/stderr\n3. **If outputs defined: capture specified outputs**\n4. **Store outputs on bead for subsequent references**\n5. Handle errors based on on_error policy\n6. Close bead\n\n## Output Capture\n```yaml\noutputs:\n  path: stdout           # Capture stdout\n  error_log: stderr      # Capture stderr\n  sha: file:/tmp/sha.txt # Read from file\n  result: exit_code      # Exit code as string\n```\n\nOutputs become available as {{bead_id.outputs.field}}\n\n## Example: Worktree creation\n```yaml\ntype: code\ncode: |\n  git worktree add -b meow/worker ~/worktrees/worker HEAD\n  echo \"~/worktrees/worker\"\noutputs:\n  path: stdout\n```\n\nNext bead uses: `workdir = \"{{create-worktree.outputs.path}}\"`\n\n## on_error Options\n- continue: log and continue\n- abort: stop workflow\n- retry: retry up to max_retries\n\n## Acceptance Criteria\n- [ ] Shell script executes\n- [ ] Working directory set correctly\n- [ ] Environment variables passed\n- [ ] **stdout captured when outputs.X = stdout**\n- [ ] **File contents captured when outputs.X = file:/path**\n- [ ] **Outputs stored on bead for reference**\n- [ ] on_error policies work\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:28:26.543260019-05:00","closed_at":"2026-01-07T05:28:26.543260019-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["code","primitives"],"dependencies":[{"issue_id":"meow-e4.3","depends_on_id":"meow-e3.2","type":"blocks","created_at":"2026-01-07T03:14:32.129174786-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4.4","title":"Implement expand primitive handler","description":"Handle expand beads by loading and baking templates with ephemeral support.","notes":"## Behavior\n1. Load referenced template\n2. Merge variables (including output references)\n3. Bake template into child beads\n4. **If ephemeral: true, label beads with meow:ephemeral**\n5. Wire dependencies\n6. Set assignee on children\n7. Close expand bead\n\n## Ephemeral Beads\nWhen `ephemeral: true` on expand or in template meta:\n- Child beads get `labels: [\"meow:ephemeral\"]`\n- They execute normally\n- After completion, can be auto-cleaned\n- Hidden in `bd list` by default\n\n## Example\n```yaml\ntype: expand\ntemplate: \"call-implement\"\nephemeral: true  # Machinery beads, not work beads\nvariables:\n  work_bead: \"{{select-task.outputs.work_bead}}\"\n```\n\n## Recursive Expansion\nChild expand beads get processed in later iterations.\n\n## Acceptance Criteria\n- [ ] Template loads correctly\n- [ ] Variables merge correctly (including output refs)\n- [ ] Child beads created\n- [ ] **Ephemeral flag propagates to labels**\n- [ ] Recursive expansion works\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:28:26.544767463-05:00","closed_at":"2026-01-07T05:28:26.544767463-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["expand","primitives"],"dependencies":[{"issue_id":"meow-e4.4","depends_on_id":"meow-e2.4","type":"blocks","created_at":"2026-01-07T03:14:32.218015448-05:00","created_by":"ubuntu"},{"issue_id":"meow-e4.4","depends_on_id":"meow-e3.2","type":"blocks","created_at":"2026-01-07T03:14:32.307659156-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4.5","title":"Implement stop primitive handler","description":"Handle stop beads by killing agent tmux sessions.","notes":"## Behavior\n1. If graceful: send interrupt, wait, then force kill\n2. Kill tmux session\n3. Update agent state to stopped\n4. Close bead\n\n## Acceptance Criteria\n- [ ] Graceful stop sends interrupt first\n- [ ] Force kill after timeout\n- [ ] Agent state updated\n- [ ] Works if agent not running\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:28:26.546293648-05:00","closed_at":"2026-01-07T05:28:26.546293648-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["primitives","stop"],"dependencies":[{"issue_id":"meow-e4.5","depends_on_id":"meow-e5.1","type":"blocks","created_at":"2026-01-07T03:14:32.396395228-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4.6","title":"Implement start primitive handler","description":"Handle start beads by spawning agents in tmux with optional resume.","notes":"## Behavior\n1. Create tmux session\n2. Set working directory (can be from prior bead output)\n3. Set environment\n4. **If resume_session: start Claude with --resume**\n5. Otherwise: start Claude fresh\n6. Wait for ready\n7. Inject meow prime\n8. Update agent state\n9. Close bead\n\n## Resume Support (replaces old resume primitive)\n```yaml\ntype: start\nagent: \"claude-1\"\nresume_session: \"{{save-session.outputs.session_id}}\"\nworkdir: \".\"\n```\n\nThis composes checkpoint/resume:\n- code bead saves session ID\n- start bead uses it to resume\n\n## Fresh Start\n```yaml\ntype: start\nagent: \"claude-2\"\nworkdir: \"{{setup-worktree.outputs.path}}\"\n```\n\n## Acceptance Criteria\n- [ ] Creates tmux session\n- [ ] Sets workdir (including from output references)\n- [ ] **Starts Claude with --resume when resume_session set**\n- [ ] Starts Claude fresh when no resume_session\n- [ ] Detects when ready\n- [ ] Injects meow prime\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:28:26.547932793-05:00","closed_at":"2026-01-07T05:28:26.547932793-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["primitives","start"],"dependencies":[{"issue_id":"meow-e4.6","depends_on_id":"meow-e5.1","type":"blocks","created_at":"2026-01-07T03:14:32.486939134-05:00","created_by":"ubuntu"}]}
{"id":"meow-e4.7","title":"Implement ephemeral bead cleanup","description":"Clean up ephemeral beads after template completion.","notes":"## Behavior\nWhen a template with ephemeral beads completes:\n1. Detect all beads with `meow:ephemeral` label\n2. Based on cleanup config, either:\n   - on_complete: auto-delete closed ephemeral beads\n   - manual: wait for `meow clean --ephemeral`\n   - never: keep for debugging\n\n## Why Ephemeral Beads?\nTemplate steps like \"load-context\", \"write-tests\" are operational\nmachinery, not work items. Cleaning them keeps bead history focused\non actual deliverables.\n\n## Config\n```toml\n[cleanup]\nephemeral = \"on_complete\"  # or \"manual\" or \"never\"\n```\n\n## Acceptance Criteria\n- [ ] Detects ephemeral beads by label\n- [ ] Respects cleanup config\n- [ ] Cleans only closed ephemeral beads\n- [ ] `meow clean --ephemeral` works for manual mode\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T05:28:26.549486684-05:00","closed_at":"2026-01-07T05:28:26.549486684-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["ephemeral","primitives"],"dependencies":[{"issue_id":"meow-e4.7","depends_on_id":"meow-e4.4","type":"blocks","created_at":"2026-01-07T03:14:32.575443146-05:00","created_by":"ubuntu"},{"issue_id":"meow-e4.7","depends_on_id":"meow-e1.5","type":"blocks","created_at":"2026-01-07T03:14:32.665093943-05:00","created_by":"ubuntu"}]}
{"id":"meow-e5","title":"Agent Management: tmux and lifecycle","description":"Manage agent lifecycle via tmux.","notes":"## Success Criteria\n- Can create/kill tmux sessions\n- Can send commands to sessions\n- Can detect if sessions are alive\n- Agent state reflects reality\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T05:28:26.550970968-05:00","closed_at":"2026-01-07T05:28:26.550970968-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["agents","epic","phase-2"],"dependencies":[{"issue_id":"meow-e5","depends_on_id":"meow-e3","type":"blocks","created_at":"2026-01-07T03:14:32.754467801-05:00","created_by":"ubuntu"}]}
{"id":"meow-e5.0","title":"Validate tmux availability and version","description":"Check tmux is installed and meets version requirements at startup.","notes":"## Why This Task\nMEOW relies heavily on tmux for agent session management. If tmux is missing\nor too old, users will get confusing errors deep in execution.\n\n## Validation Rules\n- tmux must be in PATH\n- Version \u003e= 3.0 (required for -c workdir flag)\n- Provide clear, actionable error if validation fails\n\n## Implementation\n```go\nfunc ValidateTmux() error {\n    // Check existence\n    path, err := exec.LookPath(\"tmux\")\n    if err != nil {\n        return \u0026MeowError{\n            Code:    \"AGENT_003\",\n            Message: \"tmux not found in PATH\",\n            Details: map[string]any{\n                \"hint\": \"Install tmux: apt install tmux / brew install tmux\",\n            },\n        }\n    }\n\n    // Check version\n    out, _ := exec.Command(\"tmux\", \"-V\").Output()\n    version := parseTmuxVersion(string(out)) // e.g., \"tmux 3.3a\" -\u003e 3.3\n    if version \u003c 3.0 {\n        return \u0026MeowError{\n            Code:    \"AGENT_004\",\n            Message: fmt.Sprintf(\"tmux version %v too old (need \u003e= 3.0)\", version),\n            Details: map[string]any{\n                \"current\": version,\n                \"required\": 3.0,\n                \"hint\": \"Upgrade tmux to 3.0 or later\",\n            },\n        }\n    }\n\n    return nil\n}\n```\n\n## Call Site\nCalled at orchestrator startup, before any agent operations.\n\n## Acceptance Criteria\n- [ ] Detects missing tmux with helpful message\n- [ ] Detects old tmux version with upgrade instructions\n- [ ] Returns nil for valid tmux installation\n- [ ] Unit test with mock exec\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:05:13.992299528-05:00","closed_at":"2026-01-08T01:05:13.992299528-05:00","close_reason":"Implemented ValidateTmux() with AGENT_005/AGENT_006 error codes, version parsing, and comprehensive unit tests with mock exec","labels":["agents","prerequisite","validation"],"dependencies":[{"issue_id":"meow-e5.0","depends_on_id":"meow-e1.7","type":"blocks","created_at":"2026-01-07T03:14:32.843733014-05:00","created_by":"ubuntu"}]}
{"id":"meow-e5.1","title":"Implement tmux wrapper library","description":"Create a Go wrapper around tmux commands.","notes":"## Interface\n- NewSession, KillSession, SessionExists, ListSessions\n- SendKeys, SendKeysLiteral\n- CapturePane, SetEnv\n\n## Acceptance Criteria\n- [ ] Create session in directory\n- [ ] Kill session cleanly\n- [ ] Check if session exists\n- [ ] Send text to session\n- [ ] Capture pane output\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:20:32.782389302-05:00","closed_at":"2026-01-08T01:20:32.782389302-05:00","close_reason":"Completed: Implemented TmuxWrapper library with NewSession, KillSession, SessionExists, ListSessions, SendKeys, SendKeysLiteral, CapturePane, SetEnv. Refactored TmuxManager to use wrapper.","labels":["agents","tmux"],"dependencies":[{"issue_id":"meow-e5.1","depends_on_id":"meow-e5.0","type":"blocks","created_at":"2026-01-07T03:14:32.933515295-05:00","created_by":"ubuntu"},{"issue_id":"meow-e5.1","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:33.016869185-05:00","created_by":"ubuntu"}]}
{"id":"meow-e5.2","title":"Implement agent state storage","description":"Manage persistent agent state.","notes":"## Storage\n.meow/agents.json with agent records\n\n## Interface\nGet, Set, Update, Delete, List, ListByStatus\nLoad, Save\n\n## Acceptance Criteria\n- [ ] Persist agent state to disk\n- [ ] Atomic writes for safety\n- [ ] Thread-safe access\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:05:17.73908867-05:00","closed_at":"2026-01-08T01:05:17.73908867-05:00","close_reason":"Implemented AgentStore with Get/Set/Update/Delete/List/ListByStatus operations, atomic file writes to .meow/agents.json, and comprehensive unit tests","labels":["agents","state"],"dependencies":[{"issue_id":"meow-e5.2","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:33.111754683-05:00","created_by":"ubuntu"}]}
{"id":"meow-e5.3","title":"Implement agent spawning logic","description":"Higher-level agent spawning that coordinates tmux and state.","notes":"## Spawn Flow\n1. Check if agent already exists\n2. Create tmux session\n3. Configure environment\n4. Start Claude\n5. Wait for ready\n6. Inject initial prompt\n7. Update agent state\n\n## Acceptance Criteria\n- [ ] Creates complete agent setup\n- [ ] Handles existing agent\n- [ ] Cleans up on failure\n- [ ] Updates state correctly\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:43:58.684806843-05:00","closed_at":"2026-01-08T01:43:58.684806843-05:00","close_reason":"Implemented Spawner struct that coordinates TmuxWrapper and Store for agent lifecycle management. Includes spawn, despawn, sync, and cleanup on error.","labels":["agents","spawn"],"dependencies":[{"issue_id":"meow-e5.3","depends_on_id":"meow-e5.1","type":"blocks","created_at":"2026-01-07T03:14:33.199682711-05:00","created_by":"ubuntu"},{"issue_id":"meow-e5.3","depends_on_id":"meow-e5.2","type":"blocks","created_at":"2026-01-07T03:14:33.290518593-05:00","created_by":"ubuntu"}]}
{"id":"meow-e5.4","title":"Implement agent health monitoring","description":"Monitor agent health and detect crashes/stuck agents.","notes":"## Health Checks\n- Session exists (tmux has-session)\n- Activity check (recent progress)\n- Stuck detection (same bead too long)\n\n## Acceptance Criteria\n- [ ] Detects crashed sessions\n- [ ] Detects stuck agents\n- [ ] Updates state on crash\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["agents","monitoring"],"dependencies":[{"issue_id":"meow-e5.4","depends_on_id":"meow-e5.3","type":"blocks","created_at":"2026-01-07T03:14:33.385427189-05:00","created_by":"ubuntu"}]}
{"id":"meow-e6","title":"Condition System: Blocking, timeouts, and gates","description":"Deep implementation of blocking conditions.","notes":"## Key Feature\nConditions can block indefinitely - this enables human gates, CI waits, etc.\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T03:12:48.457391798-05:00","labels":["conditions","epic","phase-3"],"dependencies":[{"issue_id":"meow-e6","depends_on_id":"meow-e4","type":"blocks","created_at":"2026-01-07T03:14:33.482137985-05:00","created_by":"ubuntu"}]}
{"id":"meow-e6.1","title":"Implement blocking shell execution with cancellation","description":"Shell commands that block indefinitely with cancellation support.","notes":"Must support cancellation via context.\nRun in goroutines to not block main loop.\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T04:38:59.239318032-05:00","closed_at":"2026-01-07T04:38:59.239318032-05:00","close_reason":"Implemented ShellExecutor in internal/executor/shell.go with:\n- Context cancellation support (SIGTERM then SIGKILL)\n- Process group handling for killing child processes\n- Output capture: stdout, stderr, exit_code, file\n- Working directory and environment variable support\n- 16 passing unit tests","labels":["blocking","conditions"]}
{"id":"meow-e6.2","title":"Implement condition timeout handling","description":"Timeouts specified on conditions.","notes":"On timeout, expand on_timeout template (or on_false if not specified).\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["conditions","timeout"],"dependencies":[{"issue_id":"meow-e6.2","depends_on_id":"meow-e6.1","type":"blocks","created_at":"2026-01-07T03:14:33.569531385-05:00","created_by":"ubuntu"}]}
{"id":"meow-e6.3","title":"Implement helper commands (wait-approve, wait-file, etc.)","description":"Convenience commands for common blocking patterns.","notes":"Commands:\n- meow wait-approve --bead \u003cid\u003e\n- meow wait-file \u003cpath\u003e\n- meow wait-bead \u003cid\u003e --status closed\n- meow context-usage --threshold N --format exit-code\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["conditions","helpers"],"dependencies":[{"issue_id":"meow-e6.3","depends_on_id":"meow-e6.1","type":"blocks","created_at":"2026-01-07T03:14:33.662016544-05:00","created_by":"ubuntu"}]}
{"id":"meow-e6.4","title":"Implement gate approval flow","description":"Human approval unblocking via meow approve.","notes":"`meow approve \u003cbead\u003e` creates marker that `meow wait-approve` detects.\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["conditions","gates"],"dependencies":[{"issue_id":"meow-e6.4","depends_on_id":"meow-e6.1","type":"blocks","created_at":"2026-01-07T03:14:33.755085213-05:00","created_by":"ubuntu"}]}
{"id":"meow-e6.5","title":"Implement meow test-runner helper command","description":"Project-type-aware test runner for TDD workflow conditions.","notes":"## Why This Task\nThe implement-tdd template needs to run tests but different projects use\ndifferent test frameworks (npm test, go test, pytest, cargo test, etc.).\nHard-coding framework detection in templates is fragile.\n\n## Solution\n`meow test-runner` abstracts the test command based on project detection.\n\n## Usage\n```bash\nmeow test-runner                    # Run tests, exit 0 if pass\nmeow test-runner --expect-fail      # Exit 0 if tests FAIL (for TDD)\nmeow test-runner --framework npm    # Force specific framework\n```\n\n## Project Detection\n1. If `package.json` exists and has `scripts.test`: npm test\n2. If `go.mod` exists: go test ./...\n3. If `Cargo.toml` exists: cargo test\n4. If `pytest.ini` or `setup.py` exists: pytest\n5. If `Makefile` with `test` target: make test\n6. Fallback: error with helpful message\n\n## Implementation\n```go\nfunc (c *TestRunnerCmd) Run() error {\n    framework := c.detectFramework()\n    if framework == \"\" {\n        return \u0026MeowError{\n            Code:    \"TEST_001\",\n            Message: \"Could not detect test framework\",\n            Details: map[string]any{\n                \"hint\": \"Use --framework to specify manually\",\n                \"supported\": []string{\"npm\", \"go\", \"cargo\", \"pytest\", \"make\"},\n            },\n        }\n    }\n\n    cmd := c.buildCommand(framework)\n    exitCode := runCommand(cmd)\n\n    if c.expectFail {\n        // For TDD: success means tests failed as expected\n        if exitCode != 0 {\n            return nil  // Tests failed = success\n        }\n        return fmt.Errorf(\"tests passed unexpectedly\")\n    }\n\n    if exitCode != 0 {\n        return fmt.Errorf(\"tests failed with exit code %d\", exitCode)\n    }\n    return nil\n}\n```\n\n## Use in Templates\n```toml\n# In implement-tdd.toml\n[[steps]]\nid = \"verify-fail\"\ntype = \"condition\"\ncondition = \"meow test-runner --expect-fail\"  # Clean, project-agnostic\n```\n\n## Acceptance Criteria\n- [ ] Detects npm projects\n- [ ] Detects Go projects\n- [ ] Detects Cargo projects\n- [ ] --expect-fail inverts exit code\n- [ ] --framework overrides detection\n- [ ] Helpful error when detection fails\n- [ ] Unit tests for each detection path\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["conditions","helpers","testing"],"dependencies":[{"issue_id":"meow-e6.5","depends_on_id":"meow-e6.1","type":"blocks","created_at":"2026-01-07T03:14:33.842319108-05:00","created_by":"ubuntu"}]}
{"id":"meow-e7","title":"Output Binding \u0026 Session Management","description":"Implement output binding between beads and session management for\ncheckpoint/resume composition.\n","notes":"## Why This Epic\nOutput binding is the key capability that enables:\n- Dynamic worktree paths from code → start\n- Task selection outputs from Claude → orchestrator\n- Session IDs from code → start (for resume)\n\n## Key Components\n1. Output storage on beads\n2. Output reference resolution in variable substitution\n3. meow session-id command for checkpoint composition\n4. meow close --output for task outputs\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T03:12:48.457391798-05:00","labels":["epic","outputs","phase-3","session"],"dependencies":[{"issue_id":"meow-e7","depends_on_id":"meow-e4","type":"blocks","created_at":"2026-01-07T03:14:33.933739685-05:00","created_by":"ubuntu"},{"issue_id":"meow-e7","depends_on_id":"meow-e5","type":"blocks","created_at":"2026-01-07T03:14:34.024222144-05:00","created_by":"ubuntu"}]}
{"id":"meow-e7.1","title":"Implement meow session-id command","description":"Command to discover and output Claude's session ID.","notes":"## Purpose\nThis command enables checkpoint composition:\n```yaml\ntype: code\ncode: meow session-id --agent {{agent}}\noutputs:\n  session_id: stdout\n```\n\nThe output can then be used by a start bead:\n```yaml\ntype: start\nresume_session: \"{{save-session.outputs.session_id}}\"\n```\n\n## Session ID Discovery\n- Read $MEOW_SESSION_ID if set (via meow prime --hook)\n- Or find latest in ~/.claude/sessions/ for agent\n- Or query tmux session for environment\n\n## Usage\n```bash\nmeow session-id              # Current agent\nmeow session-id --agent X    # Specific agent\nmeow session-id --save       # Also save to .meow/sessions/\n```\n\n## Acceptance Criteria\n- [ ] Discovers session ID from environment\n- [ ] Falls back to session file discovery\n- [ ] Outputs clean session ID to stdout\n- [ ] Works in code bead context\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["cli","session"],"dependencies":[{"issue_id":"meow-e7.1","depends_on_id":"meow-e5.2","type":"blocks","created_at":"2026-01-07T03:14:34.11118274-05:00","created_by":"ubuntu"}]}
{"id":"meow-e7.2","title":"Implement output storage on beads","description":"Store captured outputs on bead records.","notes":"## Storage Format\n```json\n{\n  \"id\": \"create-worktree\",\n  \"type\": \"code\",\n  \"status\": \"closed\",\n  \"outputs\": {\n    \"path\": \"~/worktrees/worker\",\n    \"sha\": \"abc123\"\n  }\n}\n```\n\n## Requirements\n- Outputs persist in bead file\n- Outputs queryable via bd show\n- Outputs survive orchestrator restart\n\n## Acceptance Criteria\n- [ ] Code beads store captured outputs\n- [ ] Task beads store validated outputs\n- [ ] Outputs visible in bd show\n- [ ] Outputs persist across restarts\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:35:10.378220265-05:00","closed_at":"2026-01-08T01:35:10.378220265-05:00","close_reason":"Output storage fully implemented: Outputs field on Bead, meow show command displays outputs, FileBeadStore persists to JSONL. Added comprehensive tests for meow show.","labels":["outputs","storage"]}
{"id":"meow-e7.3","title":"Implement output reference resolution","description":"Resolve {{bead.outputs.field}} references during template processing.","notes":"## Resolution Process\nWhen processing a template with {{bead_id.outputs.field}}:\n1. Find bead with matching ID\n2. Check bead is closed (outputs available)\n3. Look up outputs.field\n4. Substitute value\n\n## Error Cases\n- Bead not found → error with available beads\n- Bead not closed → error (dependency issue)\n- Output field not found → error with available fields\n\n## Acceptance Criteria\n- [ ] Resolves valid output references\n- [ ] Clear error for missing bead\n- [ ] Clear error for unclosed bead\n- [ ] Clear error for missing field\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:43:37.340068879-05:00","closed_at":"2026-01-08T01:43:37.340068879-05:00","close_reason":"Implemented BeadLookupFunc for dynamic output resolution. VarContext now supports fetching outputs from BeadStore when not cached. Added comprehensive tests for all error cases.","labels":["outputs","resolution"],"dependencies":[{"issue_id":"meow-e7.3","depends_on_id":"meow-e7.2","type":"blocks","created_at":"2026-01-07T03:14:34.202956446-05:00","created_by":"ubuntu"},{"issue_id":"meow-e7.3","depends_on_id":"meow-e2.2","type":"blocks","created_at":"2026-01-07T03:14:34.293578702-05:00","created_by":"ubuntu"}]}
{"id":"meow-e7.4","title":"Implement output type validators","description":"Implement validators for all output types including bead_id.","notes":"## Why This Task is Critical\nOutput validation is what makes Claude's outputs reliable. Without proper\nvalidation, typos and hallucinated bead IDs would break workflows.\n\n## Output Types to Validate\n```go\ntype OutputType string\n\nconst (\n    TypeString    OutputType = \"string\"\n    TypeStringArr OutputType = \"string[]\"\n    TypeNumber    OutputType = \"number\"\n    TypeBoolean   OutputType = \"boolean\"\n    TypeJSON      OutputType = \"json\"\n    TypeBeadID    OutputType = \"bead_id\"\n    TypeBeadIDArr OutputType = \"bead_id[]\"\n    TypeFilePath  OutputType = \"file_path\"\n)\n```\n\n## Validator Interface\n```go\ntype OutputValidator interface {\n    Validate(value string, ctx ValidationContext) error\n    TypeName() string\n}\n\ntype ValidationContext struct {\n    BeadsDir    string\n    WorkDir     string\n    BeadLookup  func(id string) (*types.Bead, bool)\n}\n```\n\n## bead_id Validator (Most Important)\n```go\ntype BeadIDValidator struct{}\n\nfunc (v *BeadIDValidator) Validate(value string, ctx ValidationContext) error {\n    // Check format\n    if !strings.HasPrefix(value, \"bd-\") {\n        return fmt.Errorf(\"bead_id must start with 'bd-', got '%s'\", value)\n    }\n\n    // Check existence\n    bead, found := ctx.BeadLookup(value)\n    if !found {\n        // Suggest similar beads\n        suggestions := findSimilarBeads(value, ctx)\n        return \u0026BeadNotFoundError{\n            ID:          value,\n            Suggestions: suggestions,\n        }\n    }\n\n    return nil\n}\n```\n\n## file_path Validator\n```go\ntype FilePathValidator struct{}\n\nfunc (v *FilePathValidator) Validate(value string, ctx ValidationContext) error {\n    path := value\n    if !filepath.IsAbs(path) {\n        path = filepath.Join(ctx.WorkDir, path)\n    }\n\n    if _, err := os.Stat(path); os.IsNotExist(err) {\n        return fmt.Errorf(\"file does not exist: %s\", value)\n    }\n\n    return nil\n}\n```\n\n## Error Messages\nMust be helpful and actionable:\n```\nError: Output validation failed for 'work_bead'\n\n  Value: \"bd-task-999\"\n  Type: bead_id\n  Error: Bead 'bd-task-999' does not exist\n\n  Did you mean one of these?\n    • bd-task-001 \"Implement auth\"\n    • bd-task-002 \"Add validation\"\n    • bd-task-003 \"Write tests\"\n\nHint: Run 'bd list --status=open' to see available beads\n```\n\n## Acceptance Criteria\n- [ ] All 8 types have working validators\n- [ ] bead_id checks actual bead existence\n- [ ] file_path checks file existence\n- [ ] Suggestions provided for typos\n- [ ] Error messages are actionable\n- [ ] Unit tests for each validator\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T02:17:11.613384974-05:00","closed_at":"2026-01-08T02:17:11.613384974-05:00","close_reason":"Output validators fully implemented: format validation for bead IDs, BeadNotFoundError with Levenshtein-based suggestions, actionable error messages with hints. All 8 types validated with comprehensive tests.","labels":["critical","outputs","validation"],"dependencies":[{"issue_id":"meow-e7.4","depends_on_id":"meow-e7.2","type":"blocks","created_at":"2026-01-07T03:14:34.382248765-05:00","created_by":"ubuntu"}]}
{"id":"meow-e8","title":"Integration: Beads, hooks, recovery","description":"Integration with external systems.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T03:12:48.457391798-05:00","labels":["epic","integration","phase-3"],"dependencies":[{"issue_id":"meow-e8","depends_on_id":"meow-e3","type":"blocks","created_at":"2026-01-07T03:14:34.469376424-05:00","created_by":"ubuntu"},{"issue_id":"meow-e8","depends_on_id":"meow-e4","type":"blocks","created_at":"2026-01-07T03:14:34.56063549-05:00","created_by":"ubuntu"}]}
{"id":"meow-e8.1","title":"Implement beads integration","description":"Implement MEOW's integration with the beads data layer.\n\n## Architecture Decision: Overlay Approach (No Fork)\n\nPer SPEC-ADDENDUM, MEOW **layers on top** of upstream beads rather than forking:\n- MEOW defines its own internal `Bead` type (`internal/types/bead.go`)\n- Both MEOW and upstream `bd` read/write the same `issues.jsonl` file\n- JSON schema flexibility means MEOW-specific fields are preserved but ignored by `bd`\n- ID prefix separation: `meow-*` for workflow beads, `bd-*` for work beads\n\n## Integration Approach: Direct File I/O\n\nMEOW reads/writes `.beads/issues.jsonl` directly using its internal types. We do NOT shell out to `bd` CLI for MEOW operations.\n\n```go\n// internal/orchestrator/beadstore.go already implements this!\ntype FileBeadStore struct {\n    path string  // .beads/issues.jsonl\n}\n\nfunc (s *FileBeadStore) Create(ctx context.Context, bead *types.Bead) error {\n    // Append bead as JSON line to issues.jsonl\n}\n\nfunc (s *FileBeadStore) Update(ctx context.Context, bead *types.Bead) error {\n    // Read all, update matching ID, write back\n}\n\nfunc (s *FileBeadStore) Get(ctx context.Context, id string) (*types.Bead, error) {\n    // Read file, find by ID\n}\n\nfunc (s *FileBeadStore) List(ctx context.Context, filter BeadFilter) ([]*types.Bead, error) {\n    // Read file, apply filter\n}\n```\n\n## ID Prefix Convention\n\n| Prefix | Source | Purpose |\n|--------|--------|---------|\n| `bd-*` | Created via `bd create` | Work beads (traditional issues) |\n| `meow-{workflow}.{step}` | Created by MEOW baker | Workflow beads (wisps, orchestrator) |\n\n## What This Task Actually Covers\n\nSince `FileBeadStore` is already implemented, this task is about:\n\n1. **Verifying compatibility** - Ensure MEOW-written beads are valid for upstream `bd`\n2. **ID generation** - Implement `meow-{workflow}.{step}` ID pattern\n3. **MEOW field serialization** - Verify `tier`, `hook_bead`, etc. serialize correctly\n4. **Concurrent access** - Handle case where both `meow` and `bd` modify the file\n\n## Test Cases\n\n```go\nfunc TestBeadsInterop(t *testing.T) {\n    // 1. Create bead with bd CLI\n    exec.Command(\"bd\", \"create\", \"--title\", \"Test work\").Run()\n    \n    // 2. Read it with MEOW's FileBeadStore\n    bead, _ := store.Get(ctx, \"bd-xxx\")\n    assert.Equal(t, \"Test work\", bead.Title)\n    \n    // 3. Create MEOW workflow bead\n    store.Create(ctx, \u0026types.Bead{\n        ID:   \"meow-abc.step-1\",\n        Tier: types.TierWisp,\n        // MEOW-specific fields\n    })\n    \n    // 4. Verify bd list shows it (but ignores MEOW fields)\n    out, _ := exec.Command(\"bd\", \"list\", \"--format\", \"json\").Output()\n    assert.Contains(t, string(out), \"meow-abc.step-1\")\n}\n```\n\n## Acceptance Criteria\n- [ ] FileBeadStore reads beads created by `bd` CLI\n- [ ] Beads created by MEOW are readable by `bd` CLI  \n- [ ] MEOW-specific fields are preserved through read/write cycles\n- [ ] ID prefix convention implemented in baker\n- [ ] Concurrent access doesn't corrupt data (file locking)","notes":"## Integration Points\nMEOW uses the `bd` CLI for all bead operations. This task integrates:\n\n### Bead Creation (template baking)\n```go\nfunc createBead(bead *types.Bead) error {\n    args := []string{\"create\",\n        \"--id\", bead.ID,\n        \"--type\", bead.Type,\n        \"--title\", bead.Title,\n    }\n    if bead.Parent != \"\" {\n        args = append(args, \"--parent\", bead.Parent)\n    }\n    for _, dep := range bead.Needs {\n        args = append(args, \"--dep\", dep)\n    }\n    return exec.Command(\"bd\", args...).Run()\n}\n```\n\n### Status Updates\n```go\nfunc updateBeadStatus(id string, status string) error {\n    return exec.Command(\"bd\", \"update\", id, \"--status\", status).Run()\n}\n```\n\n### Reading Beads\n```go\nfunc getBead(id string) (*types.Bead, error) {\n    out, err := exec.Command(\"bd\", \"show\", id, \"--format\", \"json\").Output()\n    if err != nil {\n        return nil, err\n    }\n    var bead types.Bead\n    json.Unmarshal(out, \u0026bead)\n    return \u0026bead, nil\n}\n```\n\n### Querying\n```go\nfunc listBeads(status string) ([]types.Bead, error) {\n    args := []string{\"list\", \"--format\", \"json\"}\n    if status != \"\" {\n        args = append(args, \"--status\", status)\n    }\n    // ...\n}\n```\n\n## Output Storage\nWhen storing outputs on beads:\n```go\nfunc storeOutputs(beadID string, outputs map[string]string) error {\n    outputJSON, _ := json.Marshal(outputs)\n    return exec.Command(\"bd\", \"update\", beadID,\n        \"--set\", fmt.Sprintf(\"outputs=%s\", outputJSON)).Run()\n}\n```\n\n## Acceptance Criteria\n- [ ] bd create integrates correctly\n- [ ] bd update for status changes\n- [ ] bd show for reading with JSON\n- [ ] bd list for queries\n- [ ] Output storage works\n- [ ] Error handling for bd failures\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T18:22:59.804970375-05:00","labels":["beads","integration"],"dependencies":[{"issue_id":"meow-e8.1","depends_on_id":"meow-e1.2","type":"blocks","created_at":"2026-01-07T03:14:34.649846479-05:00","created_by":"ubuntu"}]}
{"id":"meow-e8.2","title":"Implement Claude Code hooks setup","description":"Configure .claude/settings.json with MEOW hooks.","notes":"- SessionStart: meow prime --hook\n- Stop: meow prime --format prompt\n\nmeow init should set this up.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["hooks","integration"]}
{"id":"meow-e8.3","title":"Test and validate crash recovery","description":"Integration test for crash recovery.","notes":"1. Start workflow\n2. Kill orchestrator mid-execution\n3. Restart\n4. Verify continues correctly\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["integration","recovery"],"dependencies":[{"issue_id":"meow-e8.3","depends_on_id":"meow-e3.4","type":"blocks","created_at":"2026-01-07T03:14:34.743798036-05:00","created_by":"ubuntu"}]}
{"id":"meow-e8.4","title":"Implement git worktree support","description":"Helper functions for git worktree operations in code beads.","notes":"## Why Worktrees Matter\nWorktrees allow child agents to work in isolated branches without\naffecting the parent's working directory. This enables:\n- Parallel work on different features\n- Clean separation of concerns\n- Easy cleanup after completion\n\n## Worktree Path Convention\n```\n.meow/worktrees/{agent-id}/\n```\n\n## Helper Functions\n```go\n// Create worktree for agent\nfunc CreateWorktree(agentID string, branch string) (string, error) {\n    path := filepath.Join(\".meow/worktrees\", agentID)\n    branchName := fmt.Sprintf(\"meow/%s\", agentID)\n\n    cmd := exec.Command(\"git\", \"worktree\", \"add\",\n        \"-b\", branchName,\n        path,\n        \"HEAD\")\n\n    if err := cmd.Run(); err != nil {\n        return \"\", fmt.Errorf(\"failed to create worktree: %w\", err)\n    }\n\n    return path, nil\n}\n\n// Remove worktree and branch\nfunc RemoveWorktree(agentID string) error {\n    path := filepath.Join(\".meow/worktrees\", agentID)\n    branchName := fmt.Sprintf(\"meow/%s\", agentID)\n\n    // Remove worktree\n    exec.Command(\"git\", \"worktree\", \"remove\", path).Run()\n\n    // Delete branch (force if needed)\n    exec.Command(\"git\", \"branch\", \"-D\", branchName).Run()\n\n    return nil\n}\n\n// Check if worktree exists\nfunc WorktreeExists(agentID string) bool {\n    path := filepath.Join(\".meow/worktrees\", agentID)\n    _, err := os.Stat(path)\n    return err == nil\n}\n```\n\n## Usage in call Template\nThe call template uses worktrees when `use_worktree = true`:\n```toml\n[[steps]]\nid = \"setup-worktree\"\ntype = \"code\"\ncode = '''\nmeow worktree create {{child}}\n'''\noutputs = { workdir = \"stdout\" }\n```\n\n## CLI Commands (optional)\n```bash\nmeow worktree create \u003cagent\u003e   # Create and output path\nmeow worktree remove \u003cagent\u003e   # Remove worktree and branch\nmeow worktree list             # List active worktrees\n```\n\n## Acceptance Criteria\n- [ ] Create worktree at .meow/worktrees/{agent}/\n- [ ] Remove worktree and cleanup branch\n- [ ] Handle existing worktree gracefully\n- [ ] Output path to stdout for capture\n- [ ] Unit tests with mock git\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["git","integration"]}
{"id":"meow-e9","title":"Default Templates: MVP template library","description":"Ship useful default templates.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-07T03:12:48.457391798-05:00","labels":["epic","phase-4","templates"],"dependencies":[{"issue_id":"meow-e9","depends_on_id":"meow-e2","type":"blocks","created_at":"2026-01-07T03:14:34.834779324-05:00","created_by":"ubuntu"}]}
{"id":"meow-e9.1","title":"Create work-loop template","description":"Main orchestration loop template.","notes":"Check for work → select → implement → check context → loop.\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["templates","work-loop"]}
{"id":"meow-e9.3","title":"Create human-gate template","description":"Blocking approval template.","notes":"prepare-summary → notify → await-approval → record-decision\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["gate","templates"]}
{"id":"meow-e9.4","title":"Create refresh and handoff templates","description":"Context refresh templates.","notes":"refresh: stop → start\nhandoff: write-notes → stop → start\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["refresh","templates"]}
{"id":"meow-e9.5","title":"Create context-check template","description":"Check context and maybe refresh.","notes":"## Template: context-check.toml\n```toml\n[meta]\nname = \"context-check\"\ndescription = \"Check context usage and trigger refresh if needed\"\n\n[variables]\nagent = { required = true }\nthreshold = { default = 70, description = \"Context % threshold\" }\n\n[[steps]]\nid = \"check\"\ntype = \"condition\"\ncondition = \"meow context-usage --agent {{agent}} --threshold {{threshold}} --format exit-code\"\non_true:\n  template = \"handoff\"\n  variables = { agent = \"{{agent}}\" }\non_false:\n  inline = []  # Continue without refresh\n```\n\n## Acceptance Criteria\n- [ ] Template parses and validates\n- [ ] Threshold is configurable\n- [ ] Triggers handoff when context high\n- [ ] Unit test for template validation\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["context","templates"]}
{"id":"meow-e9.6","title":"Create call template (parent/child orchestration)","description":"Template for spawning child agent, running workflow, resuming parent.","notes":"## Why This Template is Critical\nThe `call` template is the foundation for parent/child agent orchestration.\nIt demonstrates the composed checkpoint/resume pattern using the 6 primitives.\n\n## Template: call.toml\n```toml\n[meta]\nname = \"call\"\ndescription = \"Spawn child agent for sub-workflow, then resume parent\"\nephemeral = true  # All steps are operational machinery\n\n[variables]\nparent = { required = true, description = \"Parent agent ID\" }\nchild = { required = true, description = \"Child agent ID\" }\ntemplate = { required = true, description = \"Template for child to execute\" }\ntemplate_vars = { default = {}, description = \"Variables for child template\" }\nuse_worktree = { default = false, description = \"Create git worktree for child\" }\n\n# --- Save parent session ---\n[[steps]]\nid = \"save-parent-session\"\ntype = \"code\"\ncode = \"meow session-id --agent {{parent}}\"\noutputs = { session_id = \"stdout\" }\n\n[[steps]]\nid = \"stop-parent\"\ntype = \"stop\"\nagent = \"{{parent}}\"\nneeds = [\"save-parent-session\"]\n\n# --- Setup child workspace ---\n[[steps]]\nid = \"setup-worktree\"\ntype = \"code\"\nneeds = [\"stop-parent\"]\ncode = '''\nif [ \"{{use_worktree}}\" = \"true\" ]; then\n    git worktree add -b meow/{{child}} .meow/worktrees/{{child}} HEAD\n    echo \".meow/worktrees/{{child}}\"\nelse\n    pwd\nfi\n'''\noutputs = { workdir = \"stdout\" }\n\n# --- Start child ---\n[[steps]]\nid = \"start-child\"\ntype = \"start\"\nagent = \"{{child}}\"\nworkdir = \"{{setup-worktree.outputs.workdir}}\"\nneeds = [\"setup-worktree\"]\n\n# --- Child executes the work ---\n[[steps]]\nid = \"child-work\"\ntype = \"expand\"\ntemplate = \"{{template}}\"\nvariables = \"{{template_vars}}\"\nassignee = \"{{child}}\"\nneeds = [\"start-child\"]\n\n# --- Stop child ---\n[[steps]]\nid = \"stop-child\"\ntype = \"stop\"\nagent = \"{{child}}\"\nneeds = [\"child-work\"]\n\n# --- Cleanup worktree ---\n[[steps]]\nid = \"cleanup-worktree\"\ntype = \"code\"\nneeds = [\"stop-child\"]\ncode = '''\nif [ \"{{use_worktree}}\" = \"true\" ]; then\n    git worktree remove .meow/worktrees/{{child}} || true\n    git branch -d meow/{{child}} || true\nfi\n'''\n\n# --- Resume parent ---\n[[steps]]\nid = \"resume-parent\"\ntype = \"start\"\nagent = \"{{parent}}\"\nworkdir = \".\"\nresume_session = \"{{save-parent-session.outputs.session_id}}\"\nneeds = [\"cleanup-worktree\"]\n```\n\n## Key Features Demonstrated\n1. Output binding: session_id and workdir captured and used\n2. Composed checkpoint/resume: code → start with resume_session\n3. Ephemeral: all steps are machinery, not work\n4. Worktree isolation: optional per-agent workspace\n\n## Acceptance Criteria\n- [ ] Template parses and validates\n- [ ] Variables substitute correctly\n- [ ] Output references resolve\n- [ ] E2E test with mock agents\n- [ ] Unit test for template validation\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["call","critical","templates"],"dependencies":[{"issue_id":"meow-e9.6","depends_on_id":"meow-e7.1","type":"blocks","created_at":"2026-01-07T03:14:34.927608572-05:00","created_by":"ubuntu"},{"issue_id":"meow-e9.6","depends_on_id":"meow-e7.2","type":"blocks","created_at":"2026-01-07T03:14:35.018756942-05:00","created_by":"ubuntu"},{"issue_id":"meow-e9.6","depends_on_id":"meow-e7.3","type":"blocks","created_at":"2026-01-07T03:14:35.109804641-05:00","created_by":"ubuntu"}]}
{"id":"meow-e9.7","title":"Create implement-tdd template","description":"TDD workflow template that works with a work bead.","notes":"## Template: implement-tdd.toml\n```toml\n[meta]\nname = \"implement-tdd\"\ndescription = \"TDD implementation workflow\"\nephemeral = true  # Steps are operational\n\n[variables]\nwork_bead = { required = true, type = \"bead_id\", description = \"The work bead to implement\" }\n\n[[steps]]\nid = \"load-context\"\ntype = \"task\"\ntitle = \"Load context for {{work_bead}}\"\ndescription = |\n  1. Run: bd show {{work_bead}}\n  2. Understand the requirements\n  3. Identify relevant files\n  4. Update notes with your understanding\n\n[[steps]]\nid = \"write-tests\"\ntype = \"task\"\ntitle = \"Write failing tests\"\ndescription = \"Write tests that will fail until implementation is complete\"\nneeds = [\"load-context\"]\n\n[[steps]]\nid = \"verify-fail\"\ntype = \"condition\"\ncondition = \"meow test-runner --expect-fail\"  # Project-type agnostic\nneeds = [\"write-tests\"]\non_true:\n  inline = []  # Tests fail as expected, continue\non_false:\n  inline = [\n    { id = \"fix-tests\", type = \"task\", title = \"Tests passed unexpectedly - revise tests\" }\n  ]\n\n[[steps]]\nid = \"implement\"\ntype = \"task\"\ntitle = \"Write implementation\"\ndescription = \"Write the minimum code to make tests pass\"\nneeds = [\"verify-fail\"]\n\n[[steps]]\nid = \"verify-pass\"\ntype = \"condition\"\ncondition = \"meow test-runner\"  # Project-type agnostic\nneeds = [\"implement\"]\non_true:\n  inline = []  # Tests pass, continue\non_false:\n  inline = [\n    { id = \"fix-impl\", type = \"task\", title = \"Tests still failing - fix implementation\" }\n  ]\n\n[[steps]]\nid = \"commit\"\ntype = \"task\"\ntitle = \"Commit changes\"\ndescription = \"Create a descriptive commit for the changes\"\nneeds = [\"verify-pass\"]\n\n[[steps]]\nid = \"close-work-bead\"\ntype = \"code\"\ncode = \"bd close {{work_bead}} --notes 'Implemented via implement-tdd template'\"\nneeds = [\"commit\"]\n```\n\n## Acceptance Criteria\n- [ ] Template parses and validates\n- [ ] work_bead variable is type-checked as bead_id\n- [ ] Verify-fail/verify-pass conditions work\n- [ ] Work bead is closed at end\n- [ ] Unit test for template validation\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T03:12:48.465692926-05:00","labels":["implement","tdd","templates"]}
{"id":"meow-eej","title":"Bug: Inline steps lose title/code fields in condition branches","description":"## Problem\n\nThe `InlineStep` struct in `internal/template/parser.go:97-104` is missing critical fields:\n\n```go\ntype InlineStep struct {\n    ID           string   \\`toml:\"id\"\\`\n    Type         string   \\`toml:\"type\"\\`\n    Description  string   \\`toml:\"description,omitempty\"\\`\n    Instructions string   \\`toml:\"instructions,omitempty\"\\`\n    Assignee     string   \\`toml:\"assignee,omitempty\"\\`\n    Needs        []string \\`toml:\"needs,omitempty\"\\`\n    // MISSING: Title, Code, Condition, OnTrue, OnFalse, etc.\n}\n```\n\nCompare to full `Step` struct (lines 54-74) which has: Title, Code, Condition, Validation, Template, Variables, Ephemeral, OnTrue, OnFalse, OnTimeout, Timeout, Outputs...\n\n## Impact\n\nWhen parsing inline steps in condition branches:\n```toml\n[main.steps.on_false]\ninline = [\n    { id = \"create-marker\", type = \"code\", title = \"Create marker\", code = \"touch /tmp/marker\" }\n]\n```\n\nThe `title` and `code` fields are silently discarded because the struct doesn't have them!\n\n## Root Cause\n\nThis is NOT a serialization bug in `expansionTargetToTypes()` - that code correctly marshals what it receives. The problem is the parser never captures these fields.\n\n## Fix Options\n\nOption A: Make `InlineStep` have all the same fields as `Step`\nOption B: Reuse `Step` struct for inline steps instead of a separate `InlineStep`\n\n## Files\n- `internal/template/parser.go:97-104` - `InlineStep` struct definition (root cause)\n- `internal/template/parser.go:54-74` - `Step` struct (has all fields)\n- `internal/template/baker.go:510-520` - `expansionTargetToTypes()` (works correctly with what it receives)\n\n## Acceptance Criteria\n- [ ] Inline steps in condition branches preserve title field\n- [ ] Inline steps preserve code field for code beads\n- [ ] Inline steps preserve condition field for nested conditions\n- [ ] Test: bake template with inline code step, verify code is present in bead","status":"closed","priority":1,"issue_type":"bug","assignee":"agent2","created_at":"2026-01-08T03:03:32.603903752-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:32.92831957-05:00","closed_at":"2026-01-08T03:27:32.92831957-05:00","close_reason":"Closed","labels":["baker","bug","parser"]}
{"id":"meow-f8d","title":"Implement meow agents command","description":"## Current State\n\nThe `meow agents` command is a stub that prints \"not yet implemented\".\n\n## Required Functionality\n\nList all agents and their status:\n\n```bash\nmeow agents\n# Output:\n# AGENT       STATUS        TMUX SESSION      CURRENT BEAD\n# claude-1    active        meow-claude-1     bd-task-001\n# claude-2    stopped       -                 -\n\nmeow agents --json  # JSON format for scripting\n```\n\n## Implementation\n\nUse `internal/agent/store.go` to list agents:\n- `Store.List()` - returns all agents\n- Check tmux session status for each\n\n## File\n`cmd/meow/cmd/agents.go`\n\n## Acceptance Criteria\n- [ ] Lists all agents from store\n- [ ] Shows status, tmux session, current bead\n- [ ] JSON output format option","status":"closed","priority":2,"issue_type":"task","assignee":"agent3","created_at":"2026-01-08T03:04:31.397956463-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:31.015100085-05:00","closed_at":"2026-01-08T03:27:31.015100085-05:00","close_reason":"Closed","labels":["cli"]}
{"id":"meow-fxw","title":"Implement tier partitioning logic","description":"Classify steps into Work/Wisp/Orchestrator tiers. See IMPLEMENTATION-PLAN section meow-modules-baker-partition.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.796809646-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:16:39.772075975-05:00","closed_at":"2026-01-07T18:16:39.772075975-05:00","close_reason":"Consolidated into meow-cxt (tier assignment in baker). Partitioning logic is part of determineTier() which goes in cxt.","dependencies":[{"issue_id":"meow-fxw","depends_on_id":"meow-ks2","type":"blocks","created_at":"2026-01-07T16:39:47.15279137-05:00","created_by":"ubuntu"}]}
{"id":"meow-g5s","title":"Research: MEOW-owned bead storage system","description":"## Summary\n\nReplace MEOW's dependency on external `bd` CLI with a self-contained bead storage system. The current approach of overlaying MEOW fields onto beads' `issues.jsonl` creates irreconcilable schema conflicts.\n\n## Problem Statement\n\nMEOW and `bd` write to the same `.beads/issues.jsonl` with incompatible schemas:\n- MEOW uses `type` (task, code, start, etc.), `tier` (work, wisp, orchestrator), `needs`, `workflow_id`, `*_spec` fields\n- `bd` uses `issue_type`, `priority`, `dependencies` table, no tier concept\n- When `bd sync` runs, it exports from SQLite and strips all MEOW-specific fields\n- This breaks `meow prime` which filters by Tier to find agent work\n\n## Proposed Solution\n\nBuild MEOW's own lightweight bead storage, inspired by the `ticket` CLI (github.com/wedow/ticket):\n\n### Storage Format\n```\n.meow/\n├── config.toml           # MEOW configuration\n├── templates/            # Workflow templates  \n└── beads/                # MEOW's own bead storage\n    └── {workflow-id}.{step-id}.md    # Markdown + YAML frontmatter\n```\n\n### Bead File Format\n```yaml\n---\nid: meow-xxx.step-yyy\ntype: task                    # 8 MEOW types\ntier: wisp                    # work | wisp | orchestrator\nstatus: open\nworkflow_id: meow-xxx\nassignee: agent-1\nneeds: [meow-xxx.step-aaa]\ncreated_at: 2026-01-08T21:00:00Z\ncode_spec:                    # Type-specific specs inline\n  code: \"echo hello\"\n---\n# Step Title\n\nInstructions/description in markdown body.\n```\n\n### Key Design Principles to Preserve\n\n1. **Durable execution** - Workflow state survives crashes, stored in files\n2. **Git tracking** - All beads are git-tracked for audit trail\n3. **Crash recovery** - Orchestrator can resume from file state\n4. **Agent handoffs** - Beads contain all context for session continuity\n5. **Dependency resolution** - `ready` detection via `needs` field\n\n### Advantages Over Current Approach\n\n1. **Full schema control** - Tier, Type, Specs are first-class\n2. **No sync conflicts** - No fighting with bd's SQLite/JSONL\n3. **Workflow-scoped** - Beads belong to workflows, not global tracker\n4. **Ephemeral is native** - Wisps/orchestrator beads clean up naturally\n5. **Agent-friendly** - Markdown files easy for Claude to read/search\n6. **Simpler** - No mapping layers or compatibility shims\n\n### Compatibility with Existing Beads Projects\n\nFor projects already using `bd` as issue tracker:\n- Users create workflows describing how to query beads (`bd ready`, etc.)\n- MEOW agents learn to work with beads through workflow instructions\n- No data migration required - coexistence via workflow configuration\n\n## Research References\n\n- `ticket` CLI: github.com/wedow/ticket - ~900 line bash script, markdown+YAML storage\n- Current MEOW types: `internal/types/bead.go`\n- Current beadstore: `internal/orchestrator/beadstore.go`\n- beads Issue struct: see beads source in acfs-setup\n\n## Implementation Considerations\n\n- Rewrite `FileBeadStore` to use markdown+YAML format\n- Update baker to write new format\n- Update orchestrator to read new format  \n- Add migration command for existing MEOW beads\n- Consider: separate files per bead vs single file per workflow\n\n## Acceptance Criteria\n\n- [ ] Design document with full architecture\n- [ ] New bead file format specification\n- [ ] FileBeadStore replacement implementation\n- [ ] Orchestrator integration\n- [ ] Migration path from current format\n- [ ] Tests for crash recovery scenarios","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T16:27:22.901459487-05:00","created_by":"ubuntu","updated_at":"2026-01-08T16:28:51.407745963-05:00"}
{"id":"meow-gy2","title":"Baker: Wisp Detection and Tier Labeling","description":"Extend baker for automatic tier classification and wisp detection. Phase 2.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.839652883-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:38:25.839652883-05:00"}
{"id":"meow-i46","title":"beadstore.go: Get() returns internal pointer instead of copy","description":"## Location\n`internal/orchestrator/beadstore.go:178-192`\n\n## Problem\n`FileBeadStore.Get()` returns the internal bead pointer directly, unlike `agent/store.go` which returns copies via `copyAgent()`:\n\n```go\n// beadstore.go - returns internal pointer\nfunc (s *FileBeadStore) Get(ctx context.Context, id string) (*types.Bead, error) {\n    ...\n    return bead, nil  // Direct pointer to internal state\n}\n\n// agent/store.go - returns copy\nfunc (s *Store) Get(ctx context.Context, id string) (*types.Agent, error) {\n    ...\n    return copyAgent(agent), nil  // Safe copy\n}\n```\n\n## Impact\n- Callers can mutate internal state without going through Update()\n- Potential data corruption if concurrent modifications occur\n- Race conditions possible between goroutines\n\n## Current Mitigation\nThe orchestrator pattern is: Get() → modify → Update(), which works because:\n1. The lock is released between Get() and Update()\n2. No concurrent reads of the same bead are expected\n3. Store.Update() overwrites with the modified bead\n\n## Risk\nIf condition goroutines and the main tick() both read/modify the same bead concurrently, race conditions occur.\n\n## Fix\nAdd a `copyBead()` function similar to `copyAgent()` and use it in Get():\n```go\nreturn copyBead(bead), nil\n```\n\n## Severity\nLOW-MEDIUM - Defensive improvement, potential race condition","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-08T02:23:30.639242643-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:32:55.392877006-05:00","closed_at":"2026-01-08T02:32:55.392877006-05:00","close_reason":"Fixed: Get() now returns a copy via copyBead() to prevent internal state mutation"}
{"id":"meow-j5e","title":"Loader: Reference Resolution","description":"Extend template loader for module references (.local, file#workflow). Phase 2.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.747251448-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:38:25.747251448-05:00"}
{"id":"meow-ks2","title":"Track agents from start beads","description":"Identify agents from start beads for wisp detection. See IMPLEMENTATION-PLAN section meow-modules-baker-agents.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.698904749-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:16:29.623052672-05:00","closed_at":"2026-01-07T18:16:29.623052672-05:00","close_reason":"YAGNI - With simplified tier detection, we don't scan for start beads. Tier is determined by workflow.Ephemeral property. Task types in ephemeral workflows are wisps, non-task types are orchestrator. Simple.","dependencies":[{"issue_id":"meow-ks2","depends_on_id":"meow-a85","type":"blocks","created_at":"2026-01-07T16:40:07.363200154-05:00","created_by":"ubuntu"},{"issue_id":"meow-ks2","depends_on_id":"meow-7x5","type":"blocks","created_at":"2026-01-07T16:40:07.474555034-05:00","created_by":"ubuntu"}]}
{"id":"meow-l0l","title":"Implement meow trace command","description":"## Current State\n\nThe `meow trace` command is a stub that prints \"not yet implemented\".\n\n## Required Functionality\n\nShow execution trace for debugging:\n\n```bash\nmeow trace\n# Output: Recent orchestrator activity\n\nmeow trace --follow  # Stream live trace\nmeow trace --bead \u003cid\u003e  # Trace specific bead\n```\n\n## Implementation\n\nThe trace infrastructure exists in `internal/orchestrator/trace.go`:\n- `Tracer` - records events to JSONL\n- Trace file at `.meow/state/trace.jsonl`\n\n## File\n`cmd/meow/cmd/trace.go`\n\n## Acceptance Criteria\n- [ ] Reads trace.jsonl file\n- [ ] Formats events nicely\n- [ ] Filter by bead ID option\n- [ ] Follow mode for live streaming","status":"closed","priority":2,"issue_type":"task","assignee":"agent3","created_at":"2026-01-08T03:04:40.930748503-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:31.016708684-05:00","closed_at":"2026-01-08T03:27:31.016708684-05:00","close_reason":"Closed","labels":["cli","debugging"]}
{"id":"meow-lxc","title":"Handle attach_wisp in handleStart","description":"Bake wisp template when start bead has attach_wisp. See IMPLEMENTATION-PLAN section meow-modules-orch-start.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.479863641-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:13:19.127971464-05:00","closed_at":"2026-01-07T18:13:19.127971464-05:00","close_reason":"YAGNI - attach_wisp is over-engineered. Auto-detection via ephemeral=true workflow property plus hooks_to for HookBead linking handles all real use cases. No concrete example where explicit attachment is needed. Can resurrect if a real use case emerges.","dependencies":[{"issue_id":"meow-lxc","depends_on_id":"meow-d1h","type":"blocks","created_at":"2026-01-07T16:39:47.52454027-05:00","created_by":"ubuntu"}]}
{"id":"meow-m3k","title":"Implement local reference resolution","description":"Resolve .workflow local references within module. See IMPLEMENTATION-PLAN section meow-modules-loader-local.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.416312985-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:17:49.541826373-05:00","dependencies":[{"issue_id":"meow-m3k","depends_on_id":"meow-40s","type":"blocks","created_at":"2026-01-07T16:39:46.880060673-05:00","created_by":"ubuntu"}]}
{"id":"meow-mwc","title":"Implement meow steps command","description":"List all wisp steps for current agent. See IMPLEMENTATION-PLAN section meow-modules-cli-steps.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:24.968274416-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:39:24.968274416-05:00","dependencies":[{"issue_id":"meow-mwc","depends_on_id":"meow-97m","type":"blocks","created_at":"2026-01-07T16:39:47.80486772-05:00","created_by":"ubuntu"}]}
{"id":"meow-n58","title":"Define resource limits configuration","description":"# Define Resource Limits Configuration\n\n## File: internal/config/limits.go\n\n## Purpose\n\nParse resource limits from .meow/config.toml to prevent runaway workflows from exhausting system resources.\n\n## Configuration Format\n\n\\`\\`\\`toml\n# .meow/config.toml\n\n[limits]\nmax_expansion_depth = 50       # Maximum nested expand/branch calls\nmax_total_steps = 1000         # Maximum steps in a single workflow\nmax_workflow_file_size = \"10MB\"  # Maximum workflow YAML file size\n\\`\\`\\`\n\n## Implementation\n\n\\`\\`\\`go\npackage config\n\n// Limits defines resource constraints for workflows.\ntype Limits struct {\n    MaxExpansionDepth    int    \\`toml:\"max_expansion_depth\"\\`\n    MaxTotalSteps        int    \\`toml:\"max_total_steps\"\\`\n    MaxWorkflowFileSize  string \\`toml:\"max_workflow_file_size\"\\`  // Parsed to bytes\n    maxFileSizeBytes     int64  // Computed from MaxWorkflowFileSize\n}\n\n// DefaultLimits returns generous defaults that should never trigger normally.\nfunc DefaultLimits() Limits {\n    return Limits{\n        MaxExpansionDepth:   100,\n        MaxTotalSteps:       10000,\n        MaxWorkflowFileSize: \"50MB\",\n        maxFileSizeBytes:    50 * 1024 * 1024,\n    }\n}\n\n// ParseFileSize converts human-readable sizes like \"10MB\" to bytes.\nfunc ParseFileSize(s string) (int64, error) {\n    // Handle KB, MB, GB suffixes\n    s = strings.ToUpper(strings.TrimSpace(s))\n    var multiplier int64 = 1\n    \n    if strings.HasSuffix(s, \"KB\") {\n        multiplier = 1024\n        s = strings.TrimSuffix(s, \"KB\")\n    } else if strings.HasSuffix(s, \"MB\") {\n        multiplier = 1024 * 1024\n        s = strings.TrimSuffix(s, \"MB\")\n    } else if strings.HasSuffix(s, \"GB\") {\n        multiplier = 1024 * 1024 * 1024\n        s = strings.TrimSuffix(s, \"GB\")\n    }\n    \n    n, err := strconv.ParseInt(strings.TrimSpace(s), 10, 64)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid size: %s\", s)\n    }\n    \n    return n * multiplier, nil\n}\n\n// Validate checks limits are reasonable and computes derived values.\nfunc (l *Limits) Validate() error {\n    if l.MaxExpansionDepth \u003c= 0 {\n        return fmt.Errorf(\"max_expansion_depth must be positive\")\n    }\n    if l.MaxTotalSteps \u003c= 0 {\n        return fmt.Errorf(\"max_total_steps must be positive\")\n    }\n    \n    bytes, err := ParseFileSize(l.MaxWorkflowFileSize)\n    if err != nil {\n        return fmt.Errorf(\"invalid max_workflow_file_size: %w\", err)\n    }\n    l.maxFileSizeBytes = bytes\n    \n    return nil\n}\n\n// MaxFileSizeBytes returns the file size limit in bytes.\nfunc (l *Limits) MaxFileSizeBytes() int64 {\n    return l.maxFileSizeBytes\n}\n\\`\\`\\`\n\n## Config Loading\n\n\\`\\`\\`go\n// Config is the full .meow/config.toml structure.\ntype Config struct {\n    Limits Limits \\`toml:\"limits\"\\`\n    // Other config sections...\n}\n\n// LoadConfig reads config from .meow/config.toml.\nfunc LoadConfig(dir string) (*Config, error) {\n    path := filepath.Join(dir, \"config.toml\")\n    \n    cfg := \u0026Config{\n        Limits: DefaultLimits(),\n    }\n    \n    data, err := os.ReadFile(path)\n    if os.IsNotExist(err) {\n        // No config file, use defaults\n        return cfg, nil\n    }\n    if err != nil {\n        return nil, fmt.Errorf(\"reading config: %w\", err)\n    }\n    \n    if err := toml.Unmarshal(data, cfg); err != nil {\n        return nil, fmt.Errorf(\"parsing config: %w\", err)\n    }\n    \n    if err := cfg.Limits.Validate(); err != nil {\n        return nil, fmt.Errorf(\"invalid limits: %w\", err)\n    }\n    \n    return cfg, nil\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Limits struct with all fields\n- [ ] DefaultLimits() returns generous defaults\n- [ ] ParseFileSize() handles KB, MB, GB\n- [ ] Validate() computes derived values\n- [ ] LoadConfig() reads from .meow/config.toml\n- [ ] Missing config file uses defaults\n- [ ] Unit tests for ParseFileSize\n- [ ] Unit tests for config loading","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T20:27:23.79889102-05:00","created_by":"ubuntu","updated_at":"2026-01-08T20:27:23.79889102-05:00","dependencies":[{"issue_id":"meow-n58","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T20:29:48.158644015-05:00","created_by":"ubuntu"}]}
{"id":"meow-nr7","title":"Create call pattern template","description":"Parent/child orchestration with attach_wisp. See IMPLEMENTATION-PLAN.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.576149517-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:39:25.576149517-05:00","dependencies":[{"issue_id":"meow-nr7","depends_on_id":"meow-5u6","type":"blocks","created_at":"2026-01-07T16:39:48.177947179-05:00","created_by":"ubuntu"}]}
{"id":"meow-nsv","title":"Module System and Three-Tier Architecture","description":"Root epic for the module system and three-tier bead architecture. See docs/IMPLEMENTATION-PLAN-MODULES-AND-WISPS.md for full details.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:16.142778125-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:38:16.142778125-05:00"}
{"id":"meow-o7a","title":"orchestrator.go: Race condition in evalCondition() bead mutation","description":"## Location\n`internal/orchestrator/orchestrator.go:471-579`\n\n## Problem\n`evalCondition()` runs in a goroutine and mutates the bead object, then calls `store.Update()`. If the main loop's `tick()` reads the same bead concurrently, there's a race condition.\n\nFlow:\n1. `handleCondition()` marks bead as in_progress and spawns goroutine\n2. Goroutine runs `evalCondition()` which:\n   - Executes shell command (can take arbitrary time)\n   - Calls `bead.Close(nil)` - **mutates the bead**\n   - Calls `store.Update(ctx, bead)` - persists\n3. Meanwhile, main loop continues with `tick()`\n4. If tick() calls `GetNextReady()` which iterates beads, race on bead fields\n\nThe store uses locks for its internal map, but the **bead object itself is shared**.\n\n## Evidence\n```go\n// handleCondition spawns goroutine\ngo func() {\n    o.evalCondition(condCtx, bead)  // bead is a pointer\n}()\n\n// evalCondition mutates the bead\nif err := bead.Close(nil); err != nil {  // Mutation!\n    ...\n}\nif err := o.store.Update(ctx, bead); err != nil {\n    ...\n}\n```\n\n## Fix Options\n1. **Copy bead for goroutine**: Pass a copy, Update() stores the copy\n2. **Get fresh bead before mutation**: Re-fetch from store before Close()\n3. **Add bead-level locking**: More complex, probably overkill\n\n## Severity\nMEDIUM - Race condition under concurrent condition evaluation","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:31.808052643-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:33:02.083295535-05:00","closed_at":"2026-01-08T02:33:02.083295535-05:00","close_reason":"Fixed in commit 5ea5226. Changed evalCondition() signature to take beadID and spec instead of bead pointer."}
{"id":"meow-p84","title":"Set HookBead links from variables","description":"Set HookBead links using workflow.HooksTo property per SPEC-ADDENDUM.\n\n## The hooks_to Property\n\nWorkflows declare which variable contains the work bead ID:\n\n```toml\n[implement]\nhooks_to = \"work_bead\"  # All wisps from this workflow link to {{work_bead}}\n\n[implement.variables]\nwork_bead = { required = true, type = \"bead_id\" }\n```\n\n## Baker Implementation\n\n```go\nfunc (b *Baker) setHookBead(bead *types.Bead, workflow *Workflow, vars map[string]string) {\n    // Only wisps get HookBead links\n    if bead.Tier != TierWisp {\n        return\n    }\n    \n    // Use workflow.HooksTo to find the variable name\n    if workflow.HooksTo == \"\" {\n        return  // No explicit linking\n    }\n    \n    // Get the bead ID from the variable\n    if hookID, ok := vars[workflow.HooksTo]; ok {\n        bead.HookBead = hookID\n    }\n}\n```\n\n## Key Change from Original Plan\n\n- **Before**: Magic detection via \"work_bead\" variable name\n- **After**: Explicit declaration via `workflow.HooksTo` property\n\n## File Location\nModify: `internal/template/baker.go`\n\n## Acceptance Criteria\n- [ ] Read HooksTo from workflow struct\n- [ ] Set HookBead only for wisp tier beads\n- [ ] Validate that HooksTo variable exists\n- [ ] Unit tests for HookBead linking","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:06.077463505-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:17:11.683209007-05:00","closed_at":"2026-01-07T18:17:11.683209007-05:00","close_reason":"Covered by meow-cac (vertical slice) which includes HookBead setting from hooks_to. Validation of HooksTo variable existence is part of module parsing in meow-ao5.","dependencies":[{"issue_id":"meow-p84","depends_on_id":"meow-cxt","type":"blocks","created_at":"2026-01-07T16:39:47.43086697-05:00","created_by":"ubuntu"},{"issue_id":"meow-p84","depends_on_id":"meow-8x2","type":"blocks","created_at":"2026-01-07T17:53:27.991474029-05:00","created_by":"ubuntu"}]}
{"id":"meow-p90","title":"module.go: Condition branch targets (on_true/on_false/on_timeout) not parsed","description":"## Location\n`internal/template/module.go:200-261`\n\n## Problem\nThe `parseModuleStep()` function does NOT parse `on_true`, `on_false`, or `on_timeout` fields from the step data map. These fields exist in the Step struct (parser.go:69-72) but are never extracted during module format parsing.\n\n## Impact\n- Condition beads in module-format templates will have nil branch targets\n- All conditional logic in module-format workflows is broken\n- Loops, gates, and branching patterns won't work\n\n## Expected Behavior\nThe parser should extract these fields:\n- `data[\"on_true\"]` → step.OnTrue\n- `data[\"on_false\"]` → step.OnFalse  \n- `data[\"on_timeout\"]` → step.OnTimeout\n\n## Severity\nHIGH - Core workflow functionality broken","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T02:22:25.442556921-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:35:17.508768962-05:00","closed_at":"2026-01-08T02:35:17.508768962-05:00","close_reason":"Fixed: Added parsing of on_true, on_false, and on_timeout fields in parseModuleStep()"}
{"id":"meow-sqc","title":"Types: Three-Tier Bead Metadata","description":"Extend bead types for three-tier visibility model. Phase 1 foundation.","notes":"Updated for SPEC-ADDENDUM refinements (2026-01-07):\n- Closed meow-db2 (hooked status removed from spec)\n- Added meow-x9z (gate bead type)  \n- Added meow-1l1 (collaborative bead type for interactive steps)\n- meow-bba now includes explicit Tier field and all 8 bead types\n- Labels are optional, Tier field is primary\n\nThe 8 bead types are now:\n- Agent-executable: task, collaborative, gate\n- Orchestrator-executable: start, stop, condition, code, expand","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.65411519-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:00:44.047875427-05:00"}
{"id":"meow-v5j","title":"Implement resource limits enforcement","description":"# Implement Resource Limits Enforcement\n\n## File: internal/orchestrator/limits.go\n\n## Purpose\n\nEnforce resource limits during workflow execution to prevent runaway expansions and resource exhaustion.\n\n## Enforcement Points\n\n### 1. Expansion Depth (in expand/branch executors)\n\n\\`\\`\\`go\n// ExpansionContext tracks depth during recursive expansion.\ntype ExpansionContext struct {\n    Depth    int\n    MaxDepth int\n}\n\nfunc (e *ExpandExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow, expCtx *ExpansionContext) error {\n    // Check depth limit\n    if expCtx.Depth \u003e= expCtx.MaxDepth {\n        return \u0026LimitExceededError{\n            Limit: \"max_expansion_depth\",\n            Value: expCtx.Depth,\n            Max:   expCtx.MaxDepth,\n        }\n    }\n    \n    // Increment depth for child expansions\n    childCtx := \u0026ExpansionContext{\n        Depth:    expCtx.Depth + 1,\n        MaxDepth: expCtx.MaxDepth,\n    }\n    \n    // ... expand template with childCtx ...\n}\n\\`\\`\\`\n\n### 2. Total Steps (after each expansion)\n\n\\`\\`\\`go\nfunc (e *ExpandExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow, expCtx *ExpansionContext) error {\n    // ... expand template ...\n    \n    // Check total steps\n    if len(wf.Steps) \u003e e.limits.MaxTotalSteps {\n        return \u0026LimitExceededError{\n            Limit: \"max_total_steps\",\n            Value: len(wf.Steps),\n            Max:   e.limits.MaxTotalSteps,\n        }\n    }\n}\n\\`\\`\\`\n\n### 3. Workflow File Size (before persist)\n\n\\`\\`\\`go\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow, limits *config.Limits) error {\n    data, err := yaml.Marshal(wf)\n    if err != nil {\n        return fmt.Errorf(\"marshaling workflow: %w\", err)\n    }\n    \n    // Check file size\n    if int64(len(data)) \u003e limits.MaxFileSizeBytes() {\n        return \u0026LimitExceededError{\n            Limit: \"max_workflow_file_size\",\n            Value: int(len(data)),\n            Max:   int(limits.MaxFileSizeBytes()),\n        }\n    }\n    \n    // ... atomic write ...\n}\n\\`\\`\\`\n\n## Error Type\n\n\\`\\`\\`go\n// LimitExceededError indicates a resource limit was hit.\ntype LimitExceededError struct {\n    Limit string // Which limit: max_expansion_depth, max_total_steps, max_workflow_file_size\n    Value int    // Current value\n    Max   int    // Configured maximum\n}\n\nfunc (e *LimitExceededError) Error() string {\n    return fmt.Sprintf(\"%s exceeded: %d (max: %d)\", e.Limit, e.Value, e.Max)\n}\n\n// IsLimitExceeded checks if an error is a limit exceeded error.\nfunc IsLimitExceeded(err error) bool {\n    var le *LimitExceededError\n    return errors.As(err, \u0026le)\n}\n\\`\\`\\`\n\n## Orchestrator Integration\n\n\\`\\`\\`go\nfunc (o *Orchestrator) executeStep(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    err := o.dispatchers[step.Executor].Execute(ctx, step, wf, o.expCtx)\n    \n    if IsLimitExceeded(err) {\n        // Limit hit - fail the step\n        step.Fail(\u0026types.StepError{\n            Message: err.Error(),\n        })\n        \n        // Check on_error behavior\n        if step.Shell != nil \u0026\u0026 step.Shell.OnError == \"continue\" {\n            return nil // Continue despite limit\n        }\n        \n        // Default: fail the workflow\n        wf.Fail()\n        return err\n    }\n    \n    return err\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] ExpansionContext tracks depth\n- [ ] Expand/branch executors check depth limit\n- [ ] Total steps checked after expansion\n- [ ] File size checked before persist\n- [ ] LimitExceededError type with clear messages\n- [ ] Integration with orchestrator error handling\n- [ ] on_error: continue respects limits (step fails but workflow continues)\n- [ ] Unit tests for each enforcement point\n- [ ] Integration test hitting each limit type","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T20:27:47.486522459-05:00","created_by":"ubuntu","updated_at":"2026-01-08T20:27:47.486522459-05:00","dependencies":[{"issue_id":"meow-v5j","depends_on_id":"meow-n58","type":"blocks","created_at":"2026-01-08T20:29:48.25269027-05:00","created_by":"ubuntu"},{"issue_id":"meow-v5j","depends_on_id":"pivot-405","type":"blocks","created_at":"2026-01-08T20:29:48.347185036-05:00","created_by":"ubuntu"}]}
{"id":"meow-vvt","title":"Parser: Multi-Workflow Module Support","description":"Extend template parser for multi-workflow module files. Phase 1 foundation.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.560890598-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:38:25.560890598-05:00"}
{"id":"meow-we4","title":"CLI: Wisp-Aware Commands","description":"Implement CLI commands that understand three-tier model. Phase 4.","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:26.03538728-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:38:26.03538728-05:00"}
{"id":"meow-wtb","title":"Implement meow validate command","description":"## Current State\n\nThe `meow validate` command is a stub that prints \"not yet implemented\":\n\n```go\n// cmd/meow/cmd/validate.go:36-37\nfmt.Printf(\"Validating template: %s\\n\", template)\nfmt.Println(\"(not yet implemented)\")\n```\n\n## Required Functionality\n\nThe command should validate templates without executing them:\n\n```bash\nmeow validate template.toml\n# Output:\n# ✓ TOML syntax valid\n# ✓ Required fields present  \n# ✓ Variable references valid\n# ✓ No dependency cycles\n# ✓ Output references valid\n# Template is valid!\n```\n\n## Implementation\n\nThe validation logic already exists in `internal/template/validate.go`:\n- `ValidateFull()` - comprehensive validation\n- `ValidateSteps()` - step validation\n- `ValidateOutput()` - output validation\n\nJust need to wire it up to the CLI command.\n\n## File\n`cmd/meow/cmd/validate.go`\n\n## Acceptance Criteria\n- [ ] Loads template (module or legacy format)\n- [ ] Runs full validation\n- [ ] Reports all errors found (not just first)\n- [ ] Returns non-zero exit code on failure","status":"closed","priority":2,"issue_type":"task","assignee":"agent1","created_at":"2026-01-08T03:04:06.215882961-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:28:44.807161953-05:00","closed_at":"2026-01-08T03:28:44.807161953-05:00","close_reason":"Closed","labels":["cli"]}
{"id":"meow-x9z","title":"Add BeadTypeGate for human approval points","description":"Add new `gate` bead type per SPEC-ADDENDUM-WISPS-AND-MODULES.md (lines 214-231).\n\n## The Gate Type\n\n`gate` replaces the `orchestrator_task` boolean flag for human approval points:\n\n```go\nconst (\n    // Agent-executable\n    BeadTypeTask          BeadType = \"task\"          // Agent does work, auto-continues\n    BeadTypeCollaborative BeadType = \"collaborative\" // Agent + human conversation, pauses\n    BeadTypeGate          BeadType = \"gate\"          // Human approval point (no assignee)\n    \n    // Orchestrator-executable\n    BeadTypeStart     BeadType = \"start\"\n    BeadTypeStop      BeadType = \"stop\"\n    BeadTypeCondition BeadType = \"condition\"\n    BeadTypeCode      BeadType = \"code\"\n    BeadTypeExpand    BeadType = \"expand\"\n)\n```\n\n## Type Behavior Summary\n\n| Type | Assignee | Auto-continue | Who closes | Use case |\n|------|----------|---------------|------------|----------|\n| `task` | Required | Yes (Ralph Wiggum) | Agent | Normal autonomous work |\n| `collaborative` | Required | No (pauses) | Agent | Design review, clarification |\n| `gate` | None | No | Human | Approval checkpoints |\n\n## Gate Characteristics\n\n- **No assignee** - Human-facing, not agent-facing\n- **Tier: orchestrator** - Infrastructure machinery\n- **Orchestrator waits** - Like condition but requires human action\n- **No agent visibility** - Never shown in `meow prime`\n\n## Usage in Templates\n\n```toml\n[[workflow.steps]]\nid = \"human-review\"\ntype = \"gate\"\ntitle = \"Review implementation before merge\"\ninstructions = \"Check code quality, test coverage, and documentation\"\n# No assignee field - gates are human-facing\n```\n\n## File Location\nModify: `internal/types/bead.go`\n\n## Acceptance Criteria\n- [ ] BeadTypeGate constant added\n- [ ] Valid() updated to include gate\n- [ ] Gate validation: must NOT have assignee\n- [ ] Unit tests for gate type\n- [ ] Documentation updated","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T17:52:42.000899283-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:14:53.101991604-05:00","closed_at":"2026-01-07T18:14:53.101991604-05:00","close_reason":"Consolidated into meow-bba. The gate type is now part of the unified Bead struct changes task.","dependencies":[{"issue_id":"meow-x9z","depends_on_id":"meow-bba","type":"blocks","created_at":"2026-01-07T17:53:22.585095288-05:00","created_by":"ubuntu"}]}
{"id":"meow-xju","title":"Implement meow continue for crash recovery","description":"Resume interrupted workflow from persisted state. See IMPLEMENTATION-PLAN section meow-modules-cli-continue.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.229851616-05:00","created_by":"ubuntu","updated_at":"2026-01-07T16:39:25.229851616-05:00","dependencies":[{"issue_id":"meow-xju","depends_on_id":"meow-97m","type":"blocks","created_at":"2026-01-07T16:39:47.989804784-05:00","created_by":"ubuntu"}]}
{"id":"meow-xkz","title":"Implement variable substitution with shell escaping","description":"# Implement Variable Substitution with Shell Escaping\n\n## File: internal/template/substitute.go\n\n## Purpose\n\nReplace \\`{{variable}}\\` references in templates with actual values. Includes:\n- Missing variable detection (fail loudly)\n- Shell context escaping for command/condition fields\n\n## Implementation\n\n\\`\\`\\`go\npackage template\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n\nvar varPattern = regexp.MustCompile(\\`\\{\\{([^}]+)\\}\\}\\`)\n\n// SubstitutionContext provides values for variable replacement.\ntype SubstitutionContext struct {\n    Variables map[string]string   // From workflow vars + meow run --var\n    Outputs   map[string]any      // From completed step outputs\n    Builtins  map[string]string   // workflow_id, timestamp, date\n}\n\n// SubstituteError indicates a variable could not be resolved.\ntype SubstituteError struct {\n    Variable string\n    Context  string // Where it was referenced (step ID, field name)\n}\n\nfunc (e *SubstituteError) Error() string {\n    return fmt.Sprintf(\"undefined variable: %s (in %s)\", e.Variable, e.Context)\n}\n\n// Substitute replaces all {{var}} references in a string.\n// Returns error if any variable is undefined.\nfunc Substitute(template string, ctx *SubstitutionContext, context string) (string, error) {\n    var errs []error\n    \n    result := varPattern.ReplaceAllStringFunc(template, func(match string) string {\n        // Extract variable name from {{name}}\n        varName := strings.TrimSpace(match[2 : len(match)-2])\n        \n        value, err := ctx.Resolve(varName)\n        if err != nil {\n            errs = append(errs, \u0026SubstituteError{Variable: varName, Context: context})\n            return match // Leave unreplaced for error message\n        }\n        \n        return value\n    })\n    \n    if len(errs) \u003e 0 {\n        return \"\", errs[0] // Return first error\n    }\n    \n    return result, nil\n}\n\n// SubstituteShell replaces variables with shell-escaped values.\n// Use for command and condition fields to prevent injection.\nfunc SubstituteShell(template string, ctx *SubstitutionContext, context string) (string, error) {\n    var errs []error\n    \n    result := varPattern.ReplaceAllStringFunc(template, func(match string) string {\n        varName := strings.TrimSpace(match[2 : len(match)-2])\n        \n        value, err := ctx.Resolve(varName)\n        if err != nil {\n            errs = append(errs, \u0026SubstituteError{Variable: varName, Context: context})\n            return match\n        }\n        \n        // Shell-escape the value\n        return ShellEscape(value)\n    })\n    \n    if len(errs) \u003e 0 {\n        return \"\", errs[0]\n    }\n    \n    return result, nil\n}\n\n// ShellEscape quotes a string for safe shell use.\n// Uses single quotes and escapes embedded single quotes.\nfunc ShellEscape(s string) string {\n    // If empty, return empty quoted string\n    if s == \"\" {\n        return \"''\"\n    }\n    \n    // If no special characters, return as-is\n    if !needsEscaping(s) {\n        return s\n    }\n    \n    // Wrap in single quotes, escape embedded single quotes\n    // '\\'' = end quote, literal single quote, start quote\n    escaped := strings.ReplaceAll(s, \"'\", \"'\\\\''\")\n    return \"'\" + escaped + \"'\"\n}\n\nfunc needsEscaping(s string) bool {\n    for _, c := range s {\n        switch c {\n        case ' ', '\\t', '\\n', '\\\\', '\"', '\\'', '\\`', '$', '!', '\u0026', '|', ';', '(', ')', '\u003c', '\u003e', '*', '?', '[', ']', '{', '}', '#', '~', '=':\n            return true\n        }\n    }\n    return false\n}\n\n// Resolve looks up a variable value.\nfunc (ctx *SubstitutionContext) Resolve(name string) (string, error) {\n    // Check for output reference: step_id.outputs.field\n    if strings.Contains(name, \".outputs.\") {\n        return ctx.resolveOutput(name)\n    }\n    \n    // Check builtins\n    if v, ok := ctx.Builtins[name]; ok {\n        return v, nil\n    }\n    \n    // Check workflow variables\n    if v, ok := ctx.Variables[name]; ok {\n        return v, nil\n    }\n    \n    return \"\", fmt.Errorf(\"undefined: %s\", name)\n}\n\nfunc (ctx *SubstitutionContext) resolveOutput(name string) (string, error) {\n    // Parse step_id.outputs.field\n    parts := strings.SplitN(name, \".outputs.\", 2)\n    if len(parts) != 2 {\n        return \"\", fmt.Errorf(\"invalid output reference: %s\", name)\n    }\n    \n    stepID := parts[0]\n    field := parts[1]\n    \n    stepOutputs, ok := ctx.Outputs[stepID]\n    if !ok {\n        return \"\", fmt.Errorf(\"no outputs for step: %s\", stepID)\n    }\n    \n    outputMap, ok := stepOutputs.(map[string]any)\n    if !ok {\n        return \"\", fmt.Errorf(\"invalid outputs for step: %s\", stepID)\n    }\n    \n    value, ok := outputMap[field]\n    if !ok {\n        return \"\", fmt.Errorf(\"no output %s in step %s\", field, stepID)\n    }\n    \n    return fmt.Sprintf(\"%v\", value), nil\n}\n\\`\\`\\`\n\n## Usage in Template Processing\n\n\\`\\`\\`go\n// For prompts, template references, etc. (no escaping)\nprompt, err := Substitute(step.Agent.Prompt, ctx, step.ID+\".prompt\")\nif err != nil {\n    // Fail the step - missing variable\n    return err\n}\n\n// For shell commands and conditions (with escaping)\ncommand, err := SubstituteShell(step.Shell.Command, ctx, step.ID+\".command\")\nif err != nil {\n    return err\n}\n\ncondition, err := SubstituteShell(step.Branch.Condition, ctx, step.ID+\".condition\")\nif err != nil {\n    return err\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Substitute() replaces all {{var}} references\n- [ ] SubstituteShell() escapes values for safe shell use\n- [ ] SubstituteError for undefined variables\n- [ ] ShellEscape() properly quotes values\n- [ ] Resolve() handles workflow vars, builtins, and outputs\n- [ ] Output reference parsing (step.outputs.field)\n- [ ] Unit tests for normal substitution\n- [ ] Unit tests for shell escaping edge cases\n- [ ] Unit tests for missing variable detection\n- [ ] Unit tests for output references","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T20:28:20.351021048-05:00","created_by":"ubuntu","updated_at":"2026-01-08T20:28:20.351021048-05:00","dependencies":[{"issue_id":"meow-xkz","depends_on_id":"pivot-104","type":"blocks","created_at":"2026-01-08T20:29:48.44675419-05:00","created_by":"ubuntu"}]}
{"id":"meow-y9d","title":"meow run: orchestrator integration issues","description":"## Summary\n\nTesting `meow run` with a sample template revealed multiple issues in the orchestrator-agent integration. Some were fixed during this session, others remain.\n\n## Issues Fixed\n\n### 1. Orchestrator processed all beads, not just workflow beads\n**Location:** `internal/orchestrator/beadstore.go:106-131`\n**Problem:** `GetNextReady()` and `AllDone()` returned/checked ALL beads including issue tracker beads (which have no Type field).\n**Fix:** Added check `if bead.Type == \"\"` to skip non-workflow beads.\n\n### 2. TmuxManager.Start not idempotent\n**Location:** `internal/agent/tmux.go:125-157`\n**Problem:** If a tmux session already existed (from previous run), Start failed with \"session already exists\" and kept retrying forever.\n**Fix:** Added SessionExists check at start - if session exists, track the agent and return success.\n\n### 3. SendKeys not pressing Enter properly\n**Location:** `internal/agent/tmux_wrapper.go:162-184`\n**Problem:** `tmux send-keys` wasn't pressing Enter because text and Enter were sent as single command args, which tmux interprets differently.\n**Fix:** Split into two calls: first send text with `-l` flag (literal), then send Enter separately.\n\n### 4. MEOW_AGENT env var not set for spawned agents\n**Location:** `internal/template/baker.go:485-494`\n**Problem:** `meow prime` couldn't identify which agent was asking because MEOW_AGENT wasn't set.\n**Fix:** Added `Env: map[string]string{\"MEOW_AGENT\": bead.Assignee}` to StartSpec.\n\n### 5. Startup delay too short\n**Location:** `internal/agent/tmux.go:177-179`\n**Problem:** 500ms wasn't enough for Claude to fully initialize before receiving prompt.\n**Fix:** Increased to 5 seconds.\n\n## Issues Remaining\n\n### 1. Tier field not serialized to JSON (CRITICAL)\n**Location:** `internal/template/baker.go` and/or bead serialization\n**Problem:** Despite `determineTier()` returning `TierWisp` for ephemeral workflow tasks, the Tier field is missing from serialized beads in `.beads/issues.jsonl`.\n**Impact:** `meow prime` filters by `Tier: types.TierWisp` so it can't find the agent's tasks, returning \"No tasks assigned to this agent.\"\n**Debug info:** The `labels` field shows `[\"meow:ephemeral\"]` correctly, but `tier` field is absent.\n**Needs investigation:** Check if Tier is being set but not persisted, or if there's a serialization issue.\n\n### 2. meow prime can't find assigned tasks\n**Related to:** Tier field issue above\n**Symptom:** Agent runs `meow prime`, gets \"No tasks assigned to this agent\" even though `bd list --status=in_progress` shows the task correctly assigned.\n\n## Test Template Used\n\n`.meow/templates/hello-test.meow.toml` with `--var agent=\u003ctest-agent\u003e`\n\n## Files Modified\n\n- `internal/orchestrator/beadstore.go` - Bead filtering\n- `internal/agent/tmux.go` - Idempotent start, longer delay\n- `internal/agent/tmux_wrapper.go` - SendKeys fix\n- `internal/template/baker.go` - MEOW_AGENT env var\n\n## Verification\n\nAfter fixes, the orchestrator:\n- Correctly dispatches only workflow beads\n- Creates tmux sessions with Claude\n- Sends `meow prime` command which executes\n- Claude agent starts processing\n\nBut the agent can't find its assigned work due to the Tier serialization bug.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T03:58:37.384236655-05:00","created_by":"ubuntu","updated_at":"2026-01-08T16:27:32.749527775-05:00","closed_at":"2026-01-08T16:27:32.749527775-05:00","close_reason":"Pivoted approach: Instead of fixing tier field serialization (band-aid), we're redesigning MEOW to own its bead storage completely. See meow-g5s for the new research task."}
{"id":"meow-ym3","title":"Implement wisp lifecycle management (burn/squash)","description":"Implement wisp cleanup per SPEC-ADDENDUM (lines 859-904).\n\n## When Wisps Get Burned\n\n- **On workflow completion** (all beads in workflow are closed)\n- **NOT on agent stop** (agent might resume)\n- **NOT on work bead close** (workflow machinery still needed)\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) cleanupWorkflow(ctx context.Context, workflowID string) error {\n    beads, _ := o.store.List(ctx, BeadFilter{\n        WorkflowID: workflowID,\n    })\n    \n    // Check if all beads are closed\n    allClosed := true\n    for _, bead := range beads {\n        if bead.Status != StatusClosed {\n            allClosed = false\n            break\n        }\n    }\n    \n    if allClosed {\n        // Delete non-work beads (wisps and orchestrator)\n        for _, bead := range beads {\n            if bead.Tier != TierWork {\n                _ = o.store.Delete(ctx, bead.ID)\n            }\n        }\n    }\n    \n    return nil\n}\n```\n\n## Cleanup Options\n\n```toml\n# .meow/config.toml\n[cleanup]\nephemeral = \"on_complete\"  # on_complete | manual | never\n```\n\n## Squash to Digest (Optional)\n\nBefore burning, optionally create a summary:\n```go\nfunc (o *Orchestrator) squashWisps(ctx context.Context, workflowID string, workBeadID string) error {\n    wisps, _ := o.store.List(ctx, BeadFilter{\n        WorkflowID: workflowID,\n        Tier:       TierWisp,\n    })\n    \n    // Generate digest\n    digest := generateDigest(wisps)\n    \n    // Append to work bead notes\n    workBead, _ := o.store.Get(ctx, workBeadID)\n    workBead.Notes += \"\\n\\n\" + digest\n    o.store.Update(ctx, workBead)\n    \n    // Then burn\n    return o.burnWisps(ctx, workflowID)\n}\n```\n\n## File Location\nModify: `internal/orchestrator/orchestrator.go`\n\n## Acceptance Criteria\n- [ ] cleanupWorkflow() deletes wisps and orchestrator beads\n- [ ] Only cleanup when all workflow beads closed\n- [ ] Work beads preserved\n- [ ] Optional squash to digest before burn\n- [ ] Cleanup triggered after workflow completion","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.725195883-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:28:18.744206271-05:00","closed_at":"2026-01-08T02:28:18.744206271-05:00","close_reason":"Implemented tier-based wisp lifecycle management: cleanupWorkflow() burns wisps/orchestrator on workflow completion, squashWisps() creates digest before burning, updated Run() to use tier-based cleanup, comprehensive unit tests","dependencies":[{"issue_id":"meow-ym3","depends_on_id":"meow-cac","type":"blocks","created_at":"2026-01-07T18:15:49.00538433-05:00","created_by":"ubuntu"},{"issue_id":"meow-ym3","depends_on_id":"meow-dax","type":"blocks","created_at":"2026-01-07T18:19:40.710726869-05:00","created_by":"ubuntu"}]}
{"id":"meow-zva","title":"Bug: Code bead code field not substituted in baker","description":"## Problem\n\nIn `internal/template/baker.go`, the module-format code path in `workflowStepToBead()` manually substitutes title, instructions, and assignee, but then passes the ORIGINAL `step` (not substituted) to `setTypeSpec()`:\n\n```go\n// Line 252 in workflowStepToBead:\nif err := b.setTypeSpec(bead, step, stepToID); err != nil {  // ← original step!\n```\n\nMeanwhile, the legacy path at line 368 correctly uses the substituted step:\n```go\n// Line 368 in legacyStepToBead:\nif err := b.setTypeSpec(bead, subbed, stepToID); err != nil {  // ← substituted!\n```\n\n## Impact\n\nVariables like \\`{{test_name}}\\` appear literally in:\n- Code field of code beads\n- Condition field of condition beads\n\n## Expected Behavior\n\nThe module format path should either:\n1. Call `SubstituteStep()` before `setTypeSpec()` like the legacy path does\n2. Or substitute code/condition fields alongside title/instructions/assignee\n\n## Files\n- `internal/template/baker.go:252` - `workflowStepToBead()` passes original step\n- `internal/template/baker.go:368` - `legacyStepToBead()` correctly passes substituted step\n- `internal/template/vars.go:299` - `SubstituteStep()` handles Code and Condition correctly\n\n## Acceptance Criteria\n- [ ] Code field in code beads is substituted\n- [ ] Condition field in condition beads is substituted\n- [ ] Test with template containing \\`{{variable}}\\` in code field","status":"closed","priority":1,"issue_type":"bug","assignee":"agent2","created_at":"2026-01-08T03:03:17.455606938-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:32.926736694-05:00","closed_at":"2026-01-08T03:27:32.926736694-05:00","close_reason":"Closed","labels":["baker","bug","module-format"]}
{"id":"meow-zyc","title":"module.go: Task output specifications not parsed","description":"## Location\n`internal/template/module.go:200-261`\n\n## Problem\nThe `parseModuleStep()` function doesn't parse the outputs section for task beads. This means task output specifications can't be defined in module-format templates:\n\n```toml\n[[main.steps]]\nid = \"select-work\"\ntype = \"task\"\ntitle = \"Select next work bead\"\n\n# This section is NEVER parsed:\n[main.steps.outputs]\nrequired = [\n    { name = \"work_bead\", type = \"bead_id\", description = \"The bead to implement\" }\n]\n```\n\n## Impact\n- Cannot define validated outputs in module-format templates\n- Output validation (a key MVP feature per spec) unavailable for module format\n- Agent decisions can't be captured and validated\n\n## Spec Reference\nFrom MVP-SPEC.md:\n\u003e Tasks can require **validated outputs** that Claude must provide when closing. This enables reliable data flow from Claude's decisions to subsequent beads.\n\n## Fix\n1. Add outputs field to Step struct (if not present)\n2. Parse `data[\"outputs\"]` in parseModuleStep()\n3. Convert to TaskOutputSpec for bead creation\n\n## Severity\nMEDIUM - Missing feature for output validation in module format","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:06.870936755-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:35:17.787949507-05:00","closed_at":"2026-01-08T02:35:17.787949507-05:00","close_reason":"Fixed: Added Outputs field to Step struct and parsing for task output specifications in module.go"}
{"id":"pivot-000","title":"EPIC: MVP-SPEC-v2 Pivot - Workflow-Centric Architecture","description":"# The Big Pivot: Bead-Centric → Workflow-Centric\n\n## Background\n\nMEOW Stack started as a bead-aware orchestrator with three tiers (work/wisp/orchestrator). This created:\n- Tight coupling to beads task tracker\n- Conceptual confusion (are we a task tracker or workflow engine?)\n- Complex visibility model agents had to understand\n\n## The New Vision (MVP-SPEC-v2)\n\nMEOW is a **coordination language** for AI agents. Key shifts:\n\n1. **Task-tracking agnostic** - Users bring their own systems (beads, Jira, GitHub, sticky notes)\n2. **Single primitive** - Step with 7 executors (not 8 bead types)\n3. **No tiers** - Workflows are opaque to agents; they see prompts, not internals\n4. **Workflow state files** - YAML per-workflow, not JSONL bead store\n5. **meow done** - Signals step completion (not bead close)\n\n## Scope of This Pivot\n\n- Remove all bead integration code\n- Remove three-tier model (work/wisp/orchestrator)\n- Implement new Step/Workflow types\n- Switch persistence from JSONL to YAML\n- Update CLI commands\n- Update documentation\n\n## Key Documents\n\n- docs/MVP-SPEC-v2.md - The new specification\n- docs/IMPLEMENTATION-GUIDE.md - Detailed implementation guidance\n\n## Success Criteria\n\n- `meow run template.toml` starts a workflow stored in .meow/workflows/*.yaml\n- `meow prime` shows current step prompt to agents\n- `meow done` signals step completion with output validation\n- Workflows execute through all 7 executor types\n- No references to beads/tiers remain in core code","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:00Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00"}
{"id":"pivot-100","title":"EPIC: Type System Refactor","description":"# Type System Refactor\n\n## Why This Comes First\n\nThe type system is the foundation. Every other component depends on Step, Workflow, and ExecutorType definitions. Getting this right enables parallel work on other epics.\n\n## What Changes\n\n### Remove (from internal/types/bead.go)\n- BeadType enum (8 types)\n- BeadTier enum (work/wisp/orchestrator)\n- HookBead, SourceWorkflow fields\n- All type-specific specs (ConditionSpec, etc.)\n- Bead struct entirely (after migration)\n\n### Add (new files)\n- internal/types/executor.go - ExecutorType enum (7 values)\n- internal/types/step.go - Step struct with executor configs\n- internal/types/workflow.go - Workflow struct with state\n\n## The 7 Executors\n\n| Executor | Category | Purpose |\n|----------|----------|--------|\n| shell | Orchestrator | Run shell command, capture outputs |\n| spawn | Orchestrator | Start agent in tmux session |\n| kill | Orchestrator | Stop agent's tmux session |\n| expand | Orchestrator | Inline another workflow's steps |\n| branch | Orchestrator | Conditional execution (was 'condition') |\n| agent | External | Assign work to agent, wait for meow done |\n| gate | External | Human approval, wait for meow approve |\n\n## Key Design Decisions\n\n1. **Executor configs as embedded structs** - Each step has optional config for its executor type (ShellConfig, SpawnConfig, etc.). Only one is populated.\n\n2. **Status on Step, not separate** - Step.Status tracks lifecycle (pending/running/done/failed).\n\n3. **Outputs stored on Step** - When step completes, outputs captured directly on step.\n\n4. **No Tier field** - Visibility is implicit. Agents see their prompts, period.\n\n## Mapping from Old to New\n\n| Old BeadType | New Executor | Notes |\n|--------------|--------------|-------|\n| task | agent | mode: autonomous |\n| collaborative | agent | mode: interactive |\n| gate | gate | Same concept |\n| condition | branch | Renamed for clarity |\n| code | shell | Renamed for clarity |\n| start | spawn | Renamed for clarity |\n| stop | kill | Renamed for clarity |\n| expand | expand | Same |","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:01Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-100","depends_on_id":"pivot-000","type":"blocks","created_at":"2026-01-08T12:00:01Z","created_by":"claude"}]}
{"id":"pivot-101","title":"Define ExecutorType enum","description":"# Define ExecutorType Enum\n\n## File: internal/types/executor.go\n\n## Implementation\n\n```go\npackage types\n\n// ExecutorType determines who runs a step and how.\ntype ExecutorType string\n\nconst (\n    // Orchestrator executors - run internally, complete synchronously\n    ExecutorShell  ExecutorType = \"shell\"  // Run shell command\n    ExecutorSpawn  ExecutorType = \"spawn\"  // Start agent in tmux\n    ExecutorKill   ExecutorType = \"kill\"   // Stop agent's tmux session\n    ExecutorExpand ExecutorType = \"expand\" // Inline another workflow\n    ExecutorBranch ExecutorType = \"branch\" // Conditional execution\n\n    // External executors - wait for external completion signal\n    ExecutorAgent ExecutorType = \"agent\" // Agent does work, signals meow done\n    ExecutorGate  ExecutorType = \"gate\"  // Human approval via meow approve\n)\n\n// IsOrchestrator returns true if this executor runs internally.\nfunc (e ExecutorType) IsOrchestrator() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch:\n        return true\n    }\n    return false\n}\n\n// IsExternal returns true if this executor waits for external signal.\nfunc (e ExecutorType) IsExternal() bool {\n    return e == ExecutorAgent || e == ExecutorGate\n}\n\n// Valid returns true if this is a recognized executor type.\nfunc (e ExecutorType) Valid() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch, ExecutorAgent, ExecutorGate:\n        return true\n    }\n    return false\n}\n```\n\n## Rationale\n\n- **shell** not \"code\" - More intuitive, matches spec language\n- **spawn/kill** not \"start/stop\" - Clearer about what's happening (process lifecycle)\n- **branch** not \"condition\" - Describes what it does (branching), not what it evaluates\n- **agent** not \"task\" - Describes who runs it, consistent with other executors\n\n## Acceptance Criteria\n\n- [ ] ExecutorType enum with 7 values\n- [ ] IsOrchestrator() helper\n- [ ] IsExternal() helper\n- [ ] Valid() validation\n- [ ] Unit tests for all methods","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:02Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-101","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:02Z","created_by":"claude"}]}
{"id":"pivot-102","title":"Define StepStatus enum","description":"# Define StepStatus Enum\n\n## File: internal/types/step.go (or executor.go)\n\n## Implementation\n\n```go\n// StepStatus represents the lifecycle state of a step.\ntype StepStatus string\n\nconst (\n    StepStatusPending    StepStatus = \"pending\"    // Waiting for dependencies\n    StepStatusRunning    StepStatus = \"running\"    // Currently executing\n    StepStatusCompleting StepStatus = \"completing\" // Agent called meow done, orchestrator handling transition\n    StepStatusDone       StepStatus = \"done\"       // Completed successfully\n    StepStatusFailed     StepStatus = \"failed\"     // Execution failed\n)\n\n// Valid returns true if this is a recognized status.\nfunc (s StepStatus) Valid() bool {\n    switch s {\n    case StepStatusPending, StepStatusRunning, StepStatusCompleting, StepStatusDone, StepStatusFailed:\n        return true\n    }\n    return false\n}\n\n// IsTerminal returns true if this status is final (done or failed).\nfunc (s StepStatus) IsTerminal() bool {\n    return s == StepStatusDone || s == StepStatusFailed\n}\n\n// CanTransitionTo returns true if transitioning from s to target is valid.\nfunc (s StepStatus) CanTransitionTo(target StepStatus) bool {\n    switch s {\n    case StepStatusPending:\n        return target == StepStatusRunning\n    case StepStatusRunning:\n        return target == StepStatusCompleting || target == StepStatusDone || target == StepStatusFailed || target == StepStatusPending // Reset on crash\n    case StepStatusCompleting:\n        return target == StepStatusDone || target == StepStatusRunning // Back to running if validation fails\n    case StepStatusDone, StepStatusFailed:\n        return false // Terminal states\n    }\n    return false\n}\n```\n\n## Design Notes\n\n- **\\`completing\\` status added** - Critical for preventing stop hook interference during orchestrator transitions. When agent calls \\`meow done\\`, step goes to \\`completing\\` while orchestrator validates outputs and prepares next prompt.\n- **Reset allowed** - Running can go back to pending for crash recovery.\n- **Completing can retry** - If validation fails, step goes back to running so agent can retry.\n- **Terminal states** - Once done/failed, no further transitions.\n\n## Status Lifecycle\n\n\\`\\`\\`\npending ──► running ──► completing ──► done\n              │             │\n              │             └──► (back to running if validation fails)\n              │\n              └──► failed\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] StepStatus enum with 5 values (including completing)\n- [ ] Valid() validation\n- [ ] IsTerminal() helper\n- [ ] CanTransitionTo() state machine with completing transitions\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:03Z","created_by":"claude","updated_at":"2026-01-08T20:25:18.046481862-05:00","dependencies":[{"issue_id":"pivot-102","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:03Z","created_by":"claude"}]}
{"id":"pivot-103","title":"Define executor config structs","description":"# Define Executor Config Structs\n\n## File: internal/types/step.go\n\n## Implementation\n\nEach executor has its own config struct. Only one is populated per step.\n\n```go\n// ShellConfig for executor: shell\ntype ShellConfig struct {\n    Command string            `yaml:\"command\" toml:\"command\"`\n    Workdir string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env     map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    OnError string            `yaml:\"on_error,omitempty\" toml:\"on_error,omitempty\"` // continue | fail\n}\n\n// SpawnConfig for executor: spawn\ntype SpawnConfig struct {\n    Agent         string            `yaml:\"agent\" toml:\"agent\"`\n    Workdir       string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env           map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    Prompt        string            `yaml:\"prompt,omitempty\" toml:\"prompt,omitempty\"` // Default: \"meow prime\"\n    ResumeSession string            `yaml:\"resume_session,omitempty\" toml:\"resume_session,omitempty\"`\n}\n\n// KillConfig for executor: kill\ntype KillConfig struct {\n    Agent    string `yaml:\"agent\" toml:\"agent\"`\n    Graceful bool   `yaml:\"graceful,omitempty\" toml:\"graceful,omitempty\"` // Default: true\n    Timeout  int    `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"`   // Seconds, default: 10\n}\n\n// ExpandConfig for executor: expand\ntype ExpandConfig struct {\n    Template  string            `yaml:\"template\" toml:\"template\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n}\n\n// BranchTarget defines what to expand for a branch outcome.\ntype BranchTarget struct {\n    Template  string            `yaml:\"template,omitempty\" toml:\"template,omitempty\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n    Inline    []*InlineStep     `yaml:\"inline,omitempty\" toml:\"inline,omitempty\"`\n}\n\n// BranchConfig for executor: branch\ntype BranchConfig struct {\n    Condition string        `yaml:\"condition\" toml:\"condition\"` // Shell command, exit 0 = true\n    OnTrue    *BranchTarget `yaml:\"on_true,omitempty\" toml:\"on_true,omitempty\"`\n    OnFalse   *BranchTarget `yaml:\"on_false,omitempty\" toml:\"on_false,omitempty\"`\n    OnTimeout *BranchTarget `yaml:\"on_timeout,omitempty\" toml:\"on_timeout,omitempty\"`\n    Timeout   string        `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"` // Duration string\n}\n\n// AgentMode determines auto-continuation behavior.\ntype AgentMode string\n\nconst (\n    AgentModeAutonomous  AgentMode = \"autonomous\"  // Stop-hook continues\n    AgentModeInteractive AgentMode = \"interactive\" // Pauses for conversation\n)\n\n// OutputDef defines an expected output from an agent step.\ntype OutputDef struct {\n    Required    bool   `yaml:\"required\" toml:\"required\"`\n    Type        string `yaml:\"type\" toml:\"type\"` // string, number, boolean, json, file_path\n    Description string `yaml:\"description,omitempty\" toml:\"description,omitempty\"`\n}\n\n// AgentConfig for executor: agent\ntype AgentConfig struct {\n    Agent   string               `yaml:\"agent\" toml:\"agent\"`\n    Prompt  string               `yaml:\"prompt\" toml:\"prompt\"`\n    Mode    AgentMode            `yaml:\"mode,omitempty\" toml:\"mode,omitempty\"` // Default: autonomous\n    Outputs map[string]OutputDef `yaml:\"outputs,omitempty\" toml:\"outputs,omitempty\"`\n}\n\n// GateConfig for executor: gate\ntype GateConfig struct {\n    Prompt  string `yaml:\"prompt\" toml:\"prompt\"`\n    Timeout string `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"`\n}\n```\n\n## Design Notes\n\n- **Both YAML and TOML tags** - Config structs are used for both template parsing (TOML) and state persistence (YAML).\n- **AgentMode enum** - Replaces separate 'collaborative' type with a mode field.\n- **OutputDef simplified** - Type is string, validation happens at runtime.\n\n## Acceptance Criteria\n\n- [ ] All 7 executor config structs defined\n- [ ] AgentMode enum (autonomous/interactive)\n- [ ] OutputDef for agent outputs\n- [ ] BranchTarget for conditional expansion\n- [ ] Unit tests for serialization","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:04Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-103","depends_on_id":"pivot-101","type":"blocks","created_at":"2026-01-08T12:00:04Z","created_by":"claude"}]}
{"id":"pivot-104","title":"Define Step struct","description":"# Define Step Struct\n\n## File: internal/types/step.go\n\n## Implementation\n\n\\`\\`\\`go\n// Step is the single primitive in MEOW. Everything is a step.\ntype Step struct {\n    // Identity\n    ID       string       \\`yaml:\"id\"\\`\n    Executor ExecutorType \\`yaml:\"executor\"\\`\n\n    // Lifecycle\n    Status    StepStatus \\`yaml:\"status\"\\`\n    StartedAt *time.Time \\`yaml:\"started_at,omitempty\"\\`\n    DoneAt    *time.Time \\`yaml:\"done_at,omitempty\"\\`\n\n    // Dependencies\n    Needs []string \\`yaml:\"needs,omitempty\"\\`\n\n    // Expansion tracking (for crash recovery)\n    ExpandedFrom string   \\`yaml:\"expanded_from,omitempty\"\\` // Parent expand step ID\n    ExpandedInto []string \\`yaml:\"expanded_into,omitempty\"\\` // Child step IDs (on expand steps)\n\n    // Data\n    Outputs map[string]any \\`yaml:\"outputs,omitempty\"\\`\n    Error   *StepError     \\`yaml:\"error,omitempty\"\\`\n\n    // Executor-specific config (exactly one populated based on Executor)\n    Shell  *ShellConfig  \\`yaml:\"shell,omitempty\"\\`\n    Spawn  *SpawnConfig  \\`yaml:\"spawn,omitempty\"\\`\n    Kill   *KillConfig   \\`yaml:\"kill,omitempty\"\\`\n    Expand *ExpandConfig \\`yaml:\"expand,omitempty\"\\`\n    Branch *BranchConfig \\`yaml:\"branch,omitempty\"\\`\n    Agent  *AgentConfig  \\`yaml:\"agent,omitempty\"\\`\n    Gate   *GateConfig   \\`yaml:\"gate,omitempty\"\\`\n}\n\n// StepError captures failure information.\ntype StepError struct {\n    Message string \\`yaml:\"message\"\\`\n    Code    int    \\`yaml:\"code,omitempty\"\\`    // Exit code for shell\n    Output  string \\`yaml:\"output,omitempty\"\\` // stderr or other context\n}\n\n// InlineStep is used for inline step definitions in branch targets.\n// Simplified version of Step for template parsing.\ntype InlineStep struct {\n    ID       string            \\`yaml:\"id\" toml:\"id\"\\`\n    Executor ExecutorType      \\`yaml:\"executor\" toml:\"executor\"\\`\n    Prompt   string            \\`yaml:\"prompt,omitempty\" toml:\"prompt,omitempty\"\\` // For agent steps\n    Agent    string            \\`yaml:\"agent,omitempty\" toml:\"agent,omitempty\"\\`\n    Needs    []string          \\`yaml:\"needs,omitempty\" toml:\"needs,omitempty\"\\`\n}\n\\`\\`\\`\n\n## Helper Methods\n\n\\`\\`\\`go\n// IsReady returns true if all dependencies are done.\nfunc (s *Step) IsReady(steps map[string]*Step) bool {\n    if s.Status != StepStatusPending {\n        return false\n    }\n    for _, depID := range s.Needs {\n        dep, ok := steps[depID]\n        if !ok || dep.Status != StepStatusDone {\n            return false\n        }\n    }\n    return true\n}\n\n// Validate checks the step is well-formed.\nfunc (s *Step) Validate() error {\n    if s.ID == \"\" {\n        return fmt.Errorf(\"step ID is required\")\n    }\n    if !s.Executor.Valid() {\n        return fmt.Errorf(\"invalid executor: %s\", s.Executor)\n    }\n    // Verify exactly one config is set for the executor\n    return s.validateConfig()\n}\n\n// Complete marks the step as done with outputs.\nfunc (s *Step) Complete(outputs map[string]any) error {\n    if !s.Status.CanTransitionTo(StepStatusDone) {\n        return fmt.Errorf(\"cannot complete step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusDone\n    s.DoneAt = \u0026now\n    s.Outputs = outputs\n    return nil\n}\n\n// Fail marks the step as failed with error info.\nfunc (s *Step) Fail(err *StepError) error {\n    if !s.Status.CanTransitionTo(StepStatusFailed) {\n        return fmt.Errorf(\"cannot fail step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusFailed\n    s.DoneAt = \u0026now\n    s.Error = err\n    return nil\n}\n\n// SetCompleting marks the step as transitioning to done.\n// Used after meow done is received, before validation.\nfunc (s *Step) SetCompleting() error {\n    if !s.Status.CanTransitionTo(StepStatusCompleting) {\n        return fmt.Errorf(\"cannot set completing in status %s\", s.Status)\n    }\n    s.Status = StepStatusCompleting\n    return nil\n}\n\\`\\`\\`\n\n## Design Notes\n\n- **Flat config fields** - Each executor config is a direct field on Step, not nested in a generic Config field. This makes YAML output cleaner.\n- **Outputs as map[string]any** - Flexible for different output types. Validation happens at completion time.\n- **No Title field** - Steps are identified by ID. Prompts contain the human-readable description.\n- **ExpandedFrom/ExpandedInto** - Used for:\n  - Crash recovery: If expand step was running, delete all steps with \\`expanded_from: \u003cexpand-id\u003e\\`\n  - Debugging: See which template created which steps\n\n## Workflow Growth Example\n\n\\`\\`\\`yaml\n# After expand step \"do-impl\" runs\nsteps:\n  do-impl:\n    executor: expand\n    status: done\n    expanded_into: [\"do-impl.load\", \"do-impl.test\", \"do-impl.code\"]\n\n  do-impl.load:\n    executor: agent\n    status: pending\n    expanded_from: do-impl\n    # ...\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Step struct with all fields including ExpandedFrom/ExpandedInto\n- [ ] StepError struct\n- [ ] InlineStep for branch targets\n- [ ] IsReady() helper\n- [ ] Validate() method\n- [ ] Complete() and Fail() methods\n- [ ] SetCompleting() method for completing status transition\n- [ ] Unit tests for all methods\n- [ ] Unit tests for status transitions","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:05Z","created_by":"claude","updated_at":"2026-01-08T20:31:14.906704199-05:00","dependencies":[{"issue_id":"pivot-104","depends_on_id":"pivot-102","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"},{"issue_id":"pivot-104","depends_on_id":"pivot-103","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"}]}
{"id":"pivot-105","title":"Define Workflow struct","description":"# Define Workflow Struct\n\n## File: internal/types/workflow.go\n\n## Implementation\n\n\\`\\`\\`go\npackage types\n\nimport \"time\"\n\n// WorkflowStatus represents the lifecycle state of a workflow.\ntype WorkflowStatus string\n\nconst (\n    WorkflowStatusPending WorkflowStatus = \"pending\" // Created but not started\n    WorkflowStatusRunning WorkflowStatus = \"running\" // Orchestrator is processing\n    WorkflowStatusDone    WorkflowStatus = \"done\"    // All steps completed\n    WorkflowStatusFailed  WorkflowStatus = \"failed\"  // A step failed\n)\n\n// AgentInfo tracks persisted state for an agent.\ntype AgentInfo struct {\n    TmuxSession string \\`yaml:\"tmux_session\"\\`\n    Status      string \\`yaml:\"status\"\\`       // active, idle\n    Workdir     string \\`yaml:\"workdir\"\\`\n    CurrentStep string \\`yaml:\"current_step,omitempty\"\\`\n}\n\n// Workflow represents a running workflow instance.\ntype Workflow struct {\n    // Identity\n    ID       string \\`yaml:\"id\"\\`       // Unique identifier (e.g., \"wf-abc123\")\n    Template string \\`yaml:\"template\"\\` // Source template path\n\n    // Lifecycle\n    Status    WorkflowStatus \\`yaml:\"status\"\\`\n    StartedAt time.Time      \\`yaml:\"started_at\"\\`\n    DoneAt    *time.Time     \\`yaml:\"done_at,omitempty\"\\`\n\n    // Configuration\n    Variables map[string]string \\`yaml:\"variables,omitempty\"\\`\n\n    // Agent state - tracked for crash recovery and file_path validation\n    Agents map[string]*AgentInfo \\`yaml:\"agents,omitempty\"\\`\n\n    // State - all steps with their current state\n    Steps map[string]*Step \\`yaml:\"steps\"\\`\n}\n\n// NewWorkflow creates a new workflow instance.\nfunc NewWorkflow(id, template string, vars map[string]string) *Workflow {\n    return \u0026Workflow{\n        ID:        id,\n        Template:  template,\n        Status:    WorkflowStatusPending,\n        StartedAt: time.Now(),\n        Variables: vars,\n        Agents:    make(map[string]*AgentInfo),\n        Steps:     make(map[string]*Step),\n    }\n}\n\n// AddStep adds a step to the workflow.\nfunc (w *Workflow) AddStep(step *Step) error {\n    if _, exists := w.Steps[step.ID]; exists {\n        return fmt.Errorf(\"step %s already exists\", step.ID)\n    }\n    w.Steps[step.ID] = step\n    return nil\n}\n\n// RegisterAgent adds or updates agent state.\nfunc (w *Workflow) RegisterAgent(id string, info *AgentInfo) {\n    w.Agents[id] = info\n}\n\n// GetAgentWorkdir returns the working directory for an agent.\n// Used for file_path output validation.\nfunc (w *Workflow) GetAgentWorkdir(agentID string) (string, bool) {\n    agent, ok := w.Agents[agentID]\n    if !ok {\n        return \"\", false\n    }\n    return agent.Workdir, true\n}\n\n// GetReadySteps returns all steps that are ready to execute.\nfunc (w *Workflow) GetReadySteps() []*Step {\n    var ready []*Step\n    for _, step := range w.Steps {\n        if step.IsReady(w.Steps) {\n            ready = append(ready, step)\n        }\n    }\n    return ready\n}\n\n// AllDone returns true if all steps are in terminal state.\nfunc (w *Workflow) AllDone() bool {\n    for _, step := range w.Steps {\n        if !step.Status.IsTerminal() {\n            return false\n        }\n    }\n    return true\n}\n\n// HasFailed returns true if any step has failed.\nfunc (w *Workflow) HasFailed() bool {\n    for _, step := range w.Steps {\n        if step.Status == StepStatusFailed {\n            return true\n        }\n    }\n    return false\n}\n\n// Complete marks the workflow as done.\nfunc (w *Workflow) Complete() {\n    now := time.Now()\n    w.Status = WorkflowStatusDone\n    w.DoneAt = \u0026now\n}\n\n// Fail marks the workflow as failed.\nfunc (w *Workflow) Fail() {\n    now := time.Now()\n    w.Status = WorkflowStatusFailed\n    w.DoneAt = \u0026now\n}\n\n// GetStep retrieves a step by ID.\nfunc (w *Workflow) GetStep(id string) (*Step, bool) {\n    step, ok := w.Steps[id]\n    return step, ok\n}\n\n// GetStepsForAgent returns steps assigned to the given agent.\nfunc (w *Workflow) GetStepsForAgent(agentID string) []*Step {\n    var result []*Step\n    for _, step := range w.Steps {\n        if step.Executor == ExecutorAgent \u0026\u0026 step.Agent != nil \u0026\u0026 step.Agent.Agent == agentID {\n            result = append(result, step)\n        }\n    }\n    return result\n}\n\\`\\`\\`\n\n## Design Notes\n\n- **Steps as map** - O(1) lookup by ID, which is common during dependency resolution.\n- **Variables stored** - The resolved variables are saved so we can reconstruct context on restart.\n- **Agents field** - Tracks agent state for:\n  - Crash recovery (check if tmux session still exists)\n  - file_path validation (resolve relative paths against agent's workdir)\n- **No parent/child relationship** - Expanded steps are just more steps in the map with dependency links.\n\n## YAML Representation\n\n\\`\\`\\`yaml\n# .meow/workflows/wf-abc123.yaml\nid: wf-abc123\ntemplate: work-loop.meow.toml\nstatus: running\nstarted_at: 2026-01-08T21:00:00Z\n\nvariables:\n  agent: claude-1\n\nagents:\n  claude-1:\n    tmux_session: meow-wf-abc123-claude-1\n    status: active\n    workdir: /data/projects/myapp/.meow/worktrees/claude-1\n    current_step: impl.write-tests\n\nsteps:\n  # ... step definitions ...\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] WorkflowStatus enum\n- [ ] AgentInfo struct for persisted agent state\n- [ ] Workflow struct with Agents field\n- [ ] NewWorkflow() constructor initializes Agents map\n- [ ] RegisterAgent() method\n- [ ] GetAgentWorkdir() for file_path validation\n- [ ] AddStep() method\n- [ ] GetReadySteps() helper\n- [ ] AllDone() and HasFailed() helpers\n- [ ] GetStepsForAgent() for agent queries\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:06Z","created_by":"claude","updated_at":"2026-01-08T20:30:27.289995337-05:00","dependencies":[{"issue_id":"pivot-105","depends_on_id":"pivot-104","type":"blocks","created_at":"2026-01-08T12:00:06Z","created_by":"claude"}]}
{"id":"pivot-106","title":"Remove old bead types","description":"# Remove Old Bead Types\n\n## Context\n\nOnce new types are in place and the orchestrator is updated, we can remove the old bead-centric types. This is the cleanup step.\n\n## Files to Modify\n\n### internal/types/bead.go - DELETE ENTIRELY\n\nRemove:\n- BeadType enum\n- BeadTier enum\n- BeadStatus enum (replaced by StepStatus)\n- Bead struct\n- All spec structs (ConditionSpec, StartSpec, etc.)\n- All validation methods\n\n### internal/types/agent.go - KEEP\n\nAgent type is still needed for agent state tracking.\n\n## Migration Strategy\n\n1. First, implement new types alongside old\n2. Update orchestrator to use new types\n3. Update CLI to use new types\n4. Only then delete old types\n\nThis task should be done LAST in the type system epic.\n\n## Acceptance Criteria\n\n- [ ] internal/types/bead.go deleted\n- [ ] No imports of old bead types remain\n- [ ] All tests pass with new types\n- [ ] No references to BeadType, BeadTier, etc.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:07Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-106","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"pivot-106","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"pivot-106","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"}]}
{"id":"pivot-200","title":"EPIC: Workflow State Persistence","description":"# Workflow State Persistence\n\n## The Big Change\n\nPreviously: All state in `.beads/issues.jsonl` (JSONL format, shared with bd CLI)\nNow: Per-workflow YAML files in `.meow/workflows/`\n\n## Why YAML?\n\n1. **Human-readable** - Easy to debug, inspect, manually edit if needed\n2. **Per-workflow files** - No giant monolithic file, easy cleanup\n3. **Atomic writes** - Write to temp, rename (no partial states)\n4. **Git-trackable** - Can version control workflow state if desired\n5. **No lock contention** - Each workflow is independent\n\n## Directory Structure\n\n```\n.meow/\n├── config.toml              # User configuration\n├── agents.yaml              # Active agent sessions\n├── orchestrator.lock        # Prevents concurrent instances\n└── workflows/\n    ├── wf-abc123.yaml       # Workflow instance state\n    └── wf-def456.yaml\n```\n\n## Workflow State File Format\n\n```yaml\n# .meow/workflows/wf-abc123.yaml\nid: wf-abc123\ntemplate: work-loop.meow.toml\nstatus: running\nstarted_at: 2026-01-08T21:00:00Z\n\nvariables:\n  agent: claude-1\n\nsteps:\n  select:\n    executor: agent\n    status: done\n    done_at: 2026-01-08T21:02:00Z\n    agent:\n      agent: claude-1\n      prompt: \"Select the next task...\"\n    outputs:\n      task_id: \"PROJ-123\"\n\n  implement:\n    executor: expand\n    status: done\n    expand:\n      template: \".tdd\"\n\n  implement.load-context:\n    executor: agent\n    status: running\n    needs: [\"implement\"]\n    agent:\n      agent: claude-1\n      prompt: \"Load context...\"\n```\n\n## Key Operations\n\n- **Create** - New workflow from template\n- **Load** - Read workflow state from YAML\n- **Save** - Write workflow state to YAML (atomic)\n- **List** - Enumerate all workflow files\n- **Delete** - Remove completed workflow file\n\n## No More Bead Store\n\nThe BeadStore interface is replaced by WorkflowStore. No more:\n- Tier filtering\n- HookBead queries\n- JSONL parsing","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:10Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-200","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:10Z","created_by":"claude"}]}
{"id":"pivot-201","title":"Define WorkflowStore interface","description":"# Define WorkflowStore Interface\n\n## File: internal/orchestrator/workflowstore.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// WorkflowStore provides persistence for workflow state.\ntype WorkflowStore interface {\n    // Create persists a new workflow.\n    Create(ctx context.Context, wf *types.Workflow) error\n\n    // Get retrieves a workflow by ID.\n    Get(ctx context.Context, id string) (*types.Workflow, error)\n\n    // Save persists workflow state (atomic write).\n    Save(ctx context.Context, wf *types.Workflow) error\n\n    // Delete removes a workflow.\n    Delete(ctx context.Context, id string) error\n\n    // List returns all workflows matching filter.\n    List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error)\n\n    // GetByAgent returns workflows with steps assigned to agent.\n    GetByAgent(ctx context.Context, agentID string) ([]*types.Workflow, error)\n}\n\n// WorkflowFilter for listing workflows.\ntype WorkflowFilter struct {\n    Status types.WorkflowStatus // Filter by status\n}\n```\n\n## Design Notes\n\n- **Simple interface** - Just CRUD + listing\n- **No tier filtering** - Tiers don't exist in new model\n- **GetByAgent** - Needed for `meow prime` to find agent's work\n- **Atomic Save** - Implementation must be atomic (temp file + rename)\n\n## Acceptance Criteria\n\n- [ ] WorkflowStore interface defined\n- [ ] WorkflowFilter struct\n- [ ] Interface documented","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:11Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-201","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T12:00:11Z","created_by":"claude"}]}
{"id":"pivot-202","title":"Implement YAMLWorkflowStore","description":"# Implement YAMLWorkflowStore\n\n## File: internal/orchestrator/yamlstore.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"gopkg.in/yaml.v3\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// YAMLWorkflowStore persists workflows as YAML files.\ntype YAMLWorkflowStore struct {\n    dir string // .meow/workflows\n}\n\n// NewYAMLWorkflowStore creates a new store.\nfunc NewYAMLWorkflowStore(dir string) (*YAMLWorkflowStore, error) {\n    if err := os.MkdirAll(dir, 0755); err != nil {\n        return nil, fmt.Errorf(\"creating workflow dir: %w\", err)\n    }\n    // Recover from any interrupted writes\n    if err := recoverInterruptedWrites(dir); err != nil {\n        return nil, fmt.Errorf(\"recovering interrupted writes: %w\", err)\n    }\n    return \u0026YAMLWorkflowStore{dir: dir}, nil\n}\n\n// recoverInterruptedWrites handles .tmp files left from crashed writes.\n// Recovery logic:\n// - If .yaml.tmp exists and .yaml is valid: delete temp file, use main\n// - If .yaml is corrupt/missing but .tmp exists: rename temp to main\nfunc recoverInterruptedWrites(dir string) error {\n    entries, err := os.ReadDir(dir)\n    if err != nil {\n        return err\n    }\n    \n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml.tmp\") {\n            continue\n        }\n        \n        tmpPath := filepath.Join(dir, entry.Name())\n        mainPath := strings.TrimSuffix(tmpPath, \".tmp\")\n        \n        // Check if main file exists and is valid\n        mainData, mainErr := os.ReadFile(mainPath)\n        if mainErr == nil {\n            var wf types.Workflow\n            if yaml.Unmarshal(mainData, \u0026wf) == nil {\n                // Main file is valid, delete temp\n                os.Remove(tmpPath)\n                continue\n            }\n        }\n        \n        // Main file is missing or corrupt, try to use temp\n        tmpData, tmpErr := os.ReadFile(tmpPath)\n        if tmpErr != nil {\n            // Temp file unreadable, just delete it\n            os.Remove(tmpPath)\n            continue\n        }\n        \n        var wf types.Workflow\n        if yaml.Unmarshal(tmpData, \u0026wf) != nil {\n            // Temp file also corrupt, delete both\n            os.Remove(tmpPath)\n            os.Remove(mainPath)\n            continue\n        }\n        \n        // Temp file is valid, promote it to main\n        if err := os.Rename(tmpPath, mainPath); err != nil {\n            return fmt.Errorf(\"promoting temp to main %s: %w\", mainPath, err)\n        }\n    }\n    \n    return nil\n}\n\nfunc (s *YAMLWorkflowStore) path(id string) string {\n    return filepath.Join(s.dir, id+\".yaml\")\n}\n\n// Create persists a new workflow.\nfunc (s *YAMLWorkflowStore) Create(ctx context.Context, wf *types.Workflow) error {\n    path := s.path(wf.ID)\n    if _, err := os.Stat(path); err == nil {\n        return fmt.Errorf(\"workflow %s already exists\", wf.ID)\n    }\n    return s.Save(ctx, wf)\n}\n\n// Get retrieves a workflow by ID.\nfunc (s *YAMLWorkflowStore) Get(ctx context.Context, id string) (*types.Workflow, error) {\n    path := s.path(id)\n    data, err := os.ReadFile(path)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil, nil\n        }\n        return nil, fmt.Errorf(\"reading workflow: %w\", err)\n    }\n\n    var wf types.Workflow\n    if err := yaml.Unmarshal(data, \u0026wf); err != nil {\n        return nil, fmt.Errorf(\"parsing workflow: %w\", err)\n    }\n    return \u0026wf, nil\n}\n\n// Save persists workflow state atomically using write-then-rename.\n// This ensures that crashes mid-write don't corrupt the workflow file.\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow) error {\n    data, err := yaml.Marshal(wf)\n    if err != nil {\n        return fmt.Errorf(\"marshaling workflow: %w\", err)\n    }\n\n    path := s.path(wf.ID)\n    tmpPath := path + \".tmp\"\n\n    // Step 1: Write to temp file\n    if err := os.WriteFile(tmpPath, data, 0644); err != nil {\n        return fmt.Errorf(\"writing temp file: %w\", err)\n    }\n\n    // Step 2: Atomic rename (POSIX guarantees this is atomic)\n    if err := os.Rename(tmpPath, path); err != nil {\n        os.Remove(tmpPath) // Cleanup on failure\n        return fmt.Errorf(\"renaming to final: %w\", err)\n    }\n\n    return nil\n}\n\n// Delete removes a workflow.\nfunc (s *YAMLWorkflowStore) Delete(ctx context.Context, id string) error {\n    // Also clean up any temp file\n    tmpPath := s.path(id) + \".tmp\"\n    os.Remove(tmpPath)\n    return os.Remove(s.path(id))\n}\n\n// List returns all workflows matching filter.\nfunc (s *YAMLWorkflowStore) List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error) {\n    entries, err := os.ReadDir(s.dir)\n    if err != nil {\n        return nil, fmt.Errorf(\"reading workflow dir: %w\", err)\n    }\n\n    var workflows []*types.Workflow\n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml\") || strings.HasSuffix(entry.Name(), \".tmp\") {\n            continue\n        }\n\n        id := strings.TrimSuffix(entry.Name(), \".yaml\")\n        wf, err := s.Get(ctx, id)\n        if err != nil {\n            continue // Skip corrupt files\n        }\n        if wf == nil {\n            continue\n        }\n\n        if filter.Status != \"\" \u0026\u0026 wf.Status != filter.Status {\n            continue\n        }\n\n        workflows = append(workflows, wf)\n    }\n\n    return workflows, nil\n}\n```\n\n## Design Notes\n\n- **Atomic writes via write-then-rename** - On POSIX systems, rename() is atomic. This prevents corruption from mid-write crashes.\n- **Recovery on startup** - NewYAMLWorkflowStore() checks for and recovers from .tmp files left by interrupted writes.\n- **Recovery logic**:\n  - If .yaml exists and is valid: delete .tmp, use main\n  - If .yaml is corrupt/missing but .tmp is valid: promote .tmp to main\n  - If both are corrupt: delete both (workflow is lost)\n- **Delete cleans up temp files** - Ensures no orphaned .tmp files remain.\n\n## Acceptance Criteria\n\n- [ ] YAMLWorkflowStore with Create/Get/Save/Delete/List\n- [ ] Atomic write using temp file + rename\n- [ ] Recovery from interrupted writes on startup\n- [ ] List filters out .tmp files\n- [ ] Delete cleans up temp files\n- [ ] Unit tests for atomic writes\n- [ ] Unit tests for recovery scenarios","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:12Z","created_by":"claude","updated_at":"2026-01-08T20:26:08.394522352-05:00","dependencies":[{"issue_id":"pivot-202","depends_on_id":"pivot-201","type":"blocks","created_at":"2026-01-08T12:00:12Z","created_by":"claude"}]}
{"id":"pivot-203","title":"Implement workflow ID generation","description":"# Implement Workflow ID Generation\n\n## File: internal/orchestrator/id.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"time\"\n)\n\n// GenerateWorkflowID creates a unique workflow identifier.\n// Format: wf-{timestamp_hex}-{random_hex}\n// Example: wf-1a2b3c4d-e5f6g7h8\nfunc GenerateWorkflowID() string {\n    ts := time.Now().UnixNano()\n    randBytes := make([]byte, 4)\n    rand.Read(randBytes)\n    return fmt.Sprintf(\"wf-%x-%s\", ts, hex.EncodeToString(randBytes))\n}\n\n// GenerateStepID creates a unique step identifier within a workflow.\n// Format: {parent}.{step_id}\n// Example: implement.load-context (from expand step \"implement\")\nfunc GenerateExpandedStepID(parentID, stepID string) string {\n    if parentID == \"\" {\n        return stepID\n    }\n    return parentID + \".\" + stepID\n}\n```\n\n## Design Notes\n\n- **Timestamp prefix** - Makes IDs roughly sortable by creation time\n- **Random suffix** - Prevents collisions for rapid creation\n- **Dot notation for expanded steps** - Makes hierarchy visible in IDs\n\n## Acceptance Criteria\n\n- [ ] GenerateWorkflowID() creates unique IDs\n- [ ] GenerateExpandedStepID() handles parent.child notation\n- [ ] IDs are filesystem-safe (no special chars)\n- [ ] Unit tests verify uniqueness","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:13Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-203","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T12:00:13Z","created_by":"claude"}]}
{"id":"pivot-204","title":"Remove BeadStore and bead persistence","description":"# Remove BeadStore and Bead Persistence\n\n## Context\n\nOnce WorkflowStore is implemented and the orchestrator is using it, we can remove all bead persistence code.\n\n## Files to Remove/Modify\n\n### Remove entirely:\n- internal/orchestrator/beadstore.go\n- Any JSONL parsing code for beads\n\n### Modify:\n- internal/orchestrator/orchestrator.go - Remove BeadStore dependency\n- cmd/meow/cmd/*.go - Remove bead-specific queries\n\n## What We're NOT Removing\n\n- `.beads/` directory itself - Users may still use beads for task tracking\n- bd CLI integration - Templates can still prompt agents to use `bd`\n\nWe're just removing MEOW's internal use of beads as its state store.\n\n## Migration Strategy\n\n1. Implement WorkflowStore\n2. Update orchestrator to use WorkflowStore\n3. Update CLI to use WorkflowStore\n4. Remove BeadStore code\n\n## Acceptance Criteria\n\n- [ ] BeadStore interface removed\n- [ ] No JSONL parsing for beads\n- [ ] Orchestrator uses WorkflowStore\n- [ ] All tests pass without bead store","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:14Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-204","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:14Z","created_by":"claude"},{"issue_id":"pivot-204","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:14Z","created_by":"claude"}]}
{"id":"pivot-300","title":"EPIC: Template System Alignment","description":"# Template System Alignment\n\n## What's Changing\n\nThe template system is largely correct but needs updates for the new model:\n\n1. **executor field** instead of **type field**\n2. **Remove ephemeral/hooks_to** - No more tier detection\n3. **Remove legacy format** - Clean break, module format only\n4. **Agent mode field** - Replace collaborative type\n\n## Template Format (Before vs After)\n\n### Before (bead-centric)\n```toml\n[main]\nephemeral = true        # ← REMOVE\nhooks_to = \"work_bead\"  # ← REMOVE\n\n[[main.steps]]\nid = \"do-work\"\ntype = \"task\"           # ← CHANGE TO executor\nassignee = \"{{agent}}\"  # ← CHANGE TO agent field in config\ninstructions = \"...\"    # ← CHANGE TO prompt field in config\n```\n\n### After (workflow-centric)\n```toml\n[main]\nname = \"work-loop\"\ndescription = \"...\"\n\n[[main.steps]]\nid = \"do-work\"\nexecutor = \"agent\"      # ← executor, not type\nagent = \"{{agent}}\"\nprompt = \"...\"          # ← prompt, not instructions\nmode = \"autonomous\"     # ← optional, default\n\n[main.steps.outputs]\ntask_id = { required = true, type = \"string\" }\n```\n\n## Parser Changes\n\n- Parse `executor` field instead of `type`\n- Map TOML fields to executor config structs\n- Remove tier detection logic from baker\n- Remove HookBead assignment\n\n## Files Affected\n\n- internal/template/module.go - Parser\n- internal/template/baker.go - Bead→Step creation\n- internal/template/vars.go - Variable substitution (mostly unchanged)\n- internal/template/loader.go - Template loading (mostly unchanged)","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:20Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-300","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:20Z","created_by":"claude"}]}
{"id":"pivot-301","title":"Update template parser for executor field","description":"# Update Template Parser for Executor Field\n\n## File: internal/template/module.go\n\n## Changes\n\n### Step struct update\n\n```go\n// Before\ntype Step struct {\n    ID           string   `toml:\"id\"`\n    Type         string   `toml:\"type\"`  // ← Remove\n    Instructions string   `toml:\"instructions\"`\n    Assignee     string   `toml:\"assignee\"`\n    // ...\n}\n\n// After\ntype Step struct {\n    ID       string `toml:\"id\"`\n    Executor string `toml:\"executor\"` // ← Add\n\n    // Agent executor fields\n    Agent  string `toml:\"agent,omitempty\"`\n    Prompt string `toml:\"prompt,omitempty\"`\n    Mode   string `toml:\"mode,omitempty\"` // autonomous | interactive\n\n    // Shell executor fields\n    Command string `toml:\"command,omitempty\"`\n    Workdir string `toml:\"workdir,omitempty\"`\n    OnError string `toml:\"on_error,omitempty\"`\n\n    // Spawn executor fields (also uses Agent, Workdir)\n    ResumeSession string `toml:\"resume_session,omitempty\"`\n\n    // Kill executor fields (uses Agent)\n    Graceful *bool `toml:\"graceful,omitempty\"`\n    Timeout  int   `toml:\"timeout,omitempty\"`\n\n    // Expand executor fields\n    Template  string            `toml:\"template,omitempty\"`\n    Variables map[string]string `toml:\"variables,omitempty\"`\n\n    // Branch executor fields\n    Condition string               `toml:\"condition,omitempty\"`\n    OnTrue    *ExpansionTarget     `toml:\"on_true,omitempty\"`\n    OnFalse   *ExpansionTarget     `toml:\"on_false,omitempty\"`\n    OnTimeout *ExpansionTarget     `toml:\"on_timeout,omitempty\"`\n\n    // Gate executor fields (uses Prompt)\n    // Timeout already defined above\n\n    // Shared\n    Needs   []string          `toml:\"needs,omitempty\"`\n    Env     map[string]string `toml:\"env,omitempty\"`\n    Outputs map[string]any    `toml:\"outputs,omitempty\"`\n}\n```\n\n### Validation update\n\nValidate that required fields are present based on executor:\n\n```go\nfunc (s *Step) Validate() error {\n    switch s.Executor {\n    case \"shell\":\n        if s.Command == \"\" {\n            return fmt.Errorf(\"shell executor requires command\")\n        }\n    case \"agent\":\n        if s.Agent == \"\" {\n            return fmt.Errorf(\"agent executor requires agent\")\n        }\n        if s.Prompt == \"\" {\n            return fmt.Errorf(\"agent executor requires prompt\")\n        }\n    // ... etc\n    }\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Step struct uses executor field\n- [ ] All executor-specific fields present\n- [ ] Validation checks required fields per executor\n- [ ] Old 'type' field no longer parsed\n- [ ] Update all test templates\n- [ ] Unit tests for each executor type","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:21Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-301","depends_on_id":"pivot-103","type":"blocks","created_at":"2026-01-08T12:00:21Z","created_by":"claude"}]}
{"id":"pivot-302","title":"Remove ephemeral and hooks_to from workflow","description":"# Remove ephemeral and hooks_to from Workflow\n\n## File: internal/template/module.go\n\n## Changes\n\n### Remove from Workflow struct\n\n```go\n// Before\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Ephemeral   bool            `toml:\"ephemeral,omitempty\"`   // ← Remove\n    Internal    bool            `toml:\"internal,omitempty\"`\n    HooksTo     string          `toml:\"hooks_to,omitempty\"`    // ← Remove\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n\n// After\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Internal    bool            `toml:\"internal,omitempty\"`\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n```\n\n### Why These Are Removed\n\n**ephemeral**: Was used to mark workflows whose steps become \"wisps\" (agent-visible ephemeral steps). In the new model, there's no tier distinction - all steps are just steps.\n\n**hooks_to**: Was used to link wisp steps to a work bead ID. In the new model, MEOW is task-tracking agnostic - it doesn't know about beads.\n\n## Migration Note\n\nExisting templates with these fields will have them ignored (TOML parsing allows extra fields). We should update example templates to remove them.\n\n## Acceptance Criteria\n\n- [ ] ephemeral field removed from Workflow struct\n- [ ] hooks_to field removed from Workflow struct\n- [ ] Update all example templates\n- [ ] Update tests that used these fields\n- [ ] No runtime errors if old templates have these fields","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:22Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-302","depends_on_id":"pivot-300","type":"blocks","created_at":"2026-01-08T12:00:22Z","created_by":"claude"}]}
{"id":"pivot-303","title":"Refactor baker to create Steps instead of Beads","description":"# Refactor Baker to Create Steps Instead of Beads\n\n## File: internal/template/baker.go\n\n## The Big Change\n\nThe baker currently transforms template workflows into Bead objects. It needs to transform them into Step objects instead.\n\n### Before\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Bead, error) {\n    var beads []*types.Bead\n    for _, step := range workflow.Steps {\n        bead := b.workflowStepToBead(step, vars)\n        beads = append(beads, bead)\n    }\n    return beads, nil\n}\n```\n\n### After\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Step, error) {\n    var steps []*types.Step\n    for _, templateStep := range workflow.Steps {\n        step := b.templateStepToStep(templateStep, vars)\n        steps = append(steps, step)\n    }\n    return steps, nil\n}\n\nfunc (b *Baker) templateStepToStep(ts *Step, vars map[string]string) *types.Step {\n    step := \u0026types.Step{\n        ID:       ts.ID,\n        Executor: types.ExecutorType(ts.Executor),\n        Status:   types.StepStatusPending,\n        Needs:    ts.Needs,\n    }\n\n    // Set executor-specific config\n    switch step.Executor {\n    case types.ExecutorShell:\n        step.Shell = \u0026types.ShellConfig{\n            Command: substitute(ts.Command, vars),\n            Workdir: substitute(ts.Workdir, vars),\n            Env:     substituteMap(ts.Env, vars),\n            OnError: ts.OnError,\n        }\n    case types.ExecutorAgent:\n        step.Agent = \u0026types.AgentConfig{\n            Agent:  substitute(ts.Agent, vars),\n            Prompt: substitute(ts.Prompt, vars),\n            Mode:   types.AgentMode(ts.Mode),\n        }\n    // ... other executors\n    }\n\n    return step\n}\n```\n\n## What to Remove\n\n- Tier detection logic (determineTier)\n- HookBead assignment\n- SourceWorkflow assignment\n- All bead-specific field setting\n\n## Acceptance Criteria\n\n- [ ] Baker.Bake() returns []*types.Step\n- [ ] All 7 executor types create correct config\n- [ ] Variable substitution works in all fields\n- [ ] No tier/HookBead logic remains\n- [ ] Unit tests for each executor type","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:23Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-303","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"},{"issue_id":"pivot-303","depends_on_id":"pivot-302","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"}]}
{"id":"pivot-304","title":"Remove legacy [meta] format support","description":"# Remove Legacy [meta] Format Support\n\n## Context\n\nThe template system currently supports two formats:\n1. Legacy: `[meta]` section + `[[steps]]` array\n2. Module: `[workflow-name]` sections\n\nPer the clean break decision, we're removing legacy format support.\n\n## Files to Modify\n\n### internal/template/parser.go\n\n- Remove `ParseLegacy()` function\n- Remove format detection logic\n- Remove any `[meta]` parsing code\n\n### internal/template/module.go\n\n- Remove `IsLegacyFormat()` detection\n- Parser should only handle module format\n\n## Error Handling\n\nIf someone tries to use a legacy template:\n```\nError: Legacy template format ([meta] section) is no longer supported.\nPlease convert to module format. See docs/MVP-SPEC-v2.md for format.\n```\n\n## Acceptance Criteria\n\n- [ ] Legacy parser removed\n- [ ] Clear error for legacy templates\n- [ ] All example templates use module format\n- [ ] Tests updated to use module format only","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:24Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-304","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:24Z","created_by":"claude"}]}
{"id":"pivot-305","title":"Update example templates for new format","description":"# Update Example Templates for New Format\n\n## Files to Update\n\nAll templates in:\n- cmd/meow/cmd/templates/\n- examples/templates/\n- testdata/templates/\n\n## Changes Required\n\n1. `type` → `executor`\n2. `assignee` → `agent` (in step, for agent executor)\n3. `instructions` → `prompt`\n4. Remove `ephemeral` and `hooks_to`\n5. Add `mode` field for interactive steps (was `collaborative` type)\n\n## Example Conversion\n\n### Before\n```toml\n[main]\nephemeral = true\nhooks_to = \"work_bead\"\n\n[[main.steps]]\nid = \"do-work\"\ntype = \"task\"\nassignee = \"{{agent}}\"\ninstructions = \"Do the work\"\n```\n\n### After\n```toml\n[main]\nname = \"work\"\n\n[[main.steps]]\nid = \"do-work\"\nexecutor = \"agent\"\nagent = \"{{agent}}\"\nprompt = \"Do the work\"\nmode = \"autonomous\"\n```\n\n## Templates to Create\n\nNew canonical examples:\n- simple-agent.meow.toml - Single agent step\n- sequential.meow.toml - A → B → C\n- branching.meow.toml - Conditional flow\n- looping.meow.toml - Recursive expansion\n- multi-agent.meow.toml - Parallel agents\n- human-gate.meow.toml - Human approval flow\n\n## Acceptance Criteria\n\n- [ ] All existing templates converted\n- [ ] New canonical examples created\n- [ ] All templates validate successfully\n- [ ] README updated with new format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:25Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-305","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:25Z","created_by":"claude"}]}
{"id":"pivot-400","title":"EPIC: Orchestrator Refactor","description":"# Orchestrator Refactor\n\n## Current State\n\nThe orchestrator (`internal/orchestrator/orchestrator.go`) currently:\n- Uses BeadStore for state\n- Dispatches by BeadType (8 types)\n- Has tier-based priority sorting\n- Manages bead lifecycle\n\n## New Model\n\nThe orchestrator will:\n- Use WorkflowStore for state\n- Dispatch by ExecutorType (7 executors)\n- Simple priority: orchestrator executors before external\n- Manage step lifecycle within workflows\n\n## Key Changes\n\n### Main Loop\n\n```go\n// Before\nfor {\n    bead, _ := store.GetNextReady(ctx)\n    if bead == nil {\n        if store.AllDone(ctx) { break }\n        continue\n    }\n    dispatch(bead)\n}\n\n// After\nfor {\n    // Process all active workflows\n    for _, wf := range store.List(ctx, WorkflowFilter{Status: Running}) {\n        step := getNextReadyStep(wf)\n        if step == nil {\n            if wf.AllDone() {\n                wf.Complete()\n                store.Save(ctx, wf)\n            }\n            continue\n        }\n        dispatch(ctx, wf, step)\n        store.Save(ctx, wf)  // Persist after each step\n    }\n}\n```\n\n### Dispatch\n\n```go\n// Before\nswitch bead.Type {\ncase BeadTypeTask: handleTask(bead)\ncase BeadTypeCode: handleCode(bead)\n// ... 8 cases\n}\n\n// After\nswitch step.Executor {\ncase ExecutorShell:  handleShell(ctx, wf, step)\ncase ExecutorSpawn:  handleSpawn(ctx, wf, step)\ncase ExecutorKill:   handleKill(ctx, wf, step)\ncase ExecutorExpand: handleExpand(ctx, wf, step)\ncase ExecutorBranch: handleBranch(ctx, wf, step)\ncase ExecutorAgent:  handleAgent(ctx, wf, step)\ncase ExecutorGate:   handleGate(ctx, wf, step)\n}\n```\n\n## Files Affected\n\n- internal/orchestrator/orchestrator.go - Main refactor\n- internal/orchestrator/state.go - Use WorkflowStore\n- internal/orchestrator/expander.go - Update for Step model","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:30Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-400","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T12:00:30Z","created_by":"claude"},{"issue_id":"pivot-400","depends_on_id":"pivot-300","type":"blocks","created_at":"2026-01-08T12:00:30Z","created_by":"claude"}]}
{"id":"pivot-401","title":"Refactor orchestrator for WorkflowStore","description":"# Refactor Orchestrator for WorkflowStore\n\n## File: internal/orchestrator/orchestrator.go\n\n## Changes\n\n### Constructor\n\n```go\n// Before\nfunc New(cfg *config.Config, store BeadStore, agents AgentManager, ...) *Orchestrator\n\n// After\nfunc New(cfg *config.Config, store WorkflowStore, agents AgentManager, ...) *Orchestrator\n```\n\n### Main Loop\n\n```go\nfunc (o *Orchestrator) Run(ctx context.Context) error {\n    ticker := time.NewTicker(o.cfg.PollInterval)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case \u003c-ctx.Done():\n            return ctx.Err()\n        case \u003c-ticker.C:\n            if err := o.tick(ctx); err != nil {\n                if err == errAllDone {\n                    return nil\n                }\n                o.logger.Error(\"tick error\", \"error\", err)\n            }\n        }\n    }\n}\n\nfunc (o *Orchestrator) tick(ctx context.Context) error {\n    // Get all running workflows\n    workflows, _ := o.store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n\n    allComplete := true\n    for _, wf := range workflows {\n        if err := o.processWorkflow(ctx, wf); err != nil {\n            return err\n        }\n        if wf.Status == types.WorkflowStatusRunning {\n            allComplete = false\n        }\n    }\n\n    if allComplete \u0026\u0026 len(workflows) \u003e 0 {\n        return errAllDone\n    }\n    return nil\n}\n\nfunc (o *Orchestrator) processWorkflow(ctx context.Context, wf *types.Workflow) error {\n    readySteps := wf.GetReadySteps()\n    if len(readySteps) == 0 {\n        if wf.AllDone() {\n            wf.Complete()\n            return o.store.Save(ctx, wf)\n        }\n        if wf.HasFailed() {\n            wf.Fail()\n            return o.store.Save(ctx, wf)\n        }\n        return nil // Waiting for external completion\n    }\n\n    // Sort by priority: orchestrator executors first\n    sort.Slice(readySteps, func(i, j int) bool {\n        return readySteps[i].Executor.IsOrchestrator() \u0026\u0026 !readySteps[j].Executor.IsOrchestrator()\n    })\n\n    // Process first ready step\n    step := readySteps[0]\n    if err := o.dispatch(ctx, wf, step); err != nil {\n        return err\n    }\n\n    return o.store.Save(ctx, wf)\n}\n```\n\n### Dispatch\n\n```go\nfunc (o *Orchestrator) dispatch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    o.logger.Info(\"dispatching step\", \"id\", step.ID, \"executor\", step.Executor)\n\n    switch step.Executor {\n    case types.ExecutorShell:\n        return o.handleShell(ctx, wf, step)\n    case types.ExecutorSpawn:\n        return o.handleSpawn(ctx, wf, step)\n    case types.ExecutorKill:\n        return o.handleKill(ctx, wf, step)\n    case types.ExecutorExpand:\n        return o.handleExpand(ctx, wf, step)\n    case types.ExecutorBranch:\n        return o.handleBranch(ctx, wf, step)\n    case types.ExecutorAgent:\n        return o.handleAgent(ctx, wf, step)\n    case types.ExecutorGate:\n        return o.handleGate(ctx, wf, step)\n    default:\n        return fmt.Errorf(\"unknown executor: %s\", step.Executor)\n    }\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Constructor takes WorkflowStore\n- [ ] Main loop processes workflows not beads\n- [ ] Dispatch uses ExecutorType\n- [ ] Save workflow after each step\n- [ ] All 7 handlers updated\n- [ ] Tests use WorkflowStore","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:31Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-401","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"},{"issue_id":"pivot-401","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"}]}
{"id":"pivot-402","title":"Implement shell executor handler","description":"# Implement Shell Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleShell(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Shell == nil {\n        return fmt.Errorf(\"shell step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Execute command\n    outputs, err := o.executor.Execute(ctx, step.Shell)\n    if err != nil {\n        if step.Shell.OnError == \"continue\" {\n            o.logger.Warn(\"shell failed, continuing\", \"step\", step.ID, \"error\", err)\n            step.Complete(outputs)\n            return nil\n        }\n        step.Fail(\u0026types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(outputs)\n    return nil\n}\n```\n\n## Shell Executor Interface\n\n```go\ntype ShellExecutor interface {\n    Execute(ctx context.Context, cfg *types.ShellConfig) (map[string]any, error)\n}\n```\n\nThis should already exist from the old CodeExecutor - just needs interface rename.\n\n## Output Capture\n\nOutputs captured based on outputs config in template:\n- `stdout` - trimmed stdout\n- `stderr` - trimmed stderr\n- `exit_code` - integer exit code\n- `file:/path` - file contents\n\n## Acceptance Criteria\n\n- [ ] handleShell implementation\n- [ ] Uses ShellConfig from step\n- [ ] Respects on_error setting\n- [ ] Captures outputs correctly\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:32Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-402","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:32Z","created_by":"claude"}]}
{"id":"pivot-403","title":"Implement spawn executor handler","description":"# Implement Spawn Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleSpawn(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Spawn == nil {\n        return fmt.Errorf(\"spawn step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Build agent start config\n    cfg := \u0026agent.StartConfig{\n        AgentID:       step.Spawn.Agent,\n        Workdir:       step.Spawn.Workdir,\n        Env:           step.Spawn.Env,\n        Prompt:        step.Spawn.Prompt,\n        ResumeSession: step.Spawn.ResumeSession,\n    }\n\n    // Set default prompt\n    if cfg.Prompt == \"\" {\n        cfg.Prompt = \"meow prime\"\n    }\n\n    // Always set MEOW_AGENT env var\n    if cfg.Env == nil {\n        cfg.Env = make(map[string]string)\n    }\n    cfg.Env[\"MEOW_AGENT\"] = step.Spawn.Agent\n    cfg.Env[\"MEOW_WORKFLOW\"] = wf.ID\n\n    // Start agent\n    if err := o.agents.Start(ctx, cfg); err != nil {\n        step.Fail(\u0026types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Agent Manager Interface\n\n```go\ntype AgentManager interface {\n    Start(ctx context.Context, cfg *agent.StartConfig) error\n    Stop(ctx context.Context, cfg *agent.StopConfig) error\n    IsRunning(ctx context.Context, agentID string) (bool, error)\n}\n```\n\n## Key Behaviors\n\n1. Sets MEOW_AGENT and MEOW_WORKFLOW env vars\n2. Default prompt is \"meow prime\"\n3. Creates tmux session meow-{agent}\n4. Auto-completes when agent starts\n\n## Acceptance Criteria\n\n- [ ] handleSpawn implementation\n- [ ] Sets MEOW_AGENT env var\n- [ ] Sets MEOW_WORKFLOW env var\n- [ ] Default prompt handling\n- [ ] Resume session support\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:33Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-403","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:33Z","created_by":"claude"}]}
{"id":"pivot-404","title":"Implement kill executor handler","description":"# Implement Kill Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleKill(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Kill == nil {\n        return fmt.Errorf(\"kill step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    cfg := \u0026agent.StopConfig{\n        AgentID:  step.Kill.Agent,\n        Graceful: step.Kill.Graceful,\n        Timeout:  step.Kill.Timeout,\n    }\n\n    // Defaults\n    if cfg.Timeout == 0 {\n        cfg.Timeout = 10\n    }\n\n    if err := o.agents.Stop(ctx, cfg); err != nil {\n        // Log but don't fail - agent might already be dead\n        o.logger.Warn(\"kill step error\", \"step\", step.ID, \"error\", err)\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Graceful shutdown by default (SIGTERM, wait, SIGKILL)\n2. Default timeout 10 seconds\n3. Doesn't fail if agent already dead\n\n## Acceptance Criteria\n\n- [ ] handleKill implementation\n- [ ] Graceful shutdown support\n- [ ] Default timeout handling\n- [ ] Handles already-dead agents\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:34Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-404","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:34Z","created_by":"claude"}]}
{"id":"pivot-405","title":"Implement expand executor handler","description":"# Implement Expand Executor Handler\n\n## File: internal/orchestrator/executors/expand.go\n\n## Purpose\n\nExpand a template's steps into the current workflow. Handles:\n- Template resolution (same file, external file)\n- Variable substitution\n- Step ID prefixing for uniqueness\n- Tracking ExpandedFrom/ExpandedInto for crash recovery\n- Resource limit checking (depth and total steps)\n\n## Implementation\n\n\\`\\`\\`go\npackage executors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \n    \"github.com/meow-stack/meow-machine/internal/config\"\n    \"github.com/meow-stack/meow-machine/internal/template\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\ntype ExpandExecutor struct {\n    loader *template.Loader\n    limits *config.Limits\n}\n\nfunc NewExpandExecutor(loader *template.Loader, limits *config.Limits) *ExpandExecutor {\n    return \u0026ExpandExecutor{loader: loader, limits: limits}\n}\n\n// ExpansionContext tracks depth for resource limit checking.\ntype ExpansionContext struct {\n    Depth    int\n    MaxDepth int\n}\n\nfunc (e *ExpandExecutor) Execute(\n    ctx context.Context,\n    step *types.Step,\n    wf *types.Workflow,\n    subCtx *template.SubstitutionContext,\n    expCtx *ExpansionContext,\n) error {\n    // Check expansion depth limit\n    if expCtx.Depth \u003e= expCtx.MaxDepth {\n        return \u0026LimitExceededError{\n            Limit: \"max_expansion_depth\",\n            Value: expCtx.Depth,\n            Max:   expCtx.MaxDepth,\n        }\n    }\n    \n    cfg := step.Expand\n    \n    // Resolve template reference\n    tmpl, err := e.loader.Load(cfg.Template)\n    if err != nil {\n        return fmt.Errorf(\"loading template %s: %w\", cfg.Template, err)\n    }\n    \n    // Create substitution context with step's variables\n    childCtx := subCtx.WithVariables(cfg.Variables)\n    \n    // Expand template steps\n    expandedIDs := make([]string, 0)\n    for _, tmplStep := range tmpl.Steps {\n        // Prefix step ID with parent step ID for uniqueness\n        newID := step.ID + \".\" + tmplStep.ID\n        \n        // Clone and substitute\n        newStep, err := e.expandStep(tmplStep, newID, step.ID, childCtx)\n        if err != nil {\n            return fmt.Errorf(\"expanding step %s: %w\", tmplStep.ID, err)\n        }\n        \n        // Update dependencies to use prefixed IDs\n        newStep.Needs = e.prefixNeeds(tmplStep.Needs, step.ID, tmpl.Steps)\n        \n        // Track expansion relationship\n        newStep.ExpandedFrom = step.ID\n        \n        // Add to workflow\n        if err := wf.AddStep(newStep); err != nil {\n            return err\n        }\n        \n        expandedIDs = append(expandedIDs, newID)\n    }\n    \n    // Track what this step expanded into\n    step.ExpandedInto = expandedIDs\n    \n    // Check total steps limit\n    if len(wf.Steps) \u003e e.limits.MaxTotalSteps {\n        // Rollback: delete the steps we just added\n        for _, id := range expandedIDs {\n            delete(wf.Steps, id)\n        }\n        step.ExpandedInto = nil\n        \n        return \u0026LimitExceededError{\n            Limit: \"max_total_steps\",\n            Value: len(wf.Steps),\n            Max:   e.limits.MaxTotalSteps,\n        }\n    }\n    \n    // Success - mark step done\n    step.Status = types.StepStatusDone\n    \n    return nil\n}\n\nfunc (e *ExpandExecutor) expandStep(\n    tmpl *types.Step,\n    newID string,\n    parentID string,\n    ctx *template.SubstitutionContext,\n) (*types.Step, error) {\n    // Clone the step\n    newStep := \u0026types.Step{\n        ID:       newID,\n        Executor: tmpl.Executor,\n        Status:   types.StepStatusPending,\n    }\n    \n    // Substitute variables in config based on executor type\n    // ... (executor-specific substitution)\n    \n    return newStep, nil\n}\n\nfunc (e *ExpandExecutor) prefixNeeds(needs []string, parentID string, tmplSteps []*types.Step) []string {\n    // Build set of step IDs in template\n    tmplIDs := make(map[string]bool)\n    for _, s := range tmplSteps {\n        tmplIDs[s.ID] = true\n    }\n    \n    result := make([]string, len(needs))\n    for i, need := range needs {\n        if tmplIDs[need] {\n            // Internal dependency - prefix\n            result[i] = parentID + \".\" + need\n        } else {\n            // External dependency - keep as-is\n            result[i] = need\n        }\n    }\n    \n    // Add dependency on parent expand step\n    result = append(result, parentID)\n    \n    return result\n}\n\\`\\`\\`\n\n## Template Resolution\n\n| Reference | Resolution |\n|-----------|------------|\n| \\`.tdd\\` | Same file, workflow named \\`tdd\\` |\n| \\`main\\` | Same file, workflow named \\`main\\` |\n| \\`helpers#tdd\\` | File \\`helpers.meow.toml\\`, workflow \\`tdd\\` |\n| \\`helpers\\` | File \\`helpers.meow.toml\\`, workflow \\`main\\` |\n| \\`./lib/utils#helper\\` | Relative path |\n\n## Step ID Prefixing\n\nExpanded steps get prefixed IDs for uniqueness:\n- Parent step: \\`implement\\`\n- Template steps: \\`load\\`, \\`test\\`, \\`code\\`\n- Expanded IDs: \\`implement.load\\`, \\`implement.test\\`, \\`implement.code\\`\n\nRecursive expansion continues prefixing:\n- \\`implement.continue.find-work\\`\n- \\`implement.continue.continue.find-work\\`\n\n## Acceptance Criteria\n\n- [ ] Template loading via Loader\n- [ ] Variable substitution in expanded steps\n- [ ] Step ID prefixing for uniqueness\n- [ ] Dependency prefixing for internal refs\n- [ ] ExpandedFrom set on child steps\n- [ ] ExpandedInto set on parent step\n- [ ] Expansion depth limit checking\n- [ ] Total steps limit checking with rollback\n- [ ] Unit tests for template resolution\n- [ ] Unit tests for step prefixing\n- [ ] Unit tests for limit enforcement\n- [ ] Integration test with nested expansions","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:35Z","created_by":"claude","updated_at":"2026-01-08T20:31:52.476120446-05:00","dependencies":[{"issue_id":"pivot-405","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:35Z","created_by":"claude"}]}
{"id":"pivot-406","title":"Implement branch executor handler","description":"# Implement Branch Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\nBranch evaluation runs in a goroutine because the condition may block.\n\n```go\nfunc (o *Orchestrator) handleBranch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Branch == nil {\n        return fmt.Errorf(\"branch step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Save initial state\n    o.store.Save(ctx, wf)\n\n    // Run condition in goroutine (may block)\n    go o.evalBranch(ctx, wf.ID, step.ID)\n\n    return nil\n}\n\nfunc (o *Orchestrator) evalBranch(ctx context.Context, workflowID, stepID string) {\n    // Load fresh workflow state\n    wf, err := o.store.Get(ctx, workflowID)\n    if err != nil {\n        o.logger.Error(\"loading workflow for branch\", \"error\", err)\n        return\n    }\n    step := wf.Steps[stepID]\n\n    // Parse timeout\n    var timeout time.Duration\n    if step.Branch.Timeout != \"\" {\n        timeout, _ = time.ParseDuration(step.Branch.Timeout)\n    }\n\n    // Execute condition\n    execCtx := ctx\n    if timeout \u003e 0 {\n        var cancel context.CancelFunc\n        execCtx, cancel = context.WithTimeout(ctx, timeout)\n        defer cancel()\n    }\n\n    shellCfg := \u0026types.ShellConfig{Command: step.Branch.Condition}\n    outputs, err := o.executor.Execute(execCtx, shellCfg)\n\n    // Determine which branch to take\n    var target *types.BranchTarget\n    if execCtx.Err() == context.DeadlineExceeded {\n        target = step.Branch.OnTimeout\n        if target == nil {\n            target = step.Branch.OnFalse\n        }\n    } else if err != nil {\n        target = step.Branch.OnFalse\n    } else {\n        exitCode, _ := outputs[\"exit_code\"].(int)\n        if exitCode == 0 {\n            target = step.Branch.OnTrue\n        } else {\n            target = step.Branch.OnFalse\n        }\n    }\n\n    // Expand target\n    if target != nil {\n        if err := o.expandBranchTarget(ctx, wf, step, target); err != nil {\n            o.logger.Error(\"expanding branch\", \"step\", stepID, \"error\", err)\n        }\n    }\n\n    // Complete step\n    step.Complete(nil)\n    o.store.Save(ctx, wf)\n}\n```\n\n## Key Behaviors\n\n1. Condition runs in goroutine (non-blocking)\n2. Timeout support with fallback to on_false\n3. Exit code 0 = true, anything else = false\n4. Expand either template or inline steps\n\n## Acceptance Criteria\n\n- [ ] handleBranch implementation\n- [ ] Goroutine execution\n- [ ] Timeout handling\n- [ ] True/false/timeout branching\n- [ ] Template expansion\n- [ ] Inline step expansion\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:36Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-406","depends_on_id":"pivot-405","type":"blocks","created_at":"2026-01-08T12:00:36Z","created_by":"claude"}]}
{"id":"pivot-407","title":"Implement agent executor handler","description":"# Implement Agent Executor Handler\n\n## File: internal/orchestrator/executors/agent.go\n\n## Purpose\n\nHandle agent steps: inject prompt, wait for meow done, validate outputs. Key responsibilities:\n- Mark step running and inject prompt via tmux\n- Handle meow done IPC with completing status transition\n- Validate outputs against definitions (including file_path scope)\n- Handle autonomous vs interactive mode for stop hook\n\n## Implementation\n\n\\`\\`\\`go\npackage executors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \n    \"github.com/meow-stack/meow-machine/internal/ipc\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\ntype AgentExecutor struct {\n    agents    *AgentManager\n    validator *OutputValidator\n    tmux      *TmuxManager\n}\n\nfunc NewAgentExecutor(agents *AgentManager, validator *OutputValidator, tmux *TmuxManager) *AgentExecutor {\n    return \u0026AgentExecutor{\n        agents:    agents,\n        validator: validator,\n        tmux:      tmux,\n    }\n}\n\n// Start marks step running and injects prompt.\nfunc (e *AgentExecutor) Start(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    cfg := step.Agent\n    \n    // Mark step running\n    step.Status = types.StepStatusRunning\n    \n    // Update agent's current step\n    e.agents.SetCurrentStep(cfg.Agent, step.ID)\n    \n    // Build prompt with expected outputs\n    prompt := e.buildPrompt(cfg)\n    \n    // Inject prompt via tmux send-keys\n    session := e.agents.GetSession(cfg.Agent)\n    if err := e.tmux.SendKeys(ctx, session, prompt); err != nil {\n        return fmt.Errorf(\"injecting prompt: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (e *AgentExecutor) buildPrompt(cfg *types.AgentConfig) string {\n    prompt := cfg.Prompt\n    \n    // Add output expectations if defined\n    if len(cfg.Outputs) \u003e 0 {\n        prompt += \"\\n\\n## Expected Outputs\\n\\n\"\n        prompt += \"When complete, run: meow done --output \u003ckey\u003e=\u003cvalue\u003e\\n\\n\"\n        for name, def := range cfg.Outputs {\n            required := \"\"\n            if def.Required {\n                required = \" (required)\"\n            }\n            prompt += fmt.Sprintf(\"- %s (%s)%s\", name, def.Type, required)\n            if def.Description != \"\" {\n                prompt += \": \" + def.Description\n            }\n            prompt += \"\\n\"\n        }\n    } else {\n        prompt += \"\\n\\nWhen complete, run: meow done\"\n    }\n    \n    return prompt\n}\n\n// HandleCompletion processes meow done from agent.\nfunc (e *AgentExecutor) HandleCompletion(\n    ctx context.Context,\n    step *types.Step,\n    wf *types.Workflow,\n    msg *ipc.StepDoneMessage,\n) error {\n    cfg := step.Agent\n    \n    // Transition to completing\n    if err := step.SetCompleting(); err != nil {\n        return err\n    }\n    \n    // Validate outputs if defined\n    if cfg.Outputs != nil {\n        errs := e.validator.ValidateOutputs(msg.Outputs, cfg.Outputs, cfg.Agent)\n        if len(errs) \u003e 0 {\n            // Validation failed - back to running\n            step.Status = types.StepStatusRunning\n            \n            // Return error message to agent\n            return \u0026ValidationFailedError{\n                Errors: errs,\n                Defs:   cfg.Outputs,\n            }\n        }\n    }\n    \n    // Validation passed - complete\n    step.Complete(msg.Outputs)\n    \n    // Mark agent as idle (no current step)\n    e.agents.SetIdle(cfg.Agent)\n    \n    return nil\n}\n\n// GetPromptForHook returns prompt for stop hook query.\nfunc (e *AgentExecutor) GetPromptForHook(step *types.Step) string {\n    cfg := step.Agent\n    \n    // Check step status\n    switch step.Status {\n    case types.StepStatusCompleting:\n        // Transition in progress, stay quiet\n        return \"\"\n        \n    case types.StepStatusRunning:\n        // Check mode\n        if cfg.Mode == types.AgentModeInteractive {\n            // Interactive mode - allow human conversation\n            return \"\"\n        }\n        // Autonomous mode - re-inject prompt as nudge\n        return e.buildPrompt(cfg)\n        \n    default:\n        // Not running/completing - agent is idle\n        return \"\"\n    }\n}\n\\`\\`\\`\n\n## Mode Handling\n\n\\`\\`\\`go\n// AgentMode determines stop hook behavior.\ntype AgentMode string\n\nconst (\n    AgentModeAutonomous  AgentMode = \"autonomous\"  // Default - stop hook re-injects prompt\n    AgentModeInteractive AgentMode = \"interactive\" // Stop hook returns empty, allows conversation\n)\n\\`\\`\\`\n\n**Autonomous mode (default):**\n- Stop hook fires → meow prime → returns current prompt\n- This \"nudges\" Claude to continue working\n- Ralph Wiggum loop ensures persistence\n\n**Interactive mode:**\n- Stop hook fires → meow prime → returns empty\n- Claude waits for human input\n- Enables natural conversation during step execution\n\n## Step Completion Flow\n\n\\`\\`\\`\n1. Agent calls: meow done --output x=y\n2. meow done CLI → IPC → Orchestrator\n3. Orchestrator: step.SetCompleting()\n4. Orchestrator: validate outputs\n   - If invalid: step.Status = running, return error to agent\n   - If valid: step.Complete(outputs)\n5. Orchestrator: send ESC to agent tmux session\n6. Orchestrator: find next step for this agent\n7. If found: inject next prompt\n8. If not found: agent sits idle (stop hook returns empty)\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Start() marks step running and injects prompt\n- [ ] buildPrompt() includes output expectations\n- [ ] HandleCompletion() uses completing status\n- [ ] Output validation with file_path scope\n- [ ] Validation failure returns step to running\n- [ ] GetPromptForHook() handles all statuses\n- [ ] Mode handling (autonomous vs interactive)\n- [ ] Agent state updates (current step, idle)\n- [ ] Unit tests for prompt building\n- [ ] Unit tests for completion flow\n- [ ] Unit tests for mode handling\n- [ ] Integration with IPC server","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:37Z","created_by":"claude","updated_at":"2026-01-08T20:32:26.948622068-05:00","dependencies":[{"issue_id":"pivot-407","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:37Z","created_by":"claude"}]}
{"id":"pivot-408","title":"Implement gate executor handler","description":"# Implement Gate Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleGate(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Gate == nil {\n        return fmt.Errorf(\"gate step %s missing config\", step.ID)\n    }\n\n    // Mark running - human will complete via meow approve/reject\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    o.logger.Info(\"gate awaiting approval\",\n        \"workflow\", wf.ID,\n        \"step\", step.ID,\n    )\n\n    return nil\n}\n```\n\n## Key Points\n\n1. **External completion** - Human runs `meow approve` or `meow reject`\n2. **No assignee** - Gates are human-facing, not agent-facing\n3. **Timeout handling** - Future enhancement (auto-reject after timeout)\n\n## Completion Flow\n\n```\n1. handleGate marks step running\n2. Human sees gate via meow gates\n3. Human runs meow approve wf-xxx step-id\n4. meow approve finds step, marks done\n5. Next tick, orchestrator sees step is done\n\nOR\n\n3. Human runs meow reject wf-xxx step-id --reason \"...\"\n4. meow reject finds step, marks failed with reason\n5. Workflow may fail depending on error handling\n```\n\n## Acceptance Criteria\n\n- [ ] handleGate implementation\n- [ ] Marks step running\n- [ ] Logs for visibility\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:38Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-408","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:38Z","created_by":"claude"}]}
{"id":"pivot-409","title":"Implement crash recovery for workflows","description":"# Implement Crash Recovery for Workflows\n\n## File: internal/orchestrator/orchestrator.go\n\n## Recovery Protocol\n\nOn orchestrator startup:\n\n```go\nfunc (o *Orchestrator) Recover(ctx context.Context) error {\n    // Load all running workflows\n    workflows, err := o.store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n    if err != nil {\n        return err\n    }\n\n    for _, wf := range workflows {\n        modified := false\n        \n        // First pass: identify and clean up partial expansions\n        partialExpands := make(map[string]bool)\n        for _, step := range wf.Steps {\n            if step.Executor == types.ExecutorExpand \u0026\u0026 step.Status == types.StepStatusRunning {\n                partialExpands[step.ID] = true\n            }\n        }\n        \n        // Delete any partially-expanded child steps\n        for stepID, step := range wf.Steps {\n            if step.ExpandedFrom != \"\" \u0026\u0026 partialExpands[step.ExpandedFrom] {\n                o.logger.Info(\"deleting partial expansion child\", \"step\", stepID, \"parent\", step.ExpandedFrom)\n                delete(wf.Steps, stepID)\n                modified = true\n            }\n        }\n        \n        // Second pass: handle running/completing steps\n        for _, step := range wf.Steps {\n            if step.Status != types.StepStatusRunning \u0026\u0026 step.Status != types.StepStatusCompleting {\n                continue\n            }\n            \n            // Treat \"completing\" as \"running\" for recovery purposes\n            // (orchestrator crashed during transition)\n            \n            // Handle based on executor type\n            if step.Executor.IsOrchestrator() {\n                // Orchestrator step was mid-execution - reset\n                o.logger.Info(\"resetting orchestrator step\", \"step\", step.ID, \"was_status\", step.Status)\n                step.Status = types.StepStatusPending\n                step.StartedAt = nil\n                modified = true\n            } else if step.Executor == types.ExecutorAgent {\n                // Check if agent is still alive\n                running, _ := o.agents.IsRunning(ctx, step.Agent.Agent)\n                if !running {\n                    // Agent dead - reset to pending (will need respawn)\n                    o.logger.Info(\"resetting step from dead agent\",\n                        \"step\", step.ID,\n                        \"agent\", step.Agent.Agent,\n                    )\n                    step.Status = types.StepStatusPending\n                    step.StartedAt = nil\n                    modified = true\n                } else {\n                    // Agent still alive - keep running\n                    // Don't immediately re-inject prompt!\n                    // Wait for either:\n                    // - Agent to call meow done (normal completion)\n                    // - Stop hook to fire (calls meow prime, gets current prompt)\n                    // This avoids injecting duplicate prompts\n                    if step.Status == types.StepStatusCompleting {\n                        step.Status = types.StepStatusRunning\n                        modified = true\n                    }\n                }\n            }\n            // Gates stay running - human might still approve\n        }\n\n        if modified {\n            o.store.Save(ctx, wf)\n        }\n    }\n\n    return nil\n}\n```\n\n## Recovery Rules\n\n| Executor | Status | Recovery Action |\n|----------|--------|-----------------|\n| shell, spawn, kill, expand, branch | running | Reset to pending |\n| shell, spawn, kill, expand, branch | completing | Reset to pending |\n| expand | running | Delete partial child steps, reset to pending |\n| agent | running (agent alive) | Keep running, wait for stop hook |\n| agent | running (agent dead) | Reset to pending |\n| agent | completing | Set to running, wait for stop hook |\n| gate | running | Keep running (human might approve) |\n\n## Partial Expansion Recovery\n\nIf an \\`expand\\` step was \\`running\\` when orchestrator crashed:\n1. The workflow file may contain partially-inserted child steps\n2. Find all steps with \\`expanded_from: \u003cexpand-step-id\u003e\\`\n3. Delete these partial child steps from the workflow\n4. Reset the expand step to \\`pending\\`\n5. The expand will run cleanly on resume\n\n## Agent Re-injection Strategy\n\nFor agent steps that remain \\`running\\` after recovery (agent still alive):\n- DO NOT immediately re-inject the prompt\n- The agent may still be working\n- Wait for either:\n  - Agent calls \\`meow done\\` (normal completion)\n  - Stop hook fires (calls \\`meow prime\\` which returns current prompt)\n- This avoids injecting duplicate prompts into a working agent\n\n## Acceptance Criteria\n\n- [ ] Recover() method handles all step statuses\n- [ ] Correctly handles \\`completing\\` status (treat as running)\n- [ ] Deletes partially-expanded child steps\n- [ ] Resets orchestrator steps to pending\n- [ ] Checks agent tmux sessions via agents.IsRunning()\n- [ ] Keeps live agents running without re-injection\n- [ ] Preserves gate steps\n- [ ] Unit tests for each recovery scenario\n- [ ] Integration test with simulated crash during expansion","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:39Z","created_by":"claude","updated_at":"2026-01-08T20:26:48.216368564-05:00","dependencies":[{"issue_id":"pivot-409","depends_on_id":"pivot-408","type":"blocks","created_at":"2026-01-08T12:00:39Z","created_by":"claude"}]}
{"id":"pivot-410","title":"Remove tier-based logic from orchestrator","description":"# Remove Tier-Based Logic from Orchestrator\n\n## Context\n\nThe current orchestrator has tier-aware logic:\n- Priority sorting by tier\n- Wisp burning/cleanup\n- Tier filtering in queries\n\nAll of this should be removed.\n\n## Code to Remove\n\n### internal/orchestrator/orchestrator.go\n\n```go\n// Remove these functions\nfunc (o *Orchestrator) cleanupWorkflow(...)\nfunc (o *Orchestrator) burnWisps(...)\nfunc (o *Orchestrator) squashWisps(...)\nfunc (o *Orchestrator) generateWispDigest(...)\n\n// Remove tier-based priority in GetNextReady\nfunc tierPriority(tier BeadTier) int { ... }\n```\n\n### internal/orchestrator/beadstore.go\n\nThis entire file is removed in pivot-204.\n\n## New Priority Logic\n\nSimpler: orchestrator executors before external.\n\n```go\nsort.Slice(readySteps, func(i, j int) bool {\n    return readySteps[i].Executor.IsOrchestrator() \u0026\u0026 \n           !readySteps[j].Executor.IsOrchestrator()\n})\n```\n\n## Acceptance Criteria\n\n- [ ] No references to BeadTier\n- [ ] No wisp burning code\n- [ ] Simple priority logic\n- [ ] All tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:40Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-410","depends_on_id":"pivot-409","type":"blocks","created_at":"2026-01-08T12:00:40Z","created_by":"claude"}]}
{"id":"pivot-500","title":"EPIC: CLI Alignment","description":"# CLI Alignment\n\n## Overview\n\nThe CLI commands need updates to work with the new workflow model.\n\n## Key Changes\n\n| Old | New | Notes |\n|-----|-----|-------|\n| meow close | meow done | Signals step completion |\n| meow prime (bead-centric) | meow prime (step-centric) | Shows current step |\n| meow approve/reject | Same | Works with workflow/step IDs |\n| meow status | Same | Shows workflow status |\n| meow run | Same | Creates and runs workflow |\n\n## New Behaviors\n\n### meow done\n\n```bash\n# Before (bead-centric)\nmeow close meow-abc.step-1 --output key=value\n\n# After (agent-centric)\nmeow done --output key=value\n# Uses MEOW_AGENT env var to find current step\n```\n\n### meow prime\n\n```bash\n# Returns prompt for current step only\n# No tier filtering - just finds running agent step\n# Returns empty for interactive mode or no work\n```\n\n### meow approve/reject\n\n```bash\nmeow approve wf-abc123 gate-step-id\nmeow reject wf-abc123 gate-step-id --reason \"...\"\n```\n\n## Files Affected\n\n- cmd/meow/cmd/done.go (rename from close.go)\n- cmd/meow/cmd/prime.go\n- cmd/meow/cmd/approve.go\n- cmd/meow/cmd/reject.go\n- cmd/meow/cmd/run.go\n- cmd/meow/cmd/status.go","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:50Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-500","depends_on_id":"pivot-400","type":"blocks","created_at":"2026-01-08T12:00:50Z","created_by":"claude"}]}
{"id":"pivot-501","title":"Implement meow done command","description":"# Implement meow done Command\n\n## File: cmd/meow/cmd/done.go (rename from close.go)\n\n## Usage\n\n```bash\n# Simple completion\nmeow done\n\n# With outputs\nmeow done --output key=value --output other=value2\n\n# With JSON outputs\nmeow done --output-json '{\"key\": \"value\"}'\n\n# With notes\nmeow done --notes \"Completed successfully\"\n```\n\n## Implementation\n\n```go\nvar doneCmd = \u0026cobra.Command{\n    Use:   \"done\",\n    Short: \"Signal step completion\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        // Get agent ID from environment\n        agentID := os.Getenv(\"MEOW_AGENT\")\n        if agentID == \"\" {\n            return fmt.Errorf(\"MEOW_AGENT not set - are you running in a MEOW session?\")\n        }\n\n        // Find workflow with running step for this agent\n        store := getWorkflowStore()\n        workflows, _ := store.GetByAgent(ctx, agentID)\n\n        var targetWf *types.Workflow\n        var targetStep *types.Step\n        for _, wf := range workflows {\n            for _, step := range wf.Steps {\n                if step.Executor == types.ExecutorAgent \u0026\u0026\n                   step.Status == types.StepStatusRunning \u0026\u0026\n                   step.Agent.Agent == agentID {\n                    targetWf = wf\n                    targetStep = step\n                    break\n                }\n            }\n        }\n\n        if targetStep == nil {\n            return fmt.Errorf(\"no running step found for agent %s\", agentID)\n        }\n\n        // Parse outputs\n        outputs := parseOutputs(outputFlags, outputJSON)\n\n        // Validate outputs against step definition\n        if err := validateOutputs(targetStep.Agent.Outputs, outputs); err != nil {\n            return err\n        }\n\n        // Complete step\n        targetStep.Complete(outputs)\n        return store.Save(ctx, targetWf)\n    },\n}\n```\n\n## Output Validation\n\n```go\nfunc validateOutputs(defs map[string]types.OutputDef, outputs map[string]any) error {\n    for name, def := range defs {\n        val, ok := outputs[name]\n        if !ok \u0026\u0026 def.Required {\n            return fmt.Errorf(\"missing required output: %s\", name)\n        }\n        if ok {\n            if err := validateType(val, def.Type); err != nil {\n                return fmt.Errorf(\"output %s: %w\", name, err)\n            }\n        }\n    }\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Rename close.go to done.go\n- [ ] Uses MEOW_AGENT env var\n- [ ] Finds running step for agent\n- [ ] Parses --output and --output-json\n- [ ] Validates required outputs\n- [ ] Completes step\n- [ ] Clear error messages\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:51Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-501","depends_on_id":"pivot-407","type":"blocks","created_at":"2026-01-08T12:00:51Z","created_by":"claude"}]}
{"id":"pivot-502","title":"Update meow prime for workflow model","description":"# Update meow prime for Workflow Model\n\n## File: cmd/meow/cmd/prime.go\n\n## Usage\n\n```bash\n# Default - uses MEOW_AGENT env var\nmeow prime\n\n# Explicit agent\nmeow prime --agent claude-1\n\n# For stop-hook injection\nmeow prime --format prompt\n\n# Machine-readable\nmeow prime --format json\n```\n\n## Output Format (Human)\n\n```markdown\n## Write Tests\n\nWrite failing tests that define the expected behavior for PROJ-123.\n\n### Required Outputs\n- `test_file` (string): Path to the test file\n\n### When Done\nmeow done --output test_file=\u003cpath\u003e\n```\n\n## Implementation\n\n```go\nfunc runPrime(cmd *cobra.Command, args []string) error {\n    agentID := agentFlag\n    if agentID == \"\" {\n        agentID = os.Getenv(\"MEOW_AGENT\")\n    }\n    if agentID == \"\" {\n        return fmt.Errorf(\"agent not specified and MEOW_AGENT not set\")\n    }\n\n    store := getWorkflowStore()\n    workflows, _ := store.GetByAgent(ctx, agentID)\n\n    // Find running agent step for this agent\n    var step *types.Step\n    for _, wf := range workflows {\n        for _, s := range wf.Steps {\n            if s.Executor == types.ExecutorAgent \u0026\u0026\n               s.Status == types.StepStatusRunning \u0026\u0026\n               s.Agent.Agent == agentID {\n                step = s\n                break\n            }\n        }\n    }\n\n    if step == nil {\n        // No work - return empty for stop-hook\n        if format == \"prompt\" {\n            return nil\n        }\n        fmt.Println(\"No work assigned\")\n        return nil\n    }\n\n    // Check interactive mode\n    if step.Agent.Mode == types.AgentModeInteractive {\n        // Interactive mode - return empty to break auto-loop\n        if format == \"prompt\" {\n            return nil\n        }\n        fmt.Println(\"Interactive mode - waiting for conversation\")\n        return nil\n    }\n\n    // Format output\n    switch format {\n    case \"prompt\":\n        fmt.Print(formatPrompt(step))\n    case \"json\":\n        json.NewEncoder(os.Stdout).Encode(step)\n    default:\n        fmt.Print(formatHuman(step))\n    }\n\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Uses MEOW_AGENT env var by default\n2. Returns empty for interactive mode (breaks stop-hook loop)\n3. Returns empty if no work (workflow complete)\n4. Shows prompt and expected outputs\n\n## Acceptance Criteria\n\n- [ ] Uses MEOW_AGENT env var\n- [ ] Finds running agent step\n- [ ] Returns empty for interactive mode\n- [ ] Returns empty if no work\n- [ ] Formats prompt with outputs\n- [ ] --format prompt for stop-hook\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:52Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-502","depends_on_id":"pivot-407","type":"blocks","created_at":"2026-01-08T12:00:52Z","created_by":"claude"}]}
{"id":"pivot-503","title":"Update meow run for workflow model","description":"# Update meow run for Workflow Model\n\n## File: cmd/meow/cmd/run.go\n\n## Usage\n\n```bash\n# Run template\nmeow run template.meow.toml\n\n# Run specific workflow in module\nmeow run template.meow.toml#tdd\n\n# With variables\nmeow run template.meow.toml --var agent=claude-1 --var task_id=PROJ-123\n```\n\n## Implementation\n\n```go\nfunc runRun(cmd *cobra.Command, args []string) error {\n    templateRef := args[0]\n\n    // Parse variables\n    vars := parseVarFlags(varFlags)\n\n    // Load template\n    loader := template.NewLoader(searchPaths)\n    _, workflow, err := loader.Load(ctx, templateRef)\n    if err != nil {\n        return fmt.Errorf(\"loading template: %w\", err)\n    }\n\n    // Validate required variables\n    if err := validateVars(workflow.Variables, vars); err != nil {\n        return err\n    }\n\n    // Bake into steps\n    baker := template.NewBaker()\n    steps, err := baker.Bake(ctx, workflow, vars)\n    if err != nil {\n        return fmt.Errorf(\"baking template: %w\", err)\n    }\n\n    // Create workflow\n    wf := types.NewWorkflow(\n        orchestrator.GenerateWorkflowID(),\n        templateRef,\n        vars,\n    )\n    for _, step := range steps {\n        wf.AddStep(step)\n    }\n    wf.Status = types.WorkflowStatusRunning\n\n    // Persist workflow\n    store := getWorkflowStore()\n    if err := store.Create(ctx, wf); err != nil {\n        return fmt.Errorf(\"creating workflow: %w\", err)\n    }\n\n    fmt.Printf(\"Started workflow: %s\\n\", wf.ID)\n    fmt.Printf(\"Steps: %d\\n\", len(wf.Steps))\n\n    // Start orchestrator\n    orch := orchestrator.New(cfg, store, agents, loader, baker, executor, logger)\n    return orch.Run(ctx)\n}\n```\n\n## Key Changes from Old Version\n\n1. Creates Workflow not beads\n2. Uses WorkflowStore\n3. Starts orchestrator loop (was missing!)\n\n## Acceptance Criteria\n\n- [ ] Loads template\n- [ ] Validates variables\n- [ ] Bakes into steps\n- [ ] Creates workflow\n- [ ] Starts orchestrator\n- [ ] Prints workflow ID\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:53Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-503","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:53Z","created_by":"claude"},{"issue_id":"pivot-503","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T12:00:53Z","created_by":"claude"}]}
{"id":"pivot-504","title":"Update meow approve/reject for workflow model","description":"# Update meow approve/reject for Workflow Model\n\n## Files:\n- cmd/meow/cmd/approve.go\n- cmd/meow/cmd/reject.go\n\n## Usage\n\n```bash\nmeow approve wf-abc123 gate-step-id\nmeow approve wf-abc123 gate-step-id --notes \"LGTM\"\n\nmeow reject wf-abc123 gate-step-id --reason \"Missing tests\"\n```\n\n## Implementation (approve)\n\n```go\nvar approveCmd = \u0026cobra.Command{\n    Use:   \"approve \u003cworkflow-id\u003e \u003cstep-id\u003e\",\n    Short: \"Approve a gate step\",\n    Args:  cobra.ExactArgs(2),\n    RunE: func(cmd *cobra.Command, args []string) error {\n        workflowID := args[0]\n        stepID := args[1]\n\n        store := getWorkflowStore()\n        wf, err := store.Get(ctx, workflowID)\n        if err != nil {\n            return fmt.Errorf(\"loading workflow: %w\", err)\n        }\n        if wf == nil {\n            return fmt.Errorf(\"workflow not found: %s\", workflowID)\n        }\n\n        step, ok := wf.Steps[stepID]\n        if !ok {\n            return fmt.Errorf(\"step not found: %s\", stepID)\n        }\n\n        if step.Executor != types.ExecutorGate {\n            return fmt.Errorf(\"step %s is not a gate (executor: %s)\", stepID, step.Executor)\n        }\n\n        if step.Status != types.StepStatusRunning {\n            return fmt.Errorf(\"gate not pending approval (status: %s)\", step.Status)\n        }\n\n        step.Complete(map[string]any{\"approved\": true, \"notes\": notes})\n        if err := store.Save(ctx, wf); err != nil {\n            return fmt.Errorf(\"saving workflow: %w\", err)\n        }\n\n        fmt.Printf(\"Approved: %s\\n\", stepID)\n        return nil\n    },\n}\n```\n\n## Implementation (reject)\n\nSimilar but marks step as failed:\n\n```go\nstep.Fail(\u0026types.StepError{\n    Message: reason,\n})\n```\n\n## Acceptance Criteria\n\n- [ ] approve loads workflow and step\n- [ ] Validates step is a gate\n- [ ] Validates gate is running\n- [ ] Marks step done with approval info\n- [ ] reject marks step failed with reason\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:54Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-504","depends_on_id":"pivot-408","type":"blocks","created_at":"2026-01-08T12:00:54Z","created_by":"claude"}]}
{"id":"pivot-505","title":"Update meow status for workflow model","description":"# Update meow status for Workflow Model\n\n## File: cmd/meow/cmd/status.go\n\n## Usage\n\n```bash\n# List all workflows\nmeow status\n\n# Show specific workflow\nmeow status wf-abc123\n\n# Show with steps\nmeow status wf-abc123 --steps\n\n# JSON output\nmeow status --json\n```\n\n## Output Format\n\n```\nWorkflows:\n  wf-abc123  running   work-loop.meow.toml    5/10 steps done\n  wf-def456  done      deploy.meow.toml       12/12 steps done\n\n$ meow status wf-abc123 --steps\nWorkflow: wf-abc123\nTemplate: work-loop.meow.toml\nStatus:   running\nStarted:  2026-01-08 21:00:00\n\nSteps:\n  ✓ select              done      agent      00:02:00\n  ✓ implement           done      expand     00:00:01\n  ✓ implement.load      done      agent      00:03:00\n  → implement.tests     running   agent      00:05:00\n  ○ implement.impl      pending   agent\n  ○ implement.commit    pending   agent\n```\n\n## Implementation\n\nUpdate to use WorkflowStore and show workflow/step structure.\n\n## Acceptance Criteria\n\n- [ ] Lists all workflows\n- [ ] Shows workflow details\n- [ ] Shows steps with --steps flag\n- [ ] JSON output format\n- [ ] No tier/bead references\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:55Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-505","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:55Z","created_by":"claude"}]}
{"id":"pivot-506","title":"Update meow gates command","description":"# Update meow gates Command\n\n## File: cmd/meow/cmd/gates.go (may need to create)\n\n## Usage\n\n```bash\n# List all pending gates\nmeow gates\n\n# Filter by workflow\nmeow gates --workflow wf-abc123\n```\n\n## Output Format\n\n```\nPending Gates:\n\nWorkflow: wf-abc123\nStep:     review-gate\nPrompt:\n  Review the implementation for PROJ-123.\n  Changes: Added auth endpoint\n  Approve if ready to merge.\n\nCommands:\n  meow approve wf-abc123 review-gate\n  meow reject wf-abc123 review-gate --reason \"...\"\n\n---\n\nWorkflow: wf-def456\nStep:     deploy-approval\n...\n```\n\n## Implementation\n\n```go\nfunc runGates(cmd *cobra.Command, args []string) error {\n    store := getWorkflowStore()\n    workflows, _ := store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n\n    var gates []*gateInfo\n    for _, wf := range workflows {\n        if workflowFilter != \"\" \u0026\u0026 wf.ID != workflowFilter {\n            continue\n        }\n        for _, step := range wf.Steps {\n            if step.Executor == types.ExecutorGate \u0026\u0026 step.Status == types.StepStatusRunning {\n                gates = append(gates, \u0026gateInfo{wf, step})\n            }\n        }\n    }\n\n    if len(gates) == 0 {\n        fmt.Println(\"No pending gates\")\n        return nil\n    }\n\n    for _, g := range gates {\n        formatGate(g)\n    }\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Lists pending gates\n- [ ] Shows prompt for each gate\n- [ ] Shows approve/reject commands\n- [ ] Filter by workflow\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:56Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-506","depends_on_id":"pivot-408","type":"blocks","created_at":"2026-01-08T12:00:56Z","created_by":"claude"}]}
{"id":"pivot-507","title":"Remove bead-specific CLI code","description":"# Remove Bead-Specific CLI Code\n\n## Context\n\nOnce all CLI commands are updated, remove any remaining bead-specific code.\n\n## Files to Clean Up\n\n- Remove references to BeadStore\n- Remove tier filtering in queries\n- Remove HookBead display\n- Remove bead ID parsing\n\n## Specifically\n\n- cmd/meow/cmd/close.go - DELETE (renamed to done.go)\n- Any helper functions for bead queries\n- Any formatting code for bead output\n\n## Acceptance Criteria\n\n- [ ] No BeadStore references in CLI\n- [ ] No tier filtering\n- [ ] close.go removed\n- [ ] All CLI tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:57Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-507","depends_on_id":"pivot-501","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-502","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-503","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-504","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-505","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"}]}
{"id":"pivot-600","title":"EPIC: Documentation \u0026 Cleanup","description":"# Documentation \u0026 Cleanup\n\n## Overview\n\nFinal phase: update all documentation and clean up dead code.\n\n## Documentation Updates\n\n1. **ARCHITECTURE.md** - Complete rewrite\n   - Remove three-tier model\n   - Document 7 executors\n   - Update component diagram\n   - Update interfaces\n\n2. **CLAUDE.md** - Update agent instructions\n   - Remove molecule/wisp references\n   - Simplify to: meow prime, meow done\n   - Update command reference\n\n3. **README.md** - Update getting started\n   - New template format\n   - New CLI commands\n   - New concepts\n\n4. **MVP-SPEC-v2.md** - Already done (the source of this pivot)\n\n5. **IMPLEMENTATION-GUIDE.md** - Already done\n\n## Code Cleanup\n\n1. Delete internal/types/bead.go\n2. Delete internal/orchestrator/beadstore.go\n3. Delete tier-related code\n4. Delete legacy template parser\n5. Clean up unused imports\n\n## Testing Cleanup\n\n1. Update all tests to use new types\n2. Remove bead-based test fixtures\n3. Add workflow-based test fixtures\n4. Ensure full coverage","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:59Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-600","depends_on_id":"pivot-500","type":"blocks","created_at":"2026-01-08T12:00:59Z","created_by":"claude"}]}
{"id":"pivot-601","title":"Rewrite ARCHITECTURE.md","description":"# Rewrite ARCHITECTURE.md\n\n## File: ARCHITECTURE.md\n\n## New Structure\n\n1. **The One Sentence** - MEOW is a workflow execution engine that coordinates AI agents through programmable templates.\n\n2. **Core Concepts**\n   - Templates = Programs (TOML)\n   - Workflows = Running instances (YAML state)\n   - Steps = Instructions\n   - Executors = Who runs each step\n\n3. **The 7 Executors**\n   - Table with orchestrator vs external\n   - Each executor's purpose and config\n\n4. **Data Flow**\n   - Template → Parse → Bake → Workflow → Execute\n   - Step outputs → Variable substitution\n\n5. **Component Diagram**\n   - Updated for new architecture\n   - No BeadStore, no tiers\n\n6. **Key Interfaces**\n   - WorkflowStore\n   - AgentManager\n   - ShellExecutor\n   - TemplateLoader\n   - Baker\n\n7. **File Layout**\n   - Updated directory structure\n\n## What to Remove\n\n- Three-tier model section\n- Bead types table\n- Wisp lifecycle section\n- HookBead concept\n- Beads integration section\n\n## Acceptance Criteria\n\n- [ ] New architecture documented\n- [ ] No tier references\n- [ ] No bead references\n- [ ] Accurate component diagram\n- [ ] Accurate interfaces","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:01:01Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-601","depends_on_id":"pivot-410","type":"blocks","created_at":"2026-01-08T12:01:01Z","created_by":"claude"}]}
{"id":"pivot-602","title":"Update CLAUDE.md for new model","description":"# Update CLAUDE.md for New Model\n\n## File: CLAUDE.md\n\n## Key Changes\n\n### Remove\n- References to molecules\n- References to wisps\n- References to tiers\n- `bd mol stack`, `bd mol current` commands\n- HookBead concept\n\n### Update\n- \"At Session Start\" - Use `meow prime` to see current work\n- \"During Execution\" - Run `meow done` when complete\n- \"Commands Reference\" - Update for new CLI\n\n### New Content\n\n```markdown\n## Execution Protocol\n\n### At Session Start\n\n1. **Check for work**:\n   ```bash\n   meow prime\n   ```\n   This shows your current step with instructions.\n\n2. **Read the instructions** and execute them.\n\n### During Execution\n\n1. Follow the step instructions\n2. When done, signal completion:\n   ```bash\n   meow done --output key=value\n   ```\n\n### Environment Variables\n\nMEOW sets these when spawning agents:\n- `MEOW_AGENT` - Your agent identifier\n- `MEOW_WORKFLOW` - Current workflow ID (for debugging)\n\n### Commands\n\n| Command | Purpose |\n|---------|--------|\n| `meow prime` | See current work |\n| `meow done` | Signal completion |\n| `meow done --output k=v` | Complete with outputs |\n```\n\n## Acceptance Criteria\n\n- [ ] No molecule references\n- [ ] No wisp references\n- [ ] No tier references\n- [ ] Updated command reference\n- [ ] Accurate execution protocol","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:01:02Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-602","depends_on_id":"pivot-501","type":"blocks","created_at":"2026-01-08T12:01:02Z","created_by":"claude"}]}
{"id":"pivot-603","title":"Delete dead code","description":"# Delete Dead Code\n\n## Files to Delete\n\n### internal/types/\n- bead.go - Entire file (after verification)\n\n### internal/orchestrator/\n- beadstore.go - Entire file\n\n### internal/template/\n- parser.go - If only legacy parsing (check first)\n\n### cmd/meow/cmd/\n- close.go - Replaced by done.go\n\n## Code to Remove from Files\n\n### internal/orchestrator/orchestrator.go\n- `cleanupWorkflow()`\n- `burnWisps()`\n- `squashWisps()`\n- `generateWispDigest()`\n- `cleanupEphemeralBeads()`\n- Any tier-related helper functions\n\n### internal/template/baker.go\n- `determineTier()`\n- HookBead assignment code\n- Any tier/wisp logic\n\n### internal/template/module.go\n- `Ephemeral` field handling\n- `HooksTo` field handling\n\n## Verification Process\n\n1. Run full test suite\n2. Grep for removed identifiers\n3. Check for unused imports\n4. Run `go build` to verify no references\n\n## Acceptance Criteria\n\n- [ ] All dead code deleted\n- [ ] No dangling references\n- [ ] Tests still pass\n- [ ] Clean build","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:01:03Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-603","depends_on_id":"pivot-106","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"},{"issue_id":"pivot-603","depends_on_id":"pivot-204","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"},{"issue_id":"pivot-603","depends_on_id":"pivot-507","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"}]}
{"id":"pivot-604","title":"Update and run full test suite","description":"# Update and Run Full Test Suite\n\n## Overview\n\nEnsure all tests pass with the new architecture.\n\n## Test Categories\n\n### Unit Tests\n- internal/types/*_test.go - New type tests\n- internal/orchestrator/*_test.go - Updated orchestrator tests\n- internal/template/*_test.go - Updated template tests\n\n### Integration Tests\n- End-to-end workflow execution\n- All 7 executor types\n- Crash recovery\n- Multi-agent coordination\n\n### Test Fixtures\n\nUpdate testdata/ with new format templates:\n```\ntestdata/\n├── templates/\n│   ├── simple-agent.meow.toml\n│   ├── sequential.meow.toml\n│   ├── branching.meow.toml\n│   ├── looping.meow.toml\n│   └── multi-agent.meow.toml\n└── workflows/\n    └── fixtures/\n        ├── running-workflow.yaml\n        └── completed-workflow.yaml\n```\n\n## Commands\n\n```bash\n# Run all tests\ngo test ./...\n\n# Run with coverage\ngo test -coverprofile=coverage.out ./...\ngo tool cover -html=coverage.out\n\n# Run integration tests\ngo test -tags=integration ./...\n```\n\n## Acceptance Criteria\n\n- [ ] All unit tests pass\n- [ ] All integration tests pass\n- [ ] Coverage \u003e= 70%\n- [ ] No test uses old bead types\n- [ ] Test fixtures use new format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:01:04Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-604","depends_on_id":"pivot-603","type":"blocks","created_at":"2026-01-08T12:01:04Z","created_by":"claude"}]}
{"id":"pivot-605","title":"End-to-end validation","description":"# End-to-End Validation\n\n## Purpose\n\nValidate the entire pivot works end-to-end before declaring complete.\n\n## Test Scenarios\n\n### 1. Simple Agent Workflow\n\n```bash\n# Create test template\ncat \u003e /tmp/test.meow.toml \u003c\u003c 'EOF'\n[main]\nname = \"simple-test\"\n\n[[main.steps]]\nid = \"greet\"\nexecutor = \"agent\"\nagent = \"test-agent\"\nprompt = \"Say hello and report the greeting\"\n\n[main.steps.outputs]\ngreeting = { required = true, type = \"string\" }\nEOF\n\n# Run workflow\nmeow run /tmp/test.meow.toml --var agent=test-agent\n\n# In another terminal, as agent:\nexport MEOW_AGENT=test-agent\nmeow prime  # Should show prompt\nmeow done --output greeting=\"Hello, World!\"\n```\n\n### 2. Branching Workflow\n\nTest branch executor with true/false paths.\n\n### 3. Looping Workflow\n\nTest recursive template expansion.\n\n### 4. Human Gate\n\nTest meow approve/reject flow.\n\n### 5. Crash Recovery\n\nKill orchestrator mid-workflow, restart, verify continuation.\n\n## Success Criteria\n\n- [ ] All 5 scenarios pass\n- [ ] No errors in logs\n- [ ] State persists correctly\n- [ ] Agents receive correct prompts\n- [ ] Outputs captured correctly\n\n## Declare Pivot Complete\n\nOnce all scenarios pass, the pivot is complete!","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:01:05Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-605","depends_on_id":"pivot-604","type":"blocks","created_at":"2026-01-08T12:01:05Z","created_by":"claude"}]}
