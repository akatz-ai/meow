{"id":"meow-00g","title":"Define standard label conventions for tiers","description":"Define label conventions for beads. Per SPEC-ADDENDUM, the Tier field is now primary for tier detection.\n\n## Reduced Scope\n\nLabels are now OPTIONAL metadata, not the primary tier mechanism. The explicit `Tier` field handles tier filtering.\n\n## Standard Labels (Optional)\n\n| Label | Purpose |\n|-------|---------|\n| `meow:workflow:{id}` | Track which workflow instance created this bead |\n| `meow:ephemeral` | Mark for cleanup after workflow completion |\n\n## What Changed\n\n- **Removed**: `meow:wisp` and `meow:orchestrator` labels as tier indicators\n- **Added**: Explicit `Tier` field on Bead struct (handled by meow-bba)\n- Labels are now for grouping/filtering, not tier determination\n\n## File Location\nModify: `internal/types/bead.go` (label constants if any)\n\n## Acceptance Criteria\n- [ ] Document label conventions in code comments\n- [ ] Remove any code that computes tier from labels\n- [ ] Workflow ID label helper function if needed","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:53.186807739-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Label conventions are part of the unified filtering implementation.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-03iq","title":"Write stop hook E2E tests","description":"# Task: Write Stop Hook E2E Tests\n\n## Parent Feature\nmeow-ag6: Core E2E Test Suite\n\n## Objective\n\nImplement E2E tests verifying stop hook behavior.\n\n## Test Cases\n\n1. **TestE2E_StopHookFiresOnIdle**: Verify meow event agent-stopped called\n2. **TestE2E_StopHookReturnsPrompt**: Autonomous mode returns current prompt\n3. **TestE2E_StopHookReturnsEmpty_Interactive**: Interactive mode returns empty\n4. **TestE2E_StopHookRetry**: Fail → stop hook → prompt returned → retry succeeds\n5. **TestE2E_StopHookSelfInjection**: Prompt fed back to simulator\n\n## Key Verifications\n\n- agent-stopped event emitted\n- meow prime returns correct value based on mode\n- Self-injection creates continuation\n- Interactive mode stays at prompt\n\n## Acceptance Criteria\n\n1. [ ] All 5 test cases pass\n2. [ ] Tests verify event emission\n3. [ ] Tests verify meow prime responses\n4. [ ] Tests complete in \u003c15 seconds\n\n## Dependencies\n\n- meow-jd7d: Happy path tests (establish patterns)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:03:39.215859096-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:03:39.215859096-05:00","dependencies":[{"issue_id":"meow-03iq","depends_on_id":"meow-jd7d","type":"blocks","created_at":"2026-01-09T20:03:47.424715702-05:00","created_by":"ubuntu"}]}
{"id":"meow-086","title":"Implement simulator state machine","description":"# Task: Implement Simulator State Machine\n\n## Parent Feature\nmeow-a0z: Core Simulator Binary\n\n## Objective\n\nImplement the core state machine that drives the simulator's behavior.\n\n## States\n\n```\nSTARTING → IDLE → WORKING → IDLE (loop)\n                ↓\n              ASKING (sub-state)\n```\n\n- **STARTING**: Initial state, waiting startup_delay\n- **IDLE**: Showing prompt \"\u003e \", waiting for input\n- **WORKING**: Processing prompt, executing action\n- **ASKING**: Asked a question, waiting for user response\n\n## Implementation\n\n### File: cmd/meow-agent-sim/state.go\n\n```go\npackage main\n\ntype State int\n\nconst (\n    StateStarting State = iota\n    StateIdle\n    StateWorking\n    StateAsking\n)\n\nfunc (s State) String() string {\n    switch s {\n    case StateStarting:\n        return \"STARTING\"\n    case StateIdle:\n        return \"IDLE\"\n    case StateAsking:\n        return \"ASKING\"\n    case StateWorking:\n        return \"WORKING\"\n    default:\n        return \"UNKNOWN\"\n    }\n}\n\ntype Simulator struct {\n    config  SimConfig\n    logger  *slog.Logger\n    state   State\n    ipc     *IPCClient\n\n    // Environment\n    agentID    string\n    workflowID string\n    stepID     string\n}\n\nfunc NewSimulator(config SimConfig, logger *slog.Logger) *Simulator {\n    return \u0026Simulator{\n        config: config,\n        logger: logger,\n        state:  StateStarting,\n        ipc:    NewIPCClient(os.Getenv(\"MEOW_ORCH_SOCK\")),\n        agentID:    os.Getenv(\"MEOW_AGENT\"),\n        workflowID: os.Getenv(\"MEOW_WORKFLOW\"),\n        stepID:     os.Getenv(\"MEOW_STEP\"),\n    }\n}\n\nfunc (s *Simulator) Run() error {\n    // Startup phase\n    s.logger.Debug(\"starting\", \"state\", s.state)\n    time.Sleep(s.config.Timing.StartupDelay)\n\n    s.transitionTo(StateIdle)\n\n    // Main loop\n    reader := bufio.NewReader(os.Stdin)\n    for {\n        if s.state == StateIdle || s.state == StateAsking {\n            s.showPrompt()\n\n            // Fire stop hook if configured\n            if s.config.Hooks.FireStopHook {\n                s.fireStopHook()\n            }\n        }\n\n        // Read input\n        line, err := reader.ReadString('\\n')\n        if err != nil {\n            if err == io.EOF {\n                s.logger.Info(\"stdin closed, exiting\")\n                return nil\n            }\n            return fmt.Errorf(\"reading input: %w\", err)\n        }\n\n        prompt := strings.TrimSpace(line)\n        if prompt == \"\" {\n            continue\n        }\n\n        // Handle input based on current state\n        if err := s.handleInput(prompt); err != nil {\n            s.logger.Error(\"handling input\", \"error\", err)\n        }\n    }\n}\n\nfunc (s *Simulator) transitionTo(newState State) {\n    s.logger.Debug(\"state transition\",\n        \"from\", s.state,\n        \"to\", newState,\n    )\n    s.state = newState\n}\n\nfunc (s *Simulator) showPrompt() {\n    fmt.Print(\"\u003e \")\n}\n\nfunc (s *Simulator) handleInput(prompt string) error {\n    s.transitionTo(StateWorking)\n\n    // Match and execute behavior\n    behavior := s.matchBehavior(prompt)\n    return s.executeBehavior(behavior, prompt)\n}\n```\n\n## State Transitions\n\n| Current | Input | Next | Action |\n|---------|-------|------|--------|\n| STARTING | (startup delay) | IDLE | Show prompt |\n| IDLE | text | WORKING | Execute behavior |\n| WORKING | (complete) | IDLE | Call meow done |\n| WORKING | (ask) | ASKING | Print question |\n| ASKING | text | WORKING | Continue with response |\n\n## Acceptance Criteria\n\n1. [ ] States defined as enum\n2. [ ] Transition logging\n3. [ ] Startup delay respected\n4. [ ] Prompt shown in IDLE/ASKING\n5. [ ] Input reading works\n6. [ ] State machine loops correctly\n\n## Dependencies\n\n- meow-o3n: CLI entry point (need main.go structure)\n\n## Estimated Size\n\nMedium (~200 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T19:58:37.17330617-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:58:37.17330617-05:00","dependencies":[{"issue_id":"meow-086","depends_on_id":"meow-o3n","type":"blocks","created_at":"2026-01-09T19:58:42.366749263-05:00","created_by":"ubuntu"}]}
{"id":"meow-0a398443","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"hello2","created_at":"2026-01-08T03:50:29.223075246-05:00","updated_at":"2026-01-08T22:19:40.827006729-05:00","closed_at":"2026-01-08T22:19:40.827006729-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-0h7","title":"Implement agent state tracking","description":"# Implement Agent State Tracking\n\n## File: internal/orchestrator/agents.go\n\n## Purpose\n\nTrack agent state including:\n- tmux session name\n- Working directory (for file_path validation)\n- Current step (for meow prime queries)\n- Status (active/idle/dead)\n\n## Implementation\n\n\\`\\`\\`go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os/exec\"\n    \"sync\"\n)\n\n// AgentState tracks runtime state for an agent.\ntype AgentState struct {\n    ID          string \\`yaml:\"id\"\\`\n    TmuxSession string \\`yaml:\"tmux_session\"\\`\n    Workdir     string \\`yaml:\"workdir\"\\`\n    CurrentStep string \\`yaml:\"current_step,omitempty\"\\`\n    Status      string \\`yaml:\"status\"\\`  // active, idle\n}\n\n// AgentManager tracks all agents in a workflow.\ntype AgentManager struct {\n    mu     sync.RWMutex\n    agents map[string]*AgentState\n}\n\n// NewAgentManager creates a manager.\nfunc NewAgentManager() *AgentManager {\n    return \u0026AgentManager{\n        agents: make(map[string]*AgentState),\n    }\n}\n\n// Register adds a new agent after spawn.\nfunc (m *AgentManager) Register(agent *AgentState) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    m.agents[agent.ID] = agent\n}\n\n// Get retrieves an agent's state.\nfunc (m *AgentManager) Get(id string) (*AgentState, bool) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    agent, ok := m.agents[id]\n    return agent, ok\n}\n\n// SetCurrentStep updates the agent's current step.\nfunc (m *AgentManager) SetCurrentStep(agentID, stepID string) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    if agent, ok := m.agents[agentID]; ok {\n        agent.CurrentStep = stepID\n        agent.Status = \"active\"\n    }\n}\n\n// SetIdle marks the agent as idle (no current step).\nfunc (m *AgentManager) SetIdle(agentID string) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    if agent, ok := m.agents[agentID]; ok {\n        agent.CurrentStep = \"\"\n        agent.Status = \"idle\"\n    }\n}\n\n// GetWorkdir returns the agent's working directory.\nfunc (m *AgentManager) GetWorkdir(agentID string) (string, bool) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    if agent, ok := m.agents[agentID]; ok {\n        return agent.Workdir, true\n    }\n    return \"\", false\n}\n\n// IsRunning checks if agent's tmux session exists.\nfunc (m *AgentManager) IsRunning(ctx context.Context, agentID string) (bool, error) {\n    m.mu.RLock()\n    agent, ok := m.agents[agentID]\n    m.mu.RUnlock()\n    \n    if !ok {\n        return false, nil\n    }\n    \n    // Check if tmux session exists\n    cmd := exec.CommandContext(ctx, \"tmux\", \"has-session\", \"-t\", agent.TmuxSession)\n    err := cmd.Run()\n    return err == nil, nil\n}\n\n// Remove deletes an agent after kill.\nfunc (m *AgentManager) Remove(agentID string) {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n    delete(m.agents, agentID)\n}\n\n// All returns all agent states.\nfunc (m *AgentManager) All() []*AgentState {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    \n    result := make([]*AgentState, 0, len(m.agents))\n    for _, agent := range m.agents {\n        result = append(result, agent)\n    }\n    return result\n}\n\n// ForAgent returns the agent state for IPC requests (meow prime).\nfunc (m *AgentManager) ForAgent(agentID string) (*AgentState, error) {\n    m.mu.RLock()\n    defer m.mu.RUnlock()\n    \n    agent, ok := m.agents[agentID]\n    if !ok {\n        return nil, fmt.Errorf(\"unknown agent: %s\", agentID)\n    }\n    return agent, nil\n}\n\\`\\`\\`\n\n## Workflow Integration\n\nThe Workflow struct also stores agent state for persistence:\n\n\\`\\`\\`go\n// In types/workflow.go\ntype Workflow struct {\n    // ... existing fields ...\n    \n    // Active agents with their state\n    Agents map[string]*AgentInfo \\`yaml:\"agents,omitempty\"\\`\n}\n\ntype AgentInfo struct {\n    TmuxSession string \\`yaml:\"tmux_session\"\\`\n    Status      string \\`yaml:\"status\"\\`\n    Workdir     string \\`yaml:\"workdir\"\\`\n    CurrentStep string \\`yaml:\"current_step,omitempty\"\\`\n}\n\\`\\`\\`\n\n## Usage\n\n\\`\\`\\`go\n// In spawn executor\nfunc (e *SpawnExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    agent := \u0026AgentState{\n        ID:          step.Spawn.Agent,\n        TmuxSession: fmt.Sprintf(\"meow-%s-%s\", wf.ID, step.Spawn.Agent),\n        Workdir:     step.Spawn.Workdir,\n        Status:      \"active\",\n    }\n    \n    e.agents.Register(agent)\n    \n    // Also persist to workflow for crash recovery\n    wf.Agents[agent.ID] = \u0026types.AgentInfo{\n        TmuxSession: agent.TmuxSession,\n        Status:      agent.Status,\n        Workdir:     agent.Workdir,\n    }\n    \n    // ... start tmux session ...\n}\n\n// In meow prime handler\nfunc (o *Orchestrator) handlePrimeRequest(agentID string) (string, error) {\n    agent, err := o.agents.ForAgent(agentID)\n    if err != nil {\n        return \"\", err\n    }\n    \n    if agent.CurrentStep == \"\" {\n        // Agent is idle, no prompt\n        return \"\", nil\n    }\n    \n    step, ok := o.workflow.GetStep(agent.CurrentStep)\n    if !ok {\n        return \"\", nil\n    }\n    \n    // Check step status and mode\n    // ...\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] AgentState struct with all fields\n- [ ] AgentManager with thread-safe operations\n- [ ] Register/Get/Remove operations\n- [ ] SetCurrentStep/SetIdle for step tracking\n- [ ] GetWorkdir for file_path validation\n- [ ] IsRunning checks tmux session\n- [ ] Workflow.Agents for persistence\n- [ ] Integration with spawn executor\n- [ ] Integration with meow prime handler\n- [ ] Integration with crash recovery\n- [ ] Unit tests for AgentManager","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T20:29:27.397948955-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:35.275131461-05:00","closed_at":"2026-01-08T22:14:35.275131461-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These features will be implemented as part of the new orchestrator architecture.","dependencies":[{"issue_id":"meow-0h7","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T20:29:48.737979005-05:00","created_by":"ubuntu"},{"issue_id":"meow-0h7","depends_on_id":"meow-105","type":"blocks","created_at":"2026-01-08T20:29:48.737979005-05:00","created_by":"ubuntu"}]}
{"id":"meow-0tx","title":"Implement attach_wisp processing","description":"Handle explicit wisp attachment via attach_wisp field. See IMPLEMENTATION-PLAN section meow-modules-baker-attach.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.987317851-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"YAGNI - attach_wisp processing not needed. Auto-detection via ephemeral=true workflow property plus hooks_to for HookBead linking handles all real use cases. Can resurrect if a real use case emerges.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-0x5","title":"Templates: Module Format Examples","description":"Create example templates using module format. Phase 4.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-07T16:38:26.126049796-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:23:56.065574173-05:00","closed_at":"2026-01-08T22:23:56.065574173-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot"}
{"id":"meow-101","title":"Define ExecutorType enum","description":"# Define ExecutorType Enum\n\n## File: internal/types/executor.go\n\n## Implementation\n\n```go\npackage types\n\n// ExecutorType determines who runs a step and how.\n// IMPORTANT: There are exactly 6 executors. Gate is NOT an executor -\n// human approval is implemented via branch + meow await-approval.\ntype ExecutorType string\n\nconst (\n    // Orchestrator executors - run internally, complete synchronously\n    ExecutorShell  ExecutorType = \"shell\"  // Run shell command\n    ExecutorSpawn  ExecutorType = \"spawn\"  // Start agent in tmux\n    ExecutorKill   ExecutorType = \"kill\"   // Stop agent's tmux session\n    ExecutorExpand ExecutorType = \"expand\" // Inline another workflow\n    ExecutorBranch ExecutorType = \"branch\" // Conditional execution\n\n    // External executors - wait for external completion signal\n    ExecutorAgent ExecutorType = \"agent\" // Agent does work, signals meow done\n)\n\n// IsOrchestrator returns true if this executor runs internally.\nfunc (e ExecutorType) IsOrchestrator() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch:\n        return true\n    }\n    return false\n}\n\n// IsExternal returns true if this executor waits for external signal.\nfunc (e ExecutorType) IsExternal() bool {\n    return e == ExecutorAgent\n}\n\n// Valid returns true if this is a recognized executor type.\nfunc (e ExecutorType) Valid() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch, ExecutorAgent:\n        return true\n    }\n    return false\n}\n```\n\n## Rationale\n\n- **6 executors only** - Gate is NOT a primitive (per MVP-SPEC-v2)\n- **shell** not \"code\" - More intuitive, matches spec language\n- **spawn/kill** not \"start/stop\" - Clearer about what's happening (process lifecycle)\n- **branch** not \"condition\" - Describes what it does (branching), not what it evaluates\n- **agent** not \"task\" - Describes who runs it, consistent with other executors\n\n## Human Approval Pattern (NOT an executor)\n\nHuman gates are implemented via composition:\n```toml\n[[steps]]\nid = \"review-gate\"\nexecutor = \"branch\"\ncondition = \"meow await-approval review-gate --timeout 24h\"\n```\n\n## Acceptance Criteria\n\n- [ ] ExecutorType enum with exactly 6 values (NO gate)\n- [ ] IsOrchestrator() helper (returns true for shell, spawn, kill, expand, branch)\n- [ ] IsExternal() helper (returns true only for agent)\n- [ ] Valid() validation\n- [ ] Unit tests for all methods\n","notes":"**UPDATED for v2 spec**: Only 6 executors - gate is NOT a primitive, it's a composition using branch + meow await-approval. Remove ExecutorGate from enum.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:02Z","created_by":"claude","updated_at":"2026-01-08T22:50:58.914657827-05:00","closed_at":"2026-01-08T22:50:58.914657827-05:00","close_reason":"Implemented ExecutorType enum with 6 executors (no gate), IsOrchestrator(), IsExternal(), Valid() methods, and comprehensive tests"}
{"id":"meow-102","title":"Define StepStatus enum","description":"# Define StepStatus Enum\n\n## File: internal/types/step.go (or executor.go)\n\n## Implementation\n\n```go\n// StepStatus represents the lifecycle state of a step.\ntype StepStatus string\n\nconst (\n    StepStatusPending    StepStatus = \"pending\"    // Waiting for dependencies\n    StepStatusRunning    StepStatus = \"running\"    // Currently executing\n    StepStatusCompleting StepStatus = \"completing\" // Agent called meow done, orchestrator handling transition\n    StepStatusDone       StepStatus = \"done\"       // Completed successfully\n    StepStatusFailed     StepStatus = \"failed\"     // Execution failed\n)\n\n// Valid returns true if this is a recognized status.\nfunc (s StepStatus) Valid() bool {\n    switch s {\n    case StepStatusPending, StepStatusRunning, StepStatusCompleting, StepStatusDone, StepStatusFailed:\n        return true\n    }\n    return false\n}\n\n// IsTerminal returns true if this status is final (done or failed).\nfunc (s StepStatus) IsTerminal() bool {\n    return s == StepStatusDone || s == StepStatusFailed\n}\n\n// CanTransitionTo returns true if transitioning from s to target is valid.\nfunc (s StepStatus) CanTransitionTo(target StepStatus) bool {\n    switch s {\n    case StepStatusPending:\n        return target == StepStatusRunning\n    case StepStatusRunning:\n        return target == StepStatusCompleting || target == StepStatusDone || target == StepStatusFailed || target == StepStatusPending // Reset on crash\n    case StepStatusCompleting:\n        return target == StepStatusDone || target == StepStatusRunning // Back to running if validation fails\n    case StepStatusDone, StepStatusFailed:\n        return false // Terminal states\n    }\n    return false\n}\n```\n\n## Design Notes\n\n- **\\`completing\\` status added** - Critical for preventing stop hook interference during orchestrator transitions. When agent calls \\`meow done\\`, step goes to \\`completing\\` while orchestrator validates outputs and prepares next prompt.\n- **Reset allowed** - Running can go back to pending for crash recovery.\n- **Completing can retry** - If validation fails, step goes back to running so agent can retry.\n- **Terminal states** - Once done/failed, no further transitions.\n\n## Status Lifecycle\n\n\\`\\`\\`\npending ──► running ──► completing ──► done\n              │             │\n              │             └──► (back to running if validation fails)\n              │\n              └──► failed\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] StepStatus enum with 5 values (including completing)\n- [ ] Valid() validation\n- [ ] IsTerminal() helper\n- [ ] CanTransitionTo() state machine with completing transitions\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:03Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.964300077-05:00","closed_at":"2026-01-08T22:58:49.964300077-05:00","close_reason":"Implemented as part of persistence track commit e21ff43"}
{"id":"meow-103","title":"Define executor config structs","description":"# Define Executor Config Structs\n\n## File: internal/types/step.go\n\n## Implementation\n\nEach executor has its own config struct. Only one is populated per step.\n**IMPORTANT: No GateConfig - gate is NOT an executor per MVP-SPEC-v2.**\n\n```go\n// ShellConfig for executor: shell\ntype ShellConfig struct {\n    Command string            `yaml:\"command\" toml:\"command\"`\n    Workdir string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env     map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    OnError string            `yaml:\"on_error,omitempty\" toml:\"on_error,omitempty\"` // continue | fail (default: fail)\n    Outputs map[string]OutputSource `yaml:\"outputs,omitempty\" toml:\"outputs,omitempty\"`\n}\n\n// OutputSource defines where to capture output from\ntype OutputSource struct {\n    Source string `yaml:\"source\" toml:\"source\"` // stdout | stderr | exit_code | file:/path\n}\n\n// SpawnConfig for executor: spawn\ntype SpawnConfig struct {\n    Agent         string            `yaml:\"agent\" toml:\"agent\"`\n    Workdir       string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env           map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    ResumeSession string            `yaml:\"resume_session,omitempty\" toml:\"resume_session,omitempty\"`\n}\n\n// KillConfig for executor: kill\ntype KillConfig struct {\n    Agent    string `yaml:\"agent\" toml:\"agent\"`\n    Graceful bool   `yaml:\"graceful,omitempty\" toml:\"graceful,omitempty\"` // Default: true\n    Timeout  int    `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"`   // Seconds, default: 10\n}\n\n// ExpandConfig for executor: expand\ntype ExpandConfig struct {\n    Template  string            `yaml:\"template\" toml:\"template\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n}\n\n// BranchTarget defines what to expand for a branch outcome.\ntype BranchTarget struct {\n    Template  string            `yaml:\"template,omitempty\" toml:\"template,omitempty\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n    Inline    []InlineStep      `yaml:\"inline,omitempty\" toml:\"inline,omitempty\"`\n}\n\n// BranchConfig for executor: branch\ntype BranchConfig struct {\n    Condition string        `yaml:\"condition\" toml:\"condition\"` // Shell command, exit 0 = true\n    OnTrue    *BranchTarget `yaml:\"on_true,omitempty\" toml:\"on_true,omitempty\"`\n    OnFalse   *BranchTarget `yaml:\"on_false,omitempty\" toml:\"on_false,omitempty\"`\n    OnTimeout *BranchTarget `yaml:\"on_timeout,omitempty\" toml:\"on_timeout,omitempty\"`\n    Timeout   string        `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"` // Duration string\n}\n\n// AgentOutputDef defines an expected output from an agent step\ntype AgentOutputDef struct {\n    Required    bool   `yaml:\"required\" toml:\"required\"`\n    Type        string `yaml:\"type\" toml:\"type\"` // string | number | boolean | json | file_path\n    Description string `yaml:\"description,omitempty\" toml:\"description,omitempty\"`\n}\n\n// AgentConfig for executor: agent\ntype AgentConfig struct {\n    Agent   string                    `yaml:\"agent\" toml:\"agent\"`\n    Prompt  string                    `yaml:\"prompt\" toml:\"prompt\"`\n    Mode    string                    `yaml:\"mode,omitempty\" toml:\"mode,omitempty\"` // autonomous (default) | interactive\n    Outputs map[string]AgentOutputDef `yaml:\"outputs,omitempty\" toml:\"outputs,omitempty\"`\n    Timeout string                    `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"` // Max time for step\n}\n```\n\n## Acceptance Criteria\n\n- [ ] ShellConfig with command, workdir, env, on_error, outputs\n- [ ] SpawnConfig with agent, workdir, env, resume_session\n- [ ] KillConfig with agent, graceful, timeout\n- [ ] ExpandConfig with template, variables\n- [ ] BranchConfig with condition, on_true, on_false, on_timeout, timeout\n- [ ] AgentConfig with agent, prompt, mode, outputs, timeout\n- [ ] BranchTarget for expansion targets\n- [ ] AgentOutputDef for output definitions\n- [ ] **NO GateConfig** - gate is not an executor\n- [ ] Unit tests for validation\n","notes":"**UPDATED for v2 spec**: Remove GateConfig - gates are implemented via branch + meow await-approval. Only 5 orchestrator executor configs (shell, spawn, kill, expand, branch) + 1 external (agent).","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:04Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.966377001-05:00","closed_at":"2026-01-08T22:58:49.966377001-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"meow-103","depends_on_id":"meow-101","type":"blocks","created_at":"2026-01-08T12:00:04Z","created_by":"claude"}]}
{"id":"meow-104","title":"Define Step struct","description":"# Define Step Struct\n\n## File: internal/types/step.go\n\n## Implementation\n\n```go\n// Step is the single primitive in MEOW. Everything is a step.\n// IMPORTANT: Only 6 executor configs - NO Gate field (gate is not an executor).\ntype Step struct {\n    // Identity\n    ID       string       `yaml:\"id\"`\n    Executor ExecutorType `yaml:\"executor\"`\n\n    // Lifecycle\n    Status    StepStatus `yaml:\"status\"`\n    StartedAt *time.Time `yaml:\"started_at,omitempty\"`\n    DoneAt    *time.Time `yaml:\"done_at,omitempty\"`\n\n    // Dependencies\n    Needs []string `yaml:\"needs,omitempty\"`\n\n    // Expansion tracking (for crash recovery)\n    ExpandedFrom string   `yaml:\"expanded_from,omitempty\"` // Parent expand step ID\n    ExpandedInto []string `yaml:\"expanded_into,omitempty\"` // Child step IDs (on expand steps)\n\n    // Data\n    Outputs map[string]any `yaml:\"outputs,omitempty\"`\n    Error   *StepError     `yaml:\"error,omitempty\"`\n\n    // Executor-specific config (exactly one populated based on Executor)\n    // NOTE: Only 6 configs for 6 executors. NO Gate - it's a branch pattern.\n    Shell  *ShellConfig  `yaml:\"shell,omitempty\"`\n    Spawn  *SpawnConfig  `yaml:\"spawn,omitempty\"`\n    Kill   *KillConfig   `yaml:\"kill,omitempty\"`\n    Expand *ExpandConfig `yaml:\"expand,omitempty\"`\n    Branch *BranchConfig `yaml:\"branch,omitempty\"`\n    Agent  *AgentConfig  `yaml:\"agent,omitempty\"`\n}\n\n// StepError captures failure information.\ntype StepError struct {\n    Message string `yaml:\"message\"`\n    Code    int    `yaml:\"code,omitempty\"`    // Exit code for shell\n    Output  string `yaml:\"output,omitempty\"`  // stderr or other context\n}\n\n// InlineStep is used for inline step definitions in branch targets.\ntype InlineStep struct {\n    ID       string            `yaml:\"id\" toml:\"id\"`\n    Executor ExecutorType      `yaml:\"executor\" toml:\"executor\"`\n    Prompt   string            `yaml:\"prompt,omitempty\" toml:\"prompt,omitempty\"`\n    Agent    string            `yaml:\"agent,omitempty\" toml:\"agent,omitempty\"`\n    Needs    []string          `yaml:\"needs,omitempty\" toml:\"needs,omitempty\"`\n}\n```\n\n## Helper Methods\n\n```go\n// IsReady returns true if all dependencies are done.\nfunc (s *Step) IsReady(steps map[string]*Step) bool {\n    if s.Status != StepStatusPending {\n        return false\n    }\n    for _, depID := range s.Needs {\n        dep, ok := steps[depID]\n        if !ok || dep.Status != StepStatusDone {\n            return false\n        }\n    }\n    return true\n}\n\n// Validate checks the step is well-formed.\nfunc (s *Step) Validate() error {\n    if s.ID == \"\" {\n        return fmt.Errorf(\"step ID is required\")\n    }\n    if strings.Contains(s.ID, \".\") {\n        return fmt.Errorf(\"step ID cannot contain dots (reserved for expansion prefixes)\")\n    }\n    if !s.Executor.Valid() {\n        return fmt.Errorf(\"invalid executor: %s\", s.Executor)\n    }\n    return s.validateConfig()\n}\n\n// validateConfig ensures exactly one config is set matching the executor\nfunc (s *Step) validateConfig() error {\n    // Count non-nil configs and verify match\n    configs := map[ExecutorType]bool{\n        ExecutorShell:  s.Shell != nil,\n        ExecutorSpawn:  s.Spawn != nil,\n        ExecutorKill:   s.Kill != nil,\n        ExecutorExpand: s.Expand != nil,\n        ExecutorBranch: s.Branch != nil,\n        ExecutorAgent:  s.Agent != nil,\n    }\n    \n    if !configs[s.Executor] {\n        return fmt.Errorf(\"step %s: missing config for executor %s\", s.ID, s.Executor)\n    }\n    \n    for exec, hasConfig := range configs {\n        if hasConfig \u0026\u0026 exec != s.Executor {\n            return fmt.Errorf(\"step %s: has config for %s but executor is %s\", s.ID, exec, s.Executor)\n        }\n    }\n    return nil\n}\n\n// Complete marks the step as done with outputs.\nfunc (s *Step) Complete(outputs map[string]any) error {\n    if !s.Status.CanTransitionTo(StepStatusDone) {\n        return fmt.Errorf(\"cannot complete step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusDone\n    s.DoneAt = \u0026now\n    s.Outputs = outputs\n    return nil\n}\n\n// Fail marks the step as failed with error info.\nfunc (s *Step) Fail(err *StepError) error {\n    if !s.Status.CanTransitionTo(StepStatusFailed) {\n        return fmt.Errorf(\"cannot fail step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusFailed\n    s.DoneAt = \u0026now\n    s.Error = err\n    return nil\n}\n\n// SetCompleting marks the step as transitioning to done.\nfunc (s *Step) SetCompleting() error {\n    if !s.Status.CanTransitionTo(StepStatusCompleting) {\n        return fmt.Errorf(\"cannot set completing in status %s\", s.Status)\n    }\n    s.Status = StepStatusCompleting\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Step struct with 6 executor config fields (NO Gate)\n- [ ] StepError struct\n- [ ] InlineStep for branch targets\n- [ ] IsReady() helper\n- [ ] Validate() method with step ID dot check\n- [ ] validateConfig() for executor/config match\n- [ ] Complete(), Fail(), SetCompleting() methods\n- [ ] Unit tests for all methods and status transitions\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:05Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.968252706-05:00","closed_at":"2026-01-08T22:58:49.968252706-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"meow-104","depends_on_id":"meow-102","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"},{"issue_id":"meow-104","depends_on_id":"meow-103","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"}]}
{"id":"meow-105","title":"Define Workflow struct","description":"# Define Workflow Struct\n\n## File: internal/types/workflow.go\n\n## Implementation\n\n\\`\\`\\`go\npackage types\n\nimport \"time\"\n\n// WorkflowStatus represents the lifecycle state of a workflow.\ntype WorkflowStatus string\n\nconst (\n    WorkflowStatusPending WorkflowStatus = \"pending\" // Created but not started\n    WorkflowStatusRunning WorkflowStatus = \"running\" // Orchestrator is processing\n    WorkflowStatusDone    WorkflowStatus = \"done\"    // All steps completed\n    WorkflowStatusFailed  WorkflowStatus = \"failed\"  // A step failed\n)\n\n// AgentInfo tracks persisted state for an agent.\ntype AgentInfo struct {\n    TmuxSession string \\`yaml:\"tmux_session\"\\`\n    Status      string \\`yaml:\"status\"\\`       // active, idle\n    Workdir     string \\`yaml:\"workdir\"\\`\n    CurrentStep string \\`yaml:\"current_step,omitempty\"\\`\n}\n\n// Workflow represents a running workflow instance.\ntype Workflow struct {\n    // Identity\n    ID       string \\`yaml:\"id\"\\`       // Unique identifier (e.g., \"wf-abc123\")\n    Template string \\`yaml:\"template\"\\` // Source template path\n\n    // Lifecycle\n    Status    WorkflowStatus \\`yaml:\"status\"\\`\n    StartedAt time.Time      \\`yaml:\"started_at\"\\`\n    DoneAt    *time.Time     \\`yaml:\"done_at,omitempty\"\\`\n\n    // Configuration\n    Variables map[string]string \\`yaml:\"variables,omitempty\"\\`\n\n    // Agent state - tracked for crash recovery and file_path validation\n    Agents map[string]*AgentInfo \\`yaml:\"agents,omitempty\"\\`\n\n    // State - all steps with their current state\n    Steps map[string]*Step \\`yaml:\"steps\"\\`\n}\n\n// NewWorkflow creates a new workflow instance.\nfunc NewWorkflow(id, template string, vars map[string]string) *Workflow {\n    return \u0026Workflow{\n        ID:        id,\n        Template:  template,\n        Status:    WorkflowStatusPending,\n        StartedAt: time.Now(),\n        Variables: vars,\n        Agents:    make(map[string]*AgentInfo),\n        Steps:     make(map[string]*Step),\n    }\n}\n\n// AddStep adds a step to the workflow.\nfunc (w *Workflow) AddStep(step *Step) error {\n    if _, exists := w.Steps[step.ID]; exists {\n        return fmt.Errorf(\"step %s already exists\", step.ID)\n    }\n    w.Steps[step.ID] = step\n    return nil\n}\n\n// RegisterAgent adds or updates agent state.\nfunc (w *Workflow) RegisterAgent(id string, info *AgentInfo) {\n    w.Agents[id] = info\n}\n\n// GetAgentWorkdir returns the working directory for an agent.\n// Used for file_path output validation.\nfunc (w *Workflow) GetAgentWorkdir(agentID string) (string, bool) {\n    agent, ok := w.Agents[agentID]\n    if !ok {\n        return \"\", false\n    }\n    return agent.Workdir, true\n}\n\n// GetReadySteps returns all steps that are ready to execute.\nfunc (w *Workflow) GetReadySteps() []*Step {\n    var ready []*Step\n    for _, step := range w.Steps {\n        if step.IsReady(w.Steps) {\n            ready = append(ready, step)\n        }\n    }\n    return ready\n}\n\n// AllDone returns true if all steps are in terminal state.\nfunc (w *Workflow) AllDone() bool {\n    for _, step := range w.Steps {\n        if !step.Status.IsTerminal() {\n            return false\n        }\n    }\n    return true\n}\n\n// HasFailed returns true if any step has failed.\nfunc (w *Workflow) HasFailed() bool {\n    for _, step := range w.Steps {\n        if step.Status == StepStatusFailed {\n            return true\n        }\n    }\n    return false\n}\n\n// Complete marks the workflow as done.\nfunc (w *Workflow) Complete() {\n    now := time.Now()\n    w.Status = WorkflowStatusDone\n    w.DoneAt = \u0026now\n}\n\n// Fail marks the workflow as failed.\nfunc (w *Workflow) Fail() {\n    now := time.Now()\n    w.Status = WorkflowStatusFailed\n    w.DoneAt = \u0026now\n}\n\n// GetStep retrieves a step by ID.\nfunc (w *Workflow) GetStep(id string) (*Step, bool) {\n    step, ok := w.Steps[id]\n    return step, ok\n}\n\n// GetStepsForAgent returns steps assigned to the given agent.\nfunc (w *Workflow) GetStepsForAgent(agentID string) []*Step {\n    var result []*Step\n    for _, step := range w.Steps {\n        if step.Executor == ExecutorAgent \u0026\u0026 step.Agent != nil \u0026\u0026 step.Agent.Agent == agentID {\n            result = append(result, step)\n        }\n    }\n    return result\n}\n\\`\\`\\`\n\n## Design Notes\n\n- **Steps as map** - O(1) lookup by ID, which is common during dependency resolution.\n- **Variables stored** - The resolved variables are saved so we can reconstruct context on restart.\n- **Agents field** - Tracks agent state for:\n  - Crash recovery (check if tmux session still exists)\n  - file_path validation (resolve relative paths against agent's workdir)\n- **No parent/child relationship** - Expanded steps are just more steps in the map with dependency links.\n\n## YAML Representation\n\n\\`\\`\\`yaml\n# .meow/workflows/wf-abc123.yaml\nid: wf-abc123\ntemplate: work-loop.meow.toml\nstatus: running\nstarted_at: 2026-01-08T21:00:00Z\n\nvariables:\n  agent: claude-1\n\nagents:\n  claude-1:\n    tmux_session: meow-wf-abc123-claude-1\n    status: active\n    workdir: /data/projects/myapp/.meow/worktrees/claude-1\n    current_step: impl.write-tests\n\nsteps:\n  # ... step definitions ...\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] WorkflowStatus enum\n- [ ] AgentInfo struct for persisted agent state\n- [ ] Workflow struct with Agents field\n- [ ] NewWorkflow() constructor initializes Agents map\n- [ ] RegisterAgent() method\n- [ ] GetAgentWorkdir() for file_path validation\n- [ ] AddStep() method\n- [ ] GetReadySteps() helper\n- [ ] AllDone() and HasFailed() helpers\n- [ ] GetStepsForAgent() for agent queries\n- [ ] Unit tests","notes":"**UPDATED for v2 spec**: Need to add Cleanup field (shell script that runs on workflow end), ClaudeSession field to AgentInfo (for session resume), and WorkflowStatusCleaningUp/WorkflowStatusStopped status values.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:06Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.970090044-05:00","closed_at":"2026-01-08T22:58:49.970090044-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"meow-105","depends_on_id":"meow-104","type":"blocks","created_at":"2026-01-08T12:00:06Z","created_by":"claude"}]}
{"id":"meow-106","title":"Define IPC message types for orchestrator-agent communication","description":"# Define IPC Message Types for Orchestrator-Agent Communication\n\n## File: internal/ipc/messages.go\n\n## Implementation\n\nThese are **Go types** for the single-line JSON protocol between orchestrator and agents.\n\n```go\npackage ipc\n\n// MessageType identifies the IPC message kind\ntype MessageType string\n\nconst (\n    MsgStepDone     MessageType = \"step_done\"\n    MsgGetPrompt    MessageType = \"get_prompt\"\n    MsgGetSessionID MessageType = \"get_session_id\"\n    MsgApproval     MessageType = \"approval\"\n    MsgAck          MessageType = \"ack\"\n    MsgError        MessageType = \"error\"\n    MsgPrompt       MessageType = \"prompt\"\n    MsgSessionID    MessageType = \"session_id\"\n)\n\n// --- Request Messages (agent → orchestrator) ---\n\n// StepDoneMessage signals step completion\ntype StepDoneMessage struct {\n    Type     MessageType    `json:\"type\"` // \"step_done\"\n    Workflow string         `json:\"workflow\"`\n    Agent    string         `json:\"agent\"`\n    Step     string         `json:\"step\"`\n    Outputs  map[string]any `json:\"outputs,omitempty\"`\n    Notes    string         `json:\"notes,omitempty\"`\n}\n\n// GetPromptMessage requests the current prompt for an agent\ntype GetPromptMessage struct {\n    Type  MessageType `json:\"type\"` // \"get_prompt\"\n    Agent string      `json:\"agent\"`\n}\n\n// GetSessionIDMessage requests the Claude session ID for an agent\ntype GetSessionIDMessage struct {\n    Type  MessageType `json:\"type\"` // \"get_session_id\"\n    Agent string      `json:\"agent\"`\n}\n\n// ApprovalMessage signals human approval/rejection\ntype ApprovalMessage struct {\n    Type     MessageType `json:\"type\"` // \"approval\"\n    Workflow string      `json:\"workflow\"`\n    GateID   string      `json:\"gate_id\"`\n    Approved bool        `json:\"approved\"`\n    Notes    string      `json:\"notes,omitempty\"`\n    Reason   string      `json:\"reason,omitempty\"` // For rejections\n}\n\n// --- Response Messages (orchestrator → agent) ---\n\n// AckMessage confirms successful operation\ntype AckMessage struct {\n    Type    MessageType `json:\"type\"` // \"ack\"\n    Success bool        `json:\"success\"`\n}\n\n// ErrorMessage reports an error\ntype ErrorMessage struct {\n    Type    MessageType `json:\"type\"` // \"error\"\n    Message string      `json:\"message\"`\n}\n\n// PromptMessage returns the current prompt\ntype PromptMessage struct {\n    Type    MessageType `json:\"type\"` // \"prompt\"\n    Content string      `json:\"content\"` // Empty string means \"no prompt, stay idle\"\n}\n\n// SessionIDMessage returns the Claude session ID\ntype SessionIDMessage struct {\n    Type      MessageType `json:\"type\"` // \"session_id\"\n    SessionID string      `json:\"session_id\"`\n}\n```\n\n## Protocol Notes\n\n- **Single-line JSON** - Each message is one line, newline-delimited\n- **No pretty printing** - Embedded newlines escaped as `\\n`\n- **Socket path** - `/tmp/meow-{workflow_id}.sock`\n- **Keep paths short** - Unix socket path limit is ~108 bytes\n\n## Acceptance Criteria\n\n- [ ] MessageType enum with all types\n- [ ] StepDoneMessage for meow done\n- [ ] GetPromptMessage for meow prime\n- [ ] GetSessionIDMessage for meow session-id\n- [ ] ApprovalMessage for meow approve/reject\n- [ ] AckMessage, ErrorMessage for responses\n- [ ] PromptMessage, SessionIDMessage for responses\n- [ ] JSON marshaling tests (verify single-line output)\n- [ ] Parsing helpers for incoming messages\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T22:18:48.285253235-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:52:19.938831044-05:00","closed_at":"2026-01-08T22:52:19.938831044-05:00","close_reason":"Implemented Go message types for IPC protocol with full test coverage","dependencies":[{"issue_id":"meow-106","depends_on_id":"meow-105","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"meow-106","depends_on_id":"meow-301","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"meow-106","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"meow-106","depends_on_id":"pivot-101","type":"blocks","created_at":"2026-01-08T22:21:16.199674173-05:00","created_by":"ubuntu"},{"issue_id":"meow-106","depends_on_id":"meow-101","type":"blocks","created_at":"2026-01-08T22:21:16.199674173-05:00","created_by":"ubuntu"},{"issue_id":"meow-106","depends_on_id":"pivot-102","type":"blocks","created_at":"2026-01-08T22:21:17.756666433-05:00","created_by":"ubuntu"},{"issue_id":"meow-106","depends_on_id":"meow-102","type":"blocks","created_at":"2026-01-08T22:21:17.756666433-05:00","created_by":"ubuntu"}]}
{"id":"meow-1767859075881445643.check-setup-e1400b22","title":"Verify setup succeeded","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881471097-05:00","updated_at":"2026-01-08T03:03:02.969764215-05:00","closed_at":"2026-01-08T03:03:02.969764215-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767859075881445643.final-check-b8e93fc4","title":"Final verification","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881513221-05:00","updated_at":"2026-01-08T03:03:02.837518938-05:00","closed_at":"2026-01-08T03:03:02.837518938-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767859075881445643.setup-7bbb265a","title":"Setup test: integration","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881469714-05:00","updated_at":"2026-01-08T03:03:03.083696409-05:00","closed_at":"2026-01-08T03:03:03.083696409-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767859143521847187.do-task-5eca0980","title":"Manual task: Testing MEOW","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent","created_at":"2026-01-08T02:59:03.521869445-05:00","updated_at":"2026-01-08T03:02:00.041190337-05:00","closed_at":"2026-01-08T02:59:18.246773414-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767859176394229162.select-item-7ac2abd9","title":"Select an item","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent","created_at":"2026-01-08T02:59:36.394244608-05:00","updated_at":"2026-01-08T03:02:00.041190337-05:00","closed_at":"2026-01-08T02:59:57.757032872-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767859214219875123.do-task-46218984","title":"Manual task: Hook Test","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent","created_at":"2026-01-08T03:00:14.219899843-05:00","updated_at":"2026-01-08T03:03:02.718661421-05:00","closed_at":"2026-01-08T03:03:02.718661421-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-1767861713546410128.hello-task-629ae87d","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello","created_at":"2026-01-08T03:41:53.546432921-05:00","updated_at":"2026-01-08T22:19:40.832850582-05:00","closed_at":"2026-01-08T22:19:40.832850582-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-1767861713546410128.start-agent-04136978","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello","created_at":"2026-01-08T03:41:53.546429546-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","closed_at":"2026-01-08T03:44:17.638700045-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861857019966617.hello-task-b9299e98","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello2","created_at":"2026-01-08T03:44:17.019993792-05:00","updated_at":"2026-01-08T22:19:40.830988378-05:00","closed_at":"2026-01-08T22:19:40.830988378-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-1767861857019966617.start-agent-76192c8f","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello2","created_at":"2026-01-08T03:44:17.019990709-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","closed_at":"2026-01-08T03:44:18.150013333-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861974163875193.hello-task-4941d5fa","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent1","created_at":"2026-01-08T03:46:14.163899172-05:00","updated_at":"2026-01-08T22:19:40.82908161-05:00","closed_at":"2026-01-08T22:19:40.82908161-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-1767861974163875193.start-agent-e0100869","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent1","created_at":"2026-01-08T03:46:14.163896247-05:00","updated_at":"2026-01-08T03:46:58.181465511-05:00","closed_at":"2026-01-08T03:46:17.300082979-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767861974163875193.verify-d4e5493e","title":"Verify test completed","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T03:46:14.163900255-05:00","updated_at":"2026-01-08T22:14:41.41283484-05:00","closed_at":"2026-01-08T22:14:41.41283484-05:00","close_reason":"Old test workflow bead - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-1767862037315936305.hello-task-6dcee4c3","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"hello1","created_at":"2026-01-08T03:47:17.315958926-05:00","updated_at":"2026-01-08T22:19:40.834712533-05:00","closed_at":"2026-01-08T22:19:40.834712533-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-1767862037315936305.start-agent-295e92a1","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"hello1","created_at":"2026-01-08T03:47:17.31595614-05:00","updated_at":"2026-01-08T03:47:52.595423519-05:00","closed_at":"2026-01-08T03:47:20.451867057-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862229223052455.hello-task-0a398443","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"hello2","created_at":"2026-01-08T03:50:29.223075246-05:00","updated_at":"2026-01-08T22:19:40.827006729-05:00","closed_at":"2026-01-08T22:19:40.827006729-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-1767862229223052455.start-agent-5f4790c4","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"hello2","created_at":"2026-01-08T03:50:29.22307204-05:00","updated_at":"2026-01-08T03:51:03.388502137-05:00","closed_at":"2026-01-08T03:50:32.359446604-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862412750392382.hello-task-dd0b9f2b","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"testx","created_at":"2026-01-08T03:53:32.750420123-05:00","updated_at":"2026-01-08T03:54:38.672099979-05:00","closed_at":"2026-01-08T03:54:38.672099979-05:00","close_reason":"Said hello world successfully","labels":["meow:ephemeral"]}
{"id":"meow-1767862412750392382.start-agent-2fbe8a64","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"testx","created_at":"2026-01-08T03:53:32.750416442-05:00","updated_at":"2026-01-08T03:53:53.068315074-05:00","closed_at":"2026-01-08T03:53:37.897172539-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1767862600737422288.hello-task-ab26b34d","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"tiertest","created_at":"2026-01-08T03:56:40.737449805-05:00","updated_at":"2026-01-08T22:19:40.818780961-05:00","closed_at":"2026-01-08T22:19:40.818780961-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-1767862600737422288.start-agent-cb852b6e","title":"Start test agent","status":"closed","priority":0,"issue_type":"task","assignee":"tiertest","created_at":"2026-01-08T03:56:40.737446232-05:00","updated_at":"2026-01-08T03:57:10.905458818-05:00","closed_at":"2026-01-08T03:56:45.858162975-05:00","labels":["meow:ephemeral"]}
{"id":"meow-1ir","title":"Implement format detection logic","description":"Detect whether file is legacy ([meta]) or module format ([workflow-name]). See IMPLEMENTATION-PLAN section meow-modules-parser-detect.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:38:36.035558315-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"No legacy format - only module format exists in MVP","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-1l1","title":"Add BeadTypeCollaborative for interactive agent-user steps","description":"Add new `collaborative` bead type per SPEC-ADDENDUM-WISPS-AND-MODULES.md (lines 241-326).\n\n## The Collaborative Type\n\nThe `collaborative` type enables **human-in-the-loop interaction** within an otherwise autonomous workflow. Unlike `task` which auto-continues via the Ralph Wiggum loop, `collaborative` pauses for conversation.\n\n```go\nconst (\n    // Agent-executable\n    BeadTypeTask          BeadType = \"task\"          // Agent does work, auto-continues\n    BeadTypeCollaborative BeadType = \"collaborative\" // Agent + human conversation, pauses\n    BeadTypeGate          BeadType = \"gate\"          // Human approval point (no assignee)\n    \n    // Orchestrator-executable\n    BeadTypeStart     BeadType = \"start\"\n    BeadTypeStop      BeadType = \"stop\"\n    BeadTypeCondition BeadType = \"condition\"\n    BeadTypeCode      BeadType = \"code\"\n    BeadTypeExpand    BeadType = \"expand\"\n)\n```\n\n## Type Behavior Summary\n\n| Type | Assignee | Auto-continue | Who closes | Use case |\n|------|----------|---------------|------------|----------|\n| `task` | Required | Yes (Ralph Wiggum) | Agent | Normal autonomous work |\n| `collaborative` | Required | No (pauses) | Agent | Design review, clarification |\n| `gate` | None | No | Human | Approval checkpoints |\n\n## How Collaborative Works\n\n1. Agent executes step (presents info, asks questions)\n2. Agent's stop hook fires, BUT...\n3. `meow prime --format prompt` returns **empty** for in-progress collaborative steps\n4. No prompt injection → Claude waits for user input\n5. User and agent converse freely\n6. Agent runs `meow close \u003cstep-id\u003e` when done\n7. Next stop hook fires, normal flow resumes\n\n## Validation Rules\n\n- **Must have assignee** - Unlike gate, collaborative needs an agent\n- **Tier detection** - Handled same as task (wisp if in ephemeral workflow)\n\n## File Location\nModify: `internal/types/bead.go`\n\n## Acceptance Criteria\n- [ ] BeadTypeCollaborative constant added\n- [ ] Valid() updated to include collaborative\n- [ ] Collaborative validation: must have assignee (like task)\n- [ ] Unit tests for collaborative type\n- [ ] Documentation updated","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T17:59:06.403106737-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Consolidated into meow-bba. The collaborative type is now part of the unified Bead struct changes task.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-1lh","title":"Feature: Advanced E2E Test Suite","description":"# Feature: Advanced E2E Test Suite\n\n## Parent Epic\nmeow-qai: E2E Testing Infrastructure with Claude Simulator\n\n## Overview\n\nImplement advanced E2E tests covering complex scenarios: parallel agents, event routing, crash recovery, and template patterns. These tests validate MEOW's behavior under stress and edge cases.\n\n## Test Categories\n\n### 1. Parallel Agent Tests\n\nVerify correct handling of multiple concurrent agents:\n\n```go\nfunc TestE2E_ParallelAgents_TwoAgents(t *testing.T) {\n    // Two agents work in parallel, both complete\n    // Verifies: no cross-contamination, correct isolation\n}\n\nfunc TestE2E_ParallelAgents_ThreeAgentsJoin(t *testing.T) {\n    // Three agents work in parallel\n    // Join step waits for all three\n    // Verifies: correct synchronization\n}\n\nfunc TestE2E_ParallelAgents_DifferentDelays(t *testing.T) {\n    // Agents complete at different times\n    // Verifies: no race conditions in step tracking\n}\n\nfunc TestE2E_ParallelAgents_OneFailsOthersContinue(t *testing.T) {\n    // One agent fails, others complete normally\n    // Verifies: failure isolation (with on_error=continue)\n}\n```\n\n### 2. Event Routing Tests\n\nVerify event emission and await-event matching:\n\n```go\nfunc TestE2E_Events_ToolEventsEmitted(t *testing.T) {\n    // Simulator emits tool-starting, tool-completed\n    // Verifies: events reach orchestrator\n}\n\nfunc TestE2E_Events_AwaitEventMatches(t *testing.T) {\n    // Branch condition: meow await-event tool-completed\n    // Verifies: event routing to waiters\n}\n\nfunc TestE2E_Events_AwaitEventWithFilter(t *testing.T) {\n    // Filter: --filter tool=Write\n    // Verifies: only matching events satisfy waiter\n}\n\nfunc TestE2E_Events_AwaitEventTimeout(t *testing.T) {\n    // No matching event → timeout\n    // Verifies: timeout branch taken\n}\n\nfunc TestE2E_Events_MultipleWaiters(t *testing.T) {\n    // Multiple await-event waiters\n    // First-match-wins semantics\n}\n```\n\n### 3. Crash Recovery Tests\n\nVerify correct behavior after orchestrator crash:\n\n```go\nfunc TestE2E_CrashRecovery_OrchestratorRestart(t *testing.T) {\n    // Orchestrator crashes mid-workflow\n    // Restart with --resume\n    // Verifies: workflow continues from correct state\n}\n\nfunc TestE2E_CrashRecovery_RunningStepsReset(t *testing.T) {\n    // Orchestrator step was running when crashed\n    // Verifies: step reset to pending, retries\n}\n\nfunc TestE2E_CrashRecovery_AgentStillAlive(t *testing.T) {\n    // Agent tmux session survived crash\n    // Verifies: agent reused, not respawned\n}\n\nfunc TestE2E_CrashRecovery_PartialExpansion(t *testing.T) {\n    // Expand step was running when crashed\n    // Verifies: partial children removed, expand retries\n}\n```\n\n### 4. Template Pattern Tests\n\nVerify complex workflow patterns from templates:\n\n```go\nfunc TestE2E_Template_ExpandNested(t *testing.T) {\n    // Template expands another template\n    // Verifies: nested expansion works\n}\n\nfunc TestE2E_Template_BranchCondition(t *testing.T) {\n    // Branch with shell condition\n    // Verifies: correct branch taken\n}\n\nfunc TestE2E_Template_ForEach(t *testing.T) {\n    // Foreach over list of items\n    // Verifies: correct iteration, implicit join\n}\n\nfunc TestE2E_Template_RecursiveLoop(t *testing.T) {\n    // Template calls itself (with termination condition)\n    // Verifies: recursion works, terminates correctly\n}\n```\n\n### 5. Stress Tests\n\nVerify behavior under load (optional, longer running):\n\n```go\nfunc TestE2E_Stress_ManyAgents(t *testing.T) {\n    // 10 parallel agents\n    // Verifies: no resource exhaustion\n}\n\nfunc TestE2E_Stress_ManySteps(t *testing.T) {\n    // 100 steps in sequence\n    // Verifies: no memory leaks, correct tracking\n}\n\nfunc TestE2E_Stress_LargeOutputs(t *testing.T) {\n    // Outputs with large data (1MB)\n    // Verifies: IPC handles large messages\n}\n```\n\n## Test File Organization\n\n```\ntest/e2e/\n├── parallel_test.go        # Parallel agent tests\n├── events_test.go          # Event routing tests\n├── recovery_test.go        # Crash recovery tests\n├── template_test.go        # Template pattern tests\n├── stress_test.go          # Stress tests (separate, longer)\n├── testdata/\n│   ├── templates/\n│   │   ├── parallel-three.meow.toml\n│   │   ├── event-monitor.meow.toml\n│   │   ├── recursive-loop.meow.toml\n│   │   └── foreach-items.meow.toml\n│   └── configs/\n│       ├── parallel-worker.yaml\n│       ├── emit-tool-events.yaml\n│       └── crashable.yaml\n└── README.md\n```\n\n## Test Workflow Templates\n\n### parallel-three.meow.toml\n```toml\n[main]\nname = \"parallel-three\"\n\n[[main.steps]]\nid = \"spawn-1\"\nexecutor = \"spawn\"\nagent = \"worker-1\"\nadapter = \"simulator\"\n\n[[main.steps]]\nid = \"spawn-2\"\nexecutor = \"spawn\"\nagent = \"worker-2\"\nadapter = \"simulator\"\n\n[[main.steps]]\nid = \"spawn-3\"\nexecutor = \"spawn\"\nagent = \"worker-3\"\nadapter = \"simulator\"\n\n[[main.steps]]\nid = \"work-1\"\nexecutor = \"agent\"\nagent = \"worker-1\"\nprompt = \"task 1\"\nneeds = [\"spawn-1\"]\n\n[[main.steps]]\nid = \"work-2\"\nexecutor = \"agent\"\nagent = \"worker-2\"\nprompt = \"task 2\"\nneeds = [\"spawn-2\"]\n\n[[main.steps]]\nid = \"work-3\"\nexecutor = \"agent\"\nagent = \"worker-3\"\nprompt = \"task 3\"\nneeds = [\"spawn-3\"]\n\n[[main.steps]]\nid = \"join\"\nexecutor = \"shell\"\ncommand = \"echo 'all done'\"\nneeds = [\"work-1\", \"work-2\", \"work-3\"]\n\n[[main.steps]]\nid = \"cleanup\"\nexecutor = \"shell\"\ncommand = \"true\"\nneeds = [\"join\"]\n# Kill steps omitted for brevity\n```\n\n### event-monitor.meow.toml\n```toml\n[main]\nname = \"event-monitor\"\n\n[[main.steps]]\nid = \"spawn\"\nexecutor = \"spawn\"\nagent = \"worker\"\nadapter = \"simulator\"\n\n[[main.steps]]\nid = \"work\"\nexecutor = \"agent\"\nagent = \"worker\"\nprompt = \"process files\"  # Triggers tool events in simulator\nneeds = [\"spawn\"]\n\n[[main.steps]]\nid = \"wait-for-tool\"\nexecutor = \"branch\"\ncondition = \"meow await-event tool-completed --filter tool=Write --timeout 5s\"\nneeds = [\"spawn\"]  # Parallel with work\n\n[main.steps.on_true]\ninline = [\n  { id = \"tool-detected\", executor = \"shell\", command = \"echo 'Tool event received'\" }\n]\n\n[[main.steps]]\nid = \"cleanup\"\nexecutor = \"kill\"\nagent = \"worker\"\nneeds = [\"work\", \"wait-for-tool\"]\n```\n\n## Acceptance Criteria\n\n1. [ ] Parallel tests verify true concurrency\n2. [ ] Event tests verify routing and filtering\n3. [ ] Recovery tests verify state restoration\n4. [ ] Template tests cover all template patterns\n5. [ ] Stress tests pass (if enabled)\n6. [ ] No flaky tests in any category\n\n## Dependencies\n\n- meow-ag6: Core E2E Test Suite (build on core tests)\n\n## Test Tags\n\nUse build tags to separate test categories:\n\n```go\n//go:build e2e \u0026\u0026 !stress\n// +build e2e,!stress\n\npackage e2e\n\n// Normal E2E tests\n```\n\n```go\n//go:build e2e \u0026\u0026 stress\n// +build e2e,stress\n\npackage e2e\n\n// Stress tests (run separately)\n```\n\n```bash\n# Run normal E2E tests\ngo test ./test/e2e/... -tags e2e\n\n# Run stress tests too\ngo test ./test/e2e/... -tags 'e2e stress'\n```\n\n## Reference\n\n- `docs/E2E-TESTING-DESIGN.md` - Section: Test Scenarios\n- `.meow/templates/` - Existing template patterns to cover","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-09T19:56:37.063597162-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:56:37.063597162-05:00","dependencies":[{"issue_id":"meow-1lh","depends_on_id":"meow-ag6","type":"blocks","created_at":"2026-01-09T19:56:42.403857721-05:00","created_by":"ubuntu"}]}
{"id":"meow-1mc","title":"Implement item_var and index_var substitution","description":"Extend variable substitution to support foreach iteration variables.\n\nWhen expanding a foreach iteration:\n- Set item_var to current item (can be object, string, number, etc.)\n- Set index_var to current 0-based index (if specified)\n- These variables are available in the template's variables block\n- Handle nested object access (e.g., {{task.description}})","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:33.135483295-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:33.135483295-05:00"}
{"id":"meow-201","title":"Define WorkflowStore interface","description":"# Define WorkflowStore Interface\n\n## File: internal/orchestrator/workflowstore.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// WorkflowStore provides persistence for workflow state.\ntype WorkflowStore interface {\n    // Create persists a new workflow.\n    Create(ctx context.Context, wf *types.Workflow) error\n\n    // Get retrieves a workflow by ID.\n    Get(ctx context.Context, id string) (*types.Workflow, error)\n\n    // Save persists workflow state (atomic write).\n    Save(ctx context.Context, wf *types.Workflow) error\n\n    // Delete removes a workflow.\n    Delete(ctx context.Context, id string) error\n\n    // List returns all workflows matching filter.\n    List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error)\n\n    // GetByAgent returns workflows with steps assigned to agent.\n    GetByAgent(ctx context.Context, agentID string) ([]*types.Workflow, error)\n}\n\n// WorkflowFilter for listing workflows.\ntype WorkflowFilter struct {\n    Status types.WorkflowStatus // Filter by status\n}\n```\n\n## Design Notes\n\n- **Simple interface** - Just CRUD + listing\n- **No tier filtering** - Tiers don't exist in new model\n- **GetByAgent** - Needed for `meow prime` to find agent's work\n- **Atomic Save** - Implementation must be atomic (temp file + rename)\n\n## Acceptance Criteria\n\n- [ ] WorkflowStore interface defined\n- [ ] WorkflowFilter struct\n- [ ] Interface documented","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:11Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.971932522-05:00","closed_at":"2026-01-08T22:58:49.971932522-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"meow-201","depends_on_id":"meow-105","type":"blocks","created_at":"2026-01-08T12:00:11Z","created_by":"claude"}]}
{"id":"meow-202","title":"Implement YAMLWorkflowStore","description":"# Implement YAMLWorkflowStore\n\n## File: internal/orchestrator/yamlstore.go\n\n## Implementation\n\nThis implementation includes **atomic file writes** and **orchestrator lock management** (previously meow-204).\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n    \"syscall\"\n\n    \"gopkg.in/yaml.v3\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// YAMLWorkflowStore persists workflows as YAML files with atomic writes.\ntype YAMLWorkflowStore struct {\n    dir      string   // .meow/workflows\n    lockFile *os.File // Exclusive lock to prevent multiple orchestrators\n}\n\n// NewYAMLWorkflowStore creates a new store and acquires exclusive lock.\nfunc NewYAMLWorkflowStore(dir string) (*YAMLWorkflowStore, error) {\n    if err := os.MkdirAll(dir, 0755); err != nil {\n        return nil, fmt.Errorf(\"creating workflow dir: %w\", err)\n    }\n    \n    // Acquire exclusive lock\n    lockPath := filepath.Join(dir, \".lock\")\n    lockFile, err := os.OpenFile(lockPath, os.O_CREATE|os.O_RDWR, 0644)\n    if err != nil {\n        return nil, fmt.Errorf(\"opening lock file: %w\", err)\n    }\n    \n    if err := syscall.Flock(int(lockFile.Fd()), syscall.LOCK_EX|syscall.LOCK_NB); err != nil {\n        lockFile.Close()\n        return nil, fmt.Errorf(\"another orchestrator is running (lock held): %w\", err)\n    }\n    \n    // Recover from any interrupted writes\n    if err := recoverInterruptedWrites(dir); err != nil {\n        lockFile.Close()\n        return nil, fmt.Errorf(\"recovering interrupted writes: %w\", err)\n    }\n    \n    return \u0026YAMLWorkflowStore{dir: dir, lockFile: lockFile}, nil\n}\n\n// Close releases the lock.\nfunc (s *YAMLWorkflowStore) Close() error {\n    if s.lockFile != nil {\n        syscall.Flock(int(s.lockFile.Fd()), syscall.LOCK_UN)\n        return s.lockFile.Close()\n    }\n    return nil\n}\n\n// recoverInterruptedWrites handles .tmp files left from crashed writes.\nfunc recoverInterruptedWrites(dir string) error {\n    entries, err := os.ReadDir(dir)\n    if err != nil {\n        return err\n    }\n    \n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml.tmp\") {\n            continue\n        }\n        \n        tmpPath := filepath.Join(dir, entry.Name())\n        mainPath := strings.TrimSuffix(tmpPath, \".tmp\")\n        \n        // Check if main file exists and is valid\n        if _, err := os.Stat(mainPath); err == nil {\n            // Main file exists, delete orphan temp\n            os.Remove(tmpPath)\n        } else {\n            // Main file missing, promote temp\n            os.Rename(tmpPath, mainPath)\n        }\n    }\n    return nil\n}\n\n// Save persists workflow state atomically (write-then-rename).\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow) error {\n    data, err := yaml.Marshal(wf)\n    if err != nil {\n        return fmt.Errorf(\"marshaling workflow: %w\", err)\n    }\n    \n    mainPath := filepath.Join(s.dir, wf.ID+\".yaml\")\n    tmpPath := mainPath + \".tmp\"\n    \n    // Write to temp file\n    if err := os.WriteFile(tmpPath, data, 0644); err != nil {\n        return fmt.Errorf(\"writing temp file: %w\", err)\n    }\n    \n    // Atomic rename\n    if err := os.Rename(tmpPath, mainPath); err != nil {\n        os.Remove(tmpPath) // Clean up on failure\n        return fmt.Errorf(\"renaming temp file: %w\", err)\n    }\n    \n    return nil\n}\n\n// Get retrieves a workflow by ID.\nfunc (s *YAMLWorkflowStore) Get(ctx context.Context, id string) (*types.Workflow, error) {\n    path := filepath.Join(s.dir, id+\".yaml\")\n    data, err := os.ReadFile(path)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil, fmt.Errorf(\"workflow not found: %s\", id)\n        }\n        return nil, err\n    }\n    \n    var wf types.Workflow\n    if err := yaml.Unmarshal(data, \u0026wf); err != nil {\n        return nil, fmt.Errorf(\"parsing workflow %s: %w\", id, err)\n    }\n    return \u0026wf, nil\n}\n\n// Create persists a new workflow.\nfunc (s *YAMLWorkflowStore) Create(ctx context.Context, wf *types.Workflow) error {\n    path := filepath.Join(s.dir, wf.ID+\".yaml\")\n    if _, err := os.Stat(path); err == nil {\n        return fmt.Errorf(\"workflow already exists: %s\", wf.ID)\n    }\n    return s.Save(ctx, wf)\n}\n\n// Delete removes a workflow.\nfunc (s *YAMLWorkflowStore) Delete(ctx context.Context, id string) error {\n    path := filepath.Join(s.dir, id+\".yaml\")\n    return os.Remove(path)\n}\n\n// List returns all workflows matching filter.\nfunc (s *YAMLWorkflowStore) List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error) {\n    entries, err := os.ReadDir(s.dir)\n    if err != nil {\n        return nil, err\n    }\n    \n    var workflows []*types.Workflow\n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml\") || entry.Name() == \".lock\" {\n            continue\n        }\n        \n        id := strings.TrimSuffix(entry.Name(), \".yaml\")\n        wf, err := s.Get(ctx, id)\n        if err != nil {\n            continue // Skip invalid files\n        }\n        \n        if filter.Status != \"\" \u0026\u0026 wf.Status != filter.Status {\n            continue\n        }\n        workflows = append(workflows, wf)\n    }\n    return workflows, nil\n}\n\n// GetByAgent returns workflows with steps assigned to agent.\nfunc (s *YAMLWorkflowStore) GetByAgent(ctx context.Context, agentID string) ([]*types.Workflow, error) {\n    all, err := s.List(ctx, WorkflowFilter{})\n    if err != nil {\n        return nil, err\n    }\n    \n    var result []*types.Workflow\n    for _, wf := range all {\n        for _, step := range wf.Steps {\n            if step.Agent != nil \u0026\u0026 step.Agent.Agent == agentID {\n                result = append(result, wf)\n                break\n            }\n        }\n    }\n    return result, nil\n}\n```\n\n## Key Features\n\n1. **Atomic writes** - write-then-rename pattern prevents corruption\n2. **Exclusive lock** - prevents multiple orchestrators via flock()\n3. **Crash recovery** - handles orphan .tmp files on startup\n4. **Clean shutdown** - Close() releases lock\n\n## Acceptance Criteria\n\n- [ ] Create, Get, Save, Delete, List, GetByAgent methods\n- [ ] Atomic file writes (temp file + rename)\n- [ ] Exclusive lock via flock() on .lock file\n- [ ] recoverInterruptedWrites() on startup\n- [ ] Close() releases lock\n- [ ] Filter by status in List()\n- [ ] Unit tests for all methods\n- [ ] Test crash recovery scenarios\n- [ ] Test lock contention\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:12Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.973822351-05:00","closed_at":"2026-01-08T22:58:49.973822351-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"meow-202","depends_on_id":"meow-201","type":"blocks","created_at":"2026-01-08T12:00:12Z","created_by":"claude"}]}
{"id":"meow-204","title":"Implement atomic file writes and orchestrator lock management","description":"Implement atomic file writes (write-to-temp + rename) for workflow state and molecule files. Add lock file management to prevent multiple orchestrator instances per MVP-SPEC-v2 durability requirements.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T22:18:49.276375458-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:36:45.040394437-05:00","closed_at":"2026-01-08T22:36:45.040394437-05:00","close_reason":"Merged into pivot-202 - atomic writes are integral to YAMLWorkflowStore implementation, not a separate concern","dependencies":[{"issue_id":"meow-204","depends_on_id":"meow-301","type":"blocks","created_at":"2026-01-08T12:00:14Z","created_by":"claude"},{"issue_id":"meow-204","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T22:21:24.168081308-05:00","created_by":"ubuntu"},{"issue_id":"meow-204","depends_on_id":"meow-202","type":"blocks","created_at":"2026-01-08T22:21:24.168081308-05:00","created_by":"ubuntu"}]}
{"id":"meow-205","title":"Implement workflow cleanup script execution and signal handling","description":"Implement cleanup script execution on workflow completion/abort. Handle SIGINT/SIGTERM signals gracefully, ensuring state is persisted and cleanup runs per MVP-SPEC-v2.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T22:18:50.213356837-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:18:50.213356837-05:00","dependencies":[{"issue_id":"meow-205","depends_on_id":"meow-411","type":"blocks","created_at":"2026-01-08T22:21:53.94051558-05:00","created_by":"ubuntu"}]}
{"id":"meow-301","title":"Update template parser for executor field","description":"# Update Template Parser for Executor Field\n\n## File: internal/template/module.go\n\n## Changes\n\n### Step struct update\n\n```go\n// Before\ntype Step struct {\n    ID           string   `toml:\"id\"`\n    Type         string   `toml:\"type\"`  // ← Remove\n    Instructions string   `toml:\"instructions\"`\n    Assignee     string   `toml:\"assignee\"`\n    // ...\n}\n\n// After\ntype Step struct {\n    ID       string `toml:\"id\"`\n    Executor string `toml:\"executor\"` // ← Add\n\n    // Agent executor fields\n    Agent  string `toml:\"agent,omitempty\"`\n    Prompt string `toml:\"prompt,omitempty\"`\n    Mode   string `toml:\"mode,omitempty\"` // autonomous | interactive\n\n    // Shell executor fields\n    Command string `toml:\"command,omitempty\"`\n    Workdir string `toml:\"workdir,omitempty\"`\n    OnError string `toml:\"on_error,omitempty\"`\n\n    // Spawn executor fields (also uses Agent, Workdir)\n    ResumeSession string `toml:\"resume_session,omitempty\"`\n\n    // Kill executor fields (uses Agent)\n    Graceful *bool `toml:\"graceful,omitempty\"`\n    Timeout  int   `toml:\"timeout,omitempty\"`\n\n    // Expand executor fields\n    Template  string            `toml:\"template,omitempty\"`\n    Variables map[string]string `toml:\"variables,omitempty\"`\n\n    // Branch executor fields\n    Condition string               `toml:\"condition,omitempty\"`\n    OnTrue    *ExpansionTarget     `toml:\"on_true,omitempty\"`\n    OnFalse   *ExpansionTarget     `toml:\"on_false,omitempty\"`\n    OnTimeout *ExpansionTarget     `toml:\"on_timeout,omitempty\"`\n\n    // Gate executor fields (uses Prompt)\n    // Timeout already defined above\n\n    // Shared\n    Needs   []string          `toml:\"needs,omitempty\"`\n    Env     map[string]string `toml:\"env,omitempty\"`\n    Outputs map[string]any    `toml:\"outputs,omitempty\"`\n}\n```\n\n### Validation update\n\nValidate that required fields are present based on executor:\n\n```go\nfunc (s *Step) Validate() error {\n    switch s.Executor {\n    case \"shell\":\n        if s.Command == \"\" {\n            return fmt.Errorf(\"shell executor requires command\")\n        }\n    case \"agent\":\n        if s.Agent == \"\" {\n            return fmt.Errorf(\"agent executor requires agent\")\n        }\n        if s.Prompt == \"\" {\n            return fmt.Errorf(\"agent executor requires prompt\")\n        }\n    // ... etc\n    }\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Step struct uses executor field\n- [ ] All executor-specific fields present\n- [ ] Validation checks required fields per executor\n- [ ] Old 'type' field no longer parsed\n- [ ] Update all test templates\n- [ ] Unit tests for each executor type","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:21Z","created_by":"claude","updated_at":"2026-01-08T22:57:24.474662286-05:00","closed_at":"2026-01-08T22:57:24.474662286-05:00","close_reason":"Implemented executor field in Step struct with validation per executor type. Added unit tests.","dependencies":[{"issue_id":"meow-301","depends_on_id":"meow-103","type":"blocks","created_at":"2026-01-08T12:00:21Z","created_by":"claude"}]}
{"id":"meow-302","title":"Remove ephemeral and hooks_to from workflow","description":"# Remove ephemeral and hooks_to from Workflow\n\n## File: internal/template/module.go\n\n## Changes\n\n### Remove from Workflow struct\n\n```go\n// Before\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Ephemeral   bool            `toml:\"ephemeral,omitempty\"`   // ← Remove\n    Internal    bool            `toml:\"internal,omitempty\"`\n    HooksTo     string          `toml:\"hooks_to,omitempty\"`    // ← Remove\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n\n// After\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Internal    bool            `toml:\"internal,omitempty\"`\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n```\n\n### Why These Are Removed\n\n**ephemeral**: Was used to mark workflows whose steps become \"wisps\" (agent-visible ephemeral steps). In the new model, there's no tier distinction - all steps are just steps.\n\n**hooks_to**: Was used to link wisp steps to a work bead ID. In the new model, MEOW is task-tracking agnostic - it doesn't know about beads.\n\n## Migration Note\n\nExisting templates with these fields will have them ignored (TOML parsing allows extra fields). We should update example templates to remove them.\n\n## Acceptance Criteria\n\n- [ ] ephemeral field removed from Workflow struct\n- [ ] hooks_to field removed from Workflow struct\n- [ ] Update all example templates\n- [ ] Update tests that used these fields\n- [ ] No runtime errors if old templates have these fields","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:22Z","created_by":"claude","updated_at":"2026-01-08T23:03:18.939121034-05:00","closed_at":"2026-01-08T23:03:18.939121034-05:00","close_reason":"Removed ephemeral and hooks_to from Workflow struct. Step.Ephemeral retained as legacy.","dependencies":[{"issue_id":"meow-302","depends_on_id":"meow-301","type":"blocks","created_at":"2026-01-08T22:21:28.226286481-05:00","created_by":"ubuntu"}]}
{"id":"meow-303","title":"Refactor baker to create Steps instead of Beads","description":"# Refactor Baker to Create Steps Instead of Beads\n\n## File: internal/template/baker.go\n\n## The Big Change\n\nThe baker currently transforms template workflows into Bead objects. It needs to transform them into Step objects instead.\n\n### Before\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Bead, error) {\n    var beads []*types.Bead\n    for _, step := range workflow.Steps {\n        bead := b.workflowStepToBead(step, vars)\n        beads = append(beads, bead)\n    }\n    return beads, nil\n}\n```\n\n### After\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Step, error) {\n    var steps []*types.Step\n    for _, templateStep := range workflow.Steps {\n        step := b.templateStepToStep(templateStep, vars)\n        steps = append(steps, step)\n    }\n    return steps, nil\n}\n\nfunc (b *Baker) templateStepToStep(ts *Step, vars map[string]string) *types.Step {\n    step := \u0026types.Step{\n        ID:       ts.ID,\n        Executor: types.ExecutorType(ts.Executor),\n        Status:   types.StepStatusPending,\n        Needs:    ts.Needs,\n    }\n\n    // Set executor-specific config\n    switch step.Executor {\n    case types.ExecutorShell:\n        step.Shell = \u0026types.ShellConfig{\n            Command: substitute(ts.Command, vars),\n            Workdir: substitute(ts.Workdir, vars),\n            Env:     substituteMap(ts.Env, vars),\n            OnError: ts.OnError,\n        }\n    case types.ExecutorAgent:\n        step.Agent = \u0026types.AgentConfig{\n            Agent:  substitute(ts.Agent, vars),\n            Prompt: substitute(ts.Prompt, vars),\n            Mode:   types.AgentMode(ts.Mode),\n        }\n    // ... other executors\n    }\n\n    return step\n}\n```\n\n## What to Remove\n\n- Tier detection logic (determineTier)\n- HookBead assignment\n- SourceWorkflow assignment\n- All bead-specific field setting\n\n## Acceptance Criteria\n\n- [ ] Baker.Bake() returns []*types.Step\n- [ ] All 7 executor types create correct config\n- [ ] Variable substitution works in all fields\n- [ ] No tier/HookBead logic remains\n- [ ] Unit tests for each executor type","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:23Z","created_by":"claude","updated_at":"2026-01-08T23:52:03.912888016-05:00","closed_at":"2026-01-08T23:52:03.912888016-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-303","depends_on_id":"meow-301","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"},{"issue_id":"meow-303","depends_on_id":"meow-302","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"},{"issue_id":"meow-303","depends_on_id":"meow-105","type":"blocks","created_at":"2026-01-08T22:21:32.735452222-05:00","created_by":"ubuntu"}]}
{"id":"meow-304","title":"Add step ID validation (no dots allowed)","description":"Validate step IDs to disallow dots - dots are reserved for template expansion prefixes (e.g., parent.child notation) per MVP-SPEC-v2 template expansion rules.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T22:18:51.068460004-05:00","created_by":"ubuntu","updated_at":"2026-01-08T23:42:55.756139344-05:00","closed_at":"2026-01-08T23:42:55.756139344-05:00","close_reason":"Step ID validation already implemented and tested in step.go:225-227 and step_test.go:126-147","dependencies":[{"issue_id":"meow-304","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T22:21:29.215926313-05:00","created_by":"ubuntu"},{"issue_id":"meow-304","depends_on_id":"meow-301","type":"blocks","created_at":"2026-01-08T22:21:29.215926313-05:00","created_by":"ubuntu"}]}
{"id":"meow-306","title":"Implement shell context escaping for variable substitution","description":"Implement proper shell escaping when substituting context variables into step instructions and shell commands per MVP-SPEC-v2 template system requirements.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T22:18:51.917780676-05:00","created_by":"ubuntu","updated_at":"2026-01-08T23:42:56.552022762-05:00","closed_at":"2026-01-08T23:42:56.552022762-05:00","close_reason":"Added ShellEscape function and SubstituteForShell method in vars.go with comprehensive tests","dependencies":[{"issue_id":"meow-306","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T22:21:30.533020221-05:00","created_by":"ubuntu"},{"issue_id":"meow-306","depends_on_id":"meow-301","type":"blocks","created_at":"2026-01-08T22:21:30.533020221-05:00","created_by":"ubuntu"}]}
{"id":"meow-33i","title":"Implement error type classification","description":"Update each executor to classify errors with appropriate error types.\n\nFor each executor, ensure failures set the correct error type:\n- Agent: detect timeout vs crash vs not_found\n- Shell: command_failed on non-zero, timeout if applicable\n- Spawn: spawn_failed for any spawn issue\n- Expand: template_not_found or expansion_limit\n- Branch: condition_error vs expansion_limit\n- Foreach: invalid_items, expansion_limit, child_failed\n\nUpdate executor implementations to use these classifications.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:26.319428083-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:26.319428083-05:00","dependencies":[{"issue_id":"meow-33i","depends_on_id":"meow-ljo","type":"blocks","created_at":"2026-01-09T15:04:05.802439112-05:00","created_by":"ubuntu"},{"issue_id":"meow-33i","depends_on_id":"meow-74g","type":"blocks","created_at":"2026-01-09T15:04:05.918193812-05:00","created_by":"ubuntu"}]}
{"id":"meow-354","title":"Agent Adapters","description":"## Background\n\nMEOW needs to be agent-agnostic. Currently, the codebase has Claude Code hardcoded in the TmuxAgentManager. This epic covers implementing the Agent Adapter system defined in MVP-SPEC-v2 Section 6 (Agent Adapters).\n\nThe adapter system allows users to:\n- Use different AI agents (Claude Code, Aider, Cursor Agent, custom agents)\n- Define how to spawn, stop, inject prompts, and receive events from each agent\n- Install/manage adapters via CLI\n- Share adapters across projects\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Agent Adapters\n\nKey components:\n- Adapter directory structure (~/.meow/adapters/\u003cname\u003e/)\n- adapter.toml configuration format\n- Optional setup.sh and event-translator.sh scripts\n- Adapter resolution order (step -\u003e workflow -\u003e project -\u003e global -\u003e built-in)\n- CLI commands: meow adapter install/list/show/setup/remove\n\n## Success Criteria\n\n- [ ] Adapter configuration format defined and parsed\n- [ ] Adapter loading from ~/.meow/adapters/\n- [ ] TmuxAgentManager refactored to use adapters\n- [ ] Built-in claude adapter included\n- [ ] CLI commands for adapter management\n- [ ] Documentation and examples\n\n## Dependencies\n\nThis epic depends on the existing spawn/kill executor implementation being stable.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-09T02:45:52.848221242-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:45:52.848221242-05:00"}
{"id":"meow-354.1","title":"Define Adapter Configuration Types","description":"## Background\n\nThe adapter system needs Go types to represent the adapter.toml configuration. These types will be used when loading adapters from disk and when the agent manager needs to know how to interact with a specific agent.\n\nThis is the foundation of the adapter system - all other adapter work depends on these types.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Agent Adapters - Adapter Configuration\n\n```toml\n[adapter]\nname = \"claude\"\ndescription = \"Claude Code CLI agent\"\n\n[spawn]\ncommand = \"claude --dangerously-skip-permissions\"\nresume_command = \"claude --dangerously-skip-permissions --resume {{session_id}}\"\nstartup_delay = \"3s\"\n\n[environment]\nTMUX = \"\"\n\n[prompt_injection]\npre_keys = [\"Escape\"]\npre_delay = \"100ms\"\nmethod = \"literal\"  # or \"keys\"\npost_keys = [\"Enter\"]\n\n[graceful_stop]\nkeys = [\"C-c\"]\nwait = \"2s\"\n\n[events]\ntranslator = \"./event-translator.sh\"\n\n[events.agent_config]\nStop = \"{{adapter_dir}}/event-translator.sh Stop\"\n# ...\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- `internal/types/adapter.go` (new) - Define adapter types\n\nTypes to define:\n```go\ntype AdapterConfig struct {\n    Adapter      AdapterMeta         `toml:\"adapter\"`\n    Spawn        SpawnConfig         `toml:\"spawn\"`\n    Environment  map[string]string   `toml:\"environment\"`\n    PromptInject PromptInjection     `toml:\"prompt_injection\"`\n    GracefulStop GracefulStopConfig  `toml:\"graceful_stop\"`\n    Events       EventConfig         `toml:\"events\"`\n}\n\ntype AdapterMeta struct {\n    Name        string `toml:\"name\"`\n    Description string `toml:\"description\"`\n}\n\ntype SpawnConfig struct {\n    Command       string        `toml:\"command\"`\n    ResumeCommand string        `toml:\"resume_command\"`\n    StartupDelay  time.Duration `toml:\"startup_delay\"`\n}\n\ntype PromptInjection struct {\n    PreKeys   []string      `toml:\"pre_keys\"`\n    PreDelay  time.Duration `toml:\"pre_delay\"`\n    Method    string        `toml:\"method\"`  // \"literal\" or \"keys\"\n    PostKeys  []string      `toml:\"post_keys\"`\n}\n\ntype GracefulStopConfig struct {\n    Keys []string      `toml:\"keys\"`\n    Wait time.Duration `toml:\"wait\"`\n}\n\ntype EventConfig struct {\n    Translator  string            `toml:\"translator\"`\n    AgentConfig map[string]string `toml:\"agent_config\"`\n}\n```\n\n## Acceptance Criteria\n\n- [ ] AdapterConfig and all nested types defined in internal/types/adapter.go\n- [ ] TOML tags for all fields\n- [ ] Duration fields parse correctly from strings like \"3s\", \"100ms\"\n- [ ] Unit tests for TOML parsing with sample adapter.toml\n- [ ] Validation function to check required fields (name, spawn.command)\n\n## Considerations\n\n- Duration parsing: TOML doesn't have native duration type. Use `github.com/BurntSushi/toml` which can handle duration strings, or use custom unmarshaler.\n- Default values: Some fields have sensible defaults (e.g., startup_delay = 0, method = \"literal\")\n- Validation: adapter.name and spawn.command are required; others are optional","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:46:24.16420707-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:07:47.236838045-05:00","closed_at":"2026-01-09T17:07:47.236838045-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-354.1","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:46:24.165185791-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.10","title":"Add Project and Global Config for Default Adapter","description":"## Background\n\nThe adapter resolution order includes project-level and global-level defaults. This requires adding config file support for .meow/config.toml and ~/.meow/config.toml.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Adapter Resolution Order\n\n3. Project-level: .meow/config.toml [agents] default_adapter\n4. Global-level: ~/.meow/config.toml [agents] default_adapter\n\nExample config.toml:\n```toml\n[agents]\ndefault_adapter = \"claude\"\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- internal/config/config.go (new or modify existing)\n- Add config loading to orchestrator initialization\n\nConfig structure:\n```go\ntype Config struct {\n    Agents AgentsConfig `toml:\"agents\"`\n}\n\ntype AgentsConfig struct {\n    DefaultAdapter string `toml:\"default_adapter\"`\n}\n```\n\nLoading hierarchy:\n```go\nfunc LoadConfig(projectDir string) (*Config, error) {\n    cfg := \u0026Config{\n        Agents: AgentsConfig{\n            DefaultAdapter: \"claude\", // built-in default\n        },\n    }\n    \n    // Load global config\n    globalPath := filepath.Join(os.Getenv(\"HOME\"), \".meow\", \"config.toml\")\n    if data, err := os.ReadFile(globalPath); err == nil {\n        toml.Unmarshal(data, cfg)\n    }\n    \n    // Load project config (overrides global)\n    projectPath := filepath.Join(projectDir, \".meow\", \"config.toml\")\n    if data, err := os.ReadFile(projectPath); err == nil {\n        toml.Unmarshal(data, cfg)\n    }\n    \n    return cfg, nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Config type defined with agents.default_adapter\n- [ ] LoadConfig reads from ~/.meow/config.toml\n- [ ] LoadConfig reads from .meow/config.toml (overrides global)\n- [ ] Missing config files handled gracefully\n- [ ] Orchestrator uses config for adapter resolution\n- [ ] Documentation for config file format\n\n## Considerations\n\n- Config might grow to include other settings - design for extensibility\n- Consider meow config command to view/edit config (future task)\n- Handle MEOW_CONFIG_DIR environment variable for testing","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:48:15.307893976-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:07:47.242359455-05:00","closed_at":"2026-01-09T17:07:47.242359455-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-354.10","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:48:15.30914512-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.2","title":"Implement Adapter Loader","description":"## Background\n\nOnce adapter types are defined, we need a loader to find and parse adapters from the filesystem. The loader needs to support the resolution order specified in the spec.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Adapter Resolution Order\n\n1. Step-level: `adapter` field in spawn step\n2. Workflow-level: `default_adapter` in template variables\n3. Project-level: `.meow/config.toml` `[agents] default_adapter`\n4. Global-level: `~/.meow/config.toml` `[agents] default_adapter`\n5. Built-in default: `claude`\n\nAdapter locations:\n- `~/.meow/adapters/\u003cname\u003e/adapter.toml` (global)\n- `.meow/adapters/\u003cname\u003e/adapter.toml` (project-local, optional)\n\n## Implementation Details\n\nKey files to create/modify:\n- `internal/adapter/loader.go` (new) - Adapter loading and registry\n\nComponents to implement:\n\n```go\ntype AdapterRegistry struct {\n    globalDir  string // ~/.meow/adapters/\n    projectDir string // .meow/adapters/\n    cache      map[string]*types.AdapterConfig\n}\n\nfunc NewAdapterRegistry(globalDir, projectDir string) *AdapterRegistry\n\n// Load adapter by name, checking project then global\nfunc (r *AdapterRegistry) Load(name string) (*types.AdapterConfig, error)\n\n// Resolve adapter name from step/workflow/config hierarchy\nfunc (r *AdapterRegistry) Resolve(stepAdapter, workflowDefault, projectDefault, globalDefault string) string\n\n// List available adapters\nfunc (r *AdapterRegistry) List() ([]string, error)\n\n// Get adapter path (for event translator resolution)\nfunc (r *AdapterRegistry) GetPath(name string) (string, error)\n```\n\nFile operations:\n- Check if directory exists\n- Read and parse adapter.toml\n- Handle missing optional files (setup.sh, event-translator.sh)\n\n## Acceptance Criteria\n\n- [ ] AdapterRegistry struct implemented\n- [ ] Load() finds adapter in project-local or global directory\n- [ ] Resolve() implements resolution order from spec\n- [ ] List() returns available adapter names\n- [ ] GetPath() returns adapter directory for script resolution\n- [ ] Caching prevents repeated disk reads\n- [ ] Error handling for missing/invalid adapters\n- [ ] Unit tests with mock filesystem\n\n## Considerations\n\n- Project-local adapters override global ones with same name\n- Cache invalidation: for MVP, just cache for lifetime of registry\n- Handle ~/ expansion for home directory\n- Return clear errors distinguishing \"not found\" from \"parse error\"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:46:25.58010421-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:08:37.040649795-05:00","closed_at":"2026-01-09T17:08:37.040649795-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-354.2","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:46:25.581081547-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.2","depends_on_id":"meow-354.1","type":"blocks","created_at":"2026-01-09T02:48:24.493781722-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.3","title":"Create Built-in Claude Adapter","description":"## Background\n\nThe claude adapter is the built-in default. It encapsulates all the Claude Code-specific behavior currently hardcoded in TmuxAgentManager. This adapter must be embedded in the binary so it's always available.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Agent Adapters\n\nExample claude adapter.toml from spec:\n```toml\n[adapter]\nname = \"claude\"\ndescription = \"Claude Code CLI agent\"\n\n[spawn]\ncommand = \"claude --dangerously-skip-permissions\"\nresume_command = \"claude --dangerously-skip-permissions --resume {{session_id}}\"\nstartup_delay = \"3s\"\n\n[environment]\nTMUX = \"\"\n\n[prompt_injection]\npre_keys = [\"Escape\"]\npre_delay = \"100ms\"\nmethod = \"literal\"\npost_keys = [\"Enter\"]\n\n[graceful_stop]\nkeys = [\"C-c\"]\nwait = \"2s\"\n\n[events]\ntranslator = \"./event-translator.sh\"\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- `internal/adapter/builtin/` (new directory)\n- `internal/adapter/builtin/claude.go` - Embedded claude adapter\n- `internal/adapter/builtin/claude_adapter.toml` - Config file\n- `internal/adapter/builtin/event_translator.sh` - Event translator script\n\nUse Go embed:\n```go\n//go:embed claude_adapter.toml\nvar claudeAdapterTOML []byte\n\n//go:embed event_translator.sh\nvar claudeEventTranslator []byte\n```\n\nAlso need to modify AdapterRegistry to check built-in adapters before returning \"not found\".\n\nThe event-translator.sh for Claude translates Stop hooks:\n```bash\n#!/bin/bash\nHOOK_TYPE=\"$1\"\nshift\n\ncase \"$HOOK_TYPE\" in\n  Stop)\n    meow event agent-stopped\n    ;;\n  PreToolUse)\n    meow event tool-starting --data tool=\"$1\"\n    ;;\n  PostToolUse)\n    meow event tool-completed --data tool=\"$1\"\n    ;;\n  *)\n    meow event unknown --data type=\"$HOOK_TYPE\"\n    ;;\nesac\n```\n\n## Acceptance Criteria\n\n- [ ] claude adapter.toml embedded in binary\n- [ ] event-translator.sh embedded in binary\n- [ ] AdapterRegistry.Load(\"claude\") returns built-in if not overridden\n- [ ] Built-in scripts can be extracted to temp dir when needed\n- [ ] Values match current hardcoded behavior in TmuxAgentManager\n- [ ] Unit test verifying built-in adapter loads correctly\n\n## Considerations\n\n- Embedded scripts need to be extracted to temp file for execution\n- Consider creating temp dir at ~/.meow/cache/adapters/claude/ for extracted scripts\n- The event translator depends on \"meow event\" command (created later in Events epic)\n- Until events are implemented, the translator can be a no-op\n- Ensure startup_delay matches current 3-second wait in agent_manager.go","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:46:57.387697886-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:08:37.043233954-05:00","closed_at":"2026-01-09T17:08:37.043233954-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-354.3","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:46:57.388714805-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.3","depends_on_id":"meow-354.1","type":"blocks","created_at":"2026-01-09T02:48:25.604013419-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.4","title":"Refactor TmuxAgentManager to Use Adapters","description":"## Background\n\nThe TmuxAgentManager currently has Claude Code hardcoded. This task refactors it to delegate agent-specific behavior to adapters loaded via the AdapterRegistry.\n\nThis is the core integration point - where adapters actually get used.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Using Adapters in Workflows\n\nSpawnConfig gains adapter field:\n```yaml\nid: \"spawn\"\nexecutor: \"spawn\"\nagent: \"worker\"\nadapter: \"claude\"\nworkdir: \"{{worktree}}\"\n```\n\nAdapter determines:\n- What command to run in tmux\n- Environment variables to set\n- How to inject prompts (pre_keys, method, post_keys)\n- How to gracefully stop\n\n## Implementation Details\n\nKey files to modify:\n- `internal/orchestrator/agent_manager.go` - Major refactor\n- `internal/types/workflow.go` - Add Adapter field to SpawnConfig\n\nCurrent hardcoded Claude behavior to extract:\n1. Start command: `claude --dangerously-skip-permissions`\n2. Resume command: `claude --dangerously-skip-permissions --resume {session}`\n3. Environment: `TMUX=\"\"`\n4. Prompt injection: Escape -\u003e 100ms delay -\u003e text -\u003e Enter\n5. Graceful stop: C-c -\u003e 2s wait\n6. Startup delay: 3 seconds\n\nRefactored TmuxAgentManager:\n```go\ntype TmuxAgentManager struct {\n    logger   *slog.Logger\n    adapters *adapter.AdapterRegistry\n    mu       sync.RWMutex\n    agents   map[string]*agentState\n    workdir  string\n}\n\nfunc (m *TmuxAgentManager) Start(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    cfg := step.Spawn\n    \n    // Resolve adapter\n    adapterName := m.adapters.Resolve(\n        cfg.Adapter,           // step-level\n        wf.DefaultAdapter,     // workflow-level\n        \"\", \"\",                // project/global from config\n    )\n    \n    adapter, err := m.adapters.Load(adapterName)\n    if err != nil {\n        return fmt.Errorf(\"loading adapter %s: %w\", adapterName, err)\n    }\n    \n    // Use adapter config for everything\n    env := mergeEnv(cfg.Env, adapter.Environment)\n    startCmd := adapter.Spawn.Command\n    if cfg.ResumeSession != \"\" {\n        startCmd = expandTemplate(adapter.Spawn.ResumeCommand, ...)\n    }\n    \n    // ... rest uses adapter.PromptInject, adapter.GracefulStop, etc.\n}\n```\n\n## Acceptance Criteria\n\n- [ ] TmuxAgentManager constructor takes AdapterRegistry\n- [ ] Start() resolves and loads adapter\n- [ ] Start() uses adapter.Spawn.Command (not hardcoded claude)\n- [ ] Start() applies adapter.Environment\n- [ ] Start() waits adapter.Spawn.StartupDelay\n- [ ] InjectPrompt() uses adapter.PromptInject settings\n- [ ] Stop() uses adapter.GracefulStop settings\n- [ ] SpawnConfig in types/workflow.go has Adapter field\n- [ ] Existing tests pass (behavior unchanged with claude adapter)\n- [ ] New test: custom adapter changes spawn behavior\n\n## Considerations\n\n- Backwards compatibility: existing workflows without adapter field should use default (claude)\n- The adapter.Spawn.ResumeCommand needs template expansion for {{session_id}}\n- PromptInject.Method: \"literal\" means send-keys with text, \"keys\" means send-keys with key names\n- Some adapters may not have event translators - that's okay\n- Error messages should indicate which adapter failed","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T02:46:59.2697905-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:46:59.2697905-05:00","dependencies":[{"issue_id":"meow-354.4","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:46:59.27099711-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.4","depends_on_id":"meow-354.2","type":"blocks","created_at":"2026-01-09T02:48:26.689522344-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.4","depends_on_id":"meow-354.3","type":"blocks","created_at":"2026-01-09T02:48:27.638471542-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.4","depends_on_id":"meow-354.5","type":"blocks","created_at":"2026-01-09T02:48:28.474918036-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.4","depends_on_id":"meow-354.10","type":"blocks","created_at":"2026-01-09T02:48:38.625018496-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.5","title":"Add Adapter Field to SpawnConfig","description":"## Background\n\nThe SpawnConfig type in types/workflow.go needs an Adapter field so spawn steps can specify which agent adapter to use. This is a small but important change that enables the adapter system.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 3: spawn Executor\n\n```yaml\nid: \"start-worker\"\nexecutor: \"spawn\"\nagent: \"worker-1\"\nadapter: \"claude\"                                    # NEW FIELD\nworkdir: \"{{create-worktree.outputs.worktree_path}}\"\n```\n\n## Implementation Details\n\nKey files to modify:\n- `internal/types/workflow.go` - Add Adapter field to SpawnConfig\n\nCurrent SpawnConfig (inferred from agent_manager.go):\n```go\ntype SpawnConfig struct {\n    Agent         string            `yaml:\"agent\"`\n    Workdir       string            `yaml:\"workdir\"`\n    Env           map[string]string `yaml:\"env\"`\n    ResumeSession string            `yaml:\"resume_session\"`\n}\n```\n\nNew SpawnConfig:\n```go\ntype SpawnConfig struct {\n    Agent         string            `yaml:\"agent\"`\n    Adapter       string            `yaml:\"adapter,omitempty\"`  // NEW\n    Workdir       string            `yaml:\"workdir\"`\n    Env           map[string]string `yaml:\"env\"`\n    ResumeSession string            `yaml:\"resume_session\"`\n}\n```\n\nAlso add to Workflow type:\n```go\ntype Workflow struct {\n    // ... existing fields\n    DefaultAdapter string `yaml:\"default_adapter,omitempty\"` // Workflow-level default\n}\n```\n\n## Acceptance Criteria\n\n- [ ] SpawnConfig has Adapter field with yaml tag\n- [ ] Workflow has DefaultAdapter field\n- [ ] YAML parsing works for new fields\n- [ ] Omitempty ensures field not written if empty\n- [ ] Update any existing tests that construct SpawnConfig\n\n## Considerations\n\n- This is a small change but should be done first/alongside adapter types\n- Empty string means \"use default from config hierarchy\"\n- Consider adding to TOML template parser if not already there","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:47:23.587066559-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:07:47.23971604-05:00","closed_at":"2026-01-09T17:07:47.23971604-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-354.5","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:47:23.587995179-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.6","title":"Implement meow adapter install Command","description":"## Background\n\nUsers need a way to install adapters from git repositories or local directories. This command handles downloading, validating, and placing adapters in ~/.meow/adapters/.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 14: CLI Commands - Adapter Commands\n\n```bash\n# Install from git repository\nmeow adapter install https://github.com/user/meow-adapter-aider\n\n# Install from local directory\nmeow adapter install ./my-adapter\n\n# Install with custom name\nmeow adapter install https://github.com/user/meow-adapter-aider --name aider\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- `cmd/meow/cmd/adapter.go` (new) - Adapter subcommand\n- `cmd/meow/cmd/adapter_install.go` (new) - Install subcommand\n\nInstallation logic:\n1. Determine source type (git URL vs local path)\n2. For git: clone to temp directory\n3. Validate adapter.toml exists and parses correctly\n4. Determine adapter name (from --name flag, or adapter.toml name, or repo name)\n5. Copy to ~/.meow/adapters/\u003cname\u003e/\n6. Make scripts executable (setup.sh, event-translator.sh)\n\n```go\nfunc runAdapterInstall(cmd *cobra.Command, args []string) error {\n    source := args[0]\n    name := nameFlag\n    \n    var adapterDir string\n    if isGitURL(source) {\n        tempDir, err := cloneRepo(source)\n        if err != nil {\n            return err\n        }\n        defer os.RemoveAll(tempDir)\n        adapterDir = tempDir\n    } else {\n        adapterDir = source\n    }\n    \n    // Validate\n    cfg, err := adapter.LoadFromDir(adapterDir)\n    if err != nil {\n        return fmt.Errorf(\"invalid adapter: %w\", err)\n    }\n    \n    if name == \"\" {\n        name = cfg.Adapter.Name\n    }\n    \n    // Install\n    destDir := filepath.Join(os.Getenv(\"HOME\"), \".meow\", \"adapters\", name)\n    if err := copyDir(adapterDir, destDir); err != nil {\n        return err\n    }\n    \n    // Make scripts executable\n    makeExecutable(filepath.Join(destDir, \"setup.sh\"))\n    makeExecutable(filepath.Join(destDir, \"event-translator.sh\"))\n    \n    fmt.Printf(\"Installed adapter '%s' to %s\\n\", name, destDir)\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] meow adapter install \u003cgit-url\u003e clones and installs\n- [ ] meow adapter install \u003clocal-path\u003e copies and installs\n- [ ] --name flag overrides adapter name\n- [ ] Invalid adapter.toml fails with clear error\n- [ ] Existing adapter prompts for overwrite (or --force)\n- [ ] Scripts made executable after install\n- [ ] Success message shows installed path\n- [ ] Unit test for local install\n- [ ] Integration test for git install (can skip in CI)\n\n## Considerations\n\n- Git clone requires git to be installed - document this requirement\n- Consider shallow clone (--depth 1) to save bandwidth\n- Handle adapters that are subdirectories of repos (--subdir flag?)\n- Overwrite protection: fail if exists unless --force\n- Permission handling: ensure ~/.meow/adapters/ exists","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T02:47:24.835686689-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:47:24.835686689-05:00","dependencies":[{"issue_id":"meow-354.6","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:47:24.836682889-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.6","depends_on_id":"meow-354.2","type":"blocks","created_at":"2026-01-09T02:48:29.396738475-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.7","title":"Implement meow adapter list/show Commands","description":"## Background\n\nUsers need to see what adapters are available and inspect their configuration. These are simple read-only commands that help with debugging and discovery.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 14: CLI Commands - Adapter Commands\n\n```bash\n# List available adapters\nmeow adapter list\n\n# Show adapter details\nmeow adapter show claude\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- `cmd/meow/cmd/adapter_list.go` (new)\n- `cmd/meow/cmd/adapter_show.go` (new)\n\nList command output:\n```\nNAME      DESCRIPTION                    LOCATION\nclaude    Claude Code CLI agent          (built-in)\naider     Aider AI pair programmer       ~/.meow/adapters/aider\ncustom    My custom agent                .meow/adapters/custom\n```\n\nShow command output:\n```\nAdapter: claude\nDescription: Claude Code CLI agent\nLocation: (built-in)\n\nSpawn:\n  Command: claude --dangerously-skip-permissions\n  Resume: claude --dangerously-skip-permissions --resume {{session_id}}\n  Startup Delay: 3s\n\nEnvironment:\n  TMUX: \"\"\n\nPrompt Injection:\n  Pre-keys: Escape\n  Pre-delay: 100ms\n  Method: literal\n  Post-keys: Enter\n\nGraceful Stop:\n  Keys: C-c\n  Wait: 2s\n\nEvents:\n  Translator: ./event-translator.sh\n```\n\n## Acceptance Criteria\n\n- [ ] meow adapter list shows all available adapters\n- [ ] List distinguishes built-in vs user-installed vs project-local\n- [ ] meow adapter show \u003cname\u003e displays full configuration\n- [ ] Show command handles missing adapter gracefully\n- [ ] --json flag for machine-readable output\n- [ ] Table formatting looks good in terminal\n\n## Considerations\n\n- List should merge built-in, global (~/.meow/adapters/), and project (.meow/adapters/)\n- If same name exists in multiple locations, show the one that would be used (project \u003e global \u003e built-in)\n- Show command should indicate if adapter is overriding another\n- Consider color coding: built-in (default), user (green), project (blue)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T02:47:47.668749436-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:47:47.668749436-05:00","dependencies":[{"issue_id":"meow-354.7","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:47:47.670641047-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.7","depends_on_id":"meow-354.2","type":"blocks","created_at":"2026-01-09T02:48:35.536457673-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.8","title":"Implement meow adapter setup Command","description":"## Background\n\nSome adapters need one-time setup per worktree/project (e.g., Claude needs hooks configured in .claude/settings.json). The setup command runs the adapter's setup.sh script if it exists.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Setup Script\n\n```bash\n# Run adapter's setup script for a worktree\nmeow adapter setup claude /path/to/worktree\n```\n\nExample setup.sh creates .claude/settings.json with hook configuration.\n\n## Implementation Details\n\nKey files to create/modify:\n- cmd/meow/cmd/adapter_setup.go (new)\n\nLogic:\n1. Get adapter path from registry\n2. Check if setup.sh exists\n3. For built-in adapters, extract to temp directory first\n4. Run setup.sh with worktree path as argument\n5. Show script output\n\n## Acceptance Criteria\n\n- [ ] meow adapter setup \u003cadapter\u003e [worktree] runs setup.sh\n- [ ] Works for user-installed adapters\n- [ ] Works for built-in adapters (extracts to temp)\n- [ ] Passes worktree path to script\n- [ ] Handles missing setup.sh gracefully (just prints message)\n- [ ] Shows script output\n- [ ] Exit code reflects script success/failure\n\n## Considerations\n\n- Built-in adapters need their scripts extracted to run\n- Setup might be run multiple times - scripts should be idempotent\n- Consider --dry-run flag to show what would be done\n- The ADAPTER_DIR variable in script should point to actual adapter location\n- For built-in, the extracted temp dir should include all adapter files","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T02:47:56.218802876-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:47:56.218802876-05:00","dependencies":[{"issue_id":"meow-354.8","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:47:56.220130953-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.8","depends_on_id":"meow-354.2","type":"blocks","created_at":"2026-01-09T02:48:36.438403646-05:00","created_by":"ubuntu"}]}
{"id":"meow-354.9","title":"Implement meow adapter remove Command","description":"## Background\n\nUsers need a way to remove installed adapters. This command removes an adapter from ~/.meow/adapters/ or .meow/adapters/.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 14: CLI Commands - Adapter Commands\n\n```bash\n# Remove an adapter\nmeow adapter remove aider\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- cmd/meow/cmd/adapter_remove.go (new)\n\nLogic:\n1. Find adapter location (project-local or global)\n2. Confirm removal (unless --force)\n3. Remove directory\n4. Print success message\n\nCannot remove built-in adapters (error message explains this).\n\n## Acceptance Criteria\n\n- [ ] meow adapter remove \u003cname\u003e removes adapter directory\n- [ ] Prompts for confirmation unless --force\n- [ ] Cannot remove built-in adapters (clear error)\n- [ ] Handles non-existent adapter gracefully\n- [ ] Works for both project-local and global adapters\n- [ ] --project flag to specifically remove project-local version\n\n## Considerations\n\n- If adapter exists in both project and global, which to remove? Default to project-local, use --global flag for global\n- Should warn if adapter is currently in use by running workflows\n- Consider --dry-run to show what would be removed","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T02:48:13.917998917-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:48:13.917998917-05:00","dependencies":[{"issue_id":"meow-354.9","depends_on_id":"meow-354","type":"parent-child","created_at":"2026-01-09T02:48:13.918940148-05:00","created_by":"ubuntu"},{"issue_id":"meow-354.9","depends_on_id":"meow-354.2","type":"blocks","created_at":"2026-01-09T02:48:37.482741485-05:00","created_by":"ubuntu"}]}
{"id":"meow-3xa","title":"Add foreach to template parser","description":"Update the TOML template parser to support foreach steps.\n\nIn internal/template/parser.go:\n- Parse foreach executor type\n- Parse all foreach-specific fields (items, item_var, index_var, etc.)\n- Validate required fields (items, item_var, template)\n- Set defaults (parallel=true, join=true)\n- Add to step parsing logic","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:40.317185807-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:40.317185807-05:00","dependencies":[{"issue_id":"meow-3xa","depends_on_id":"meow-5ex","type":"blocks","created_at":"2026-01-09T15:04:15.691436532-05:00","created_by":"ubuntu"}]}
{"id":"meow-401","title":"Refactor orchestrator for WorkflowStore","description":"# Refactor Orchestrator for WorkflowStore\n\n## File: internal/orchestrator/orchestrator.go\n\n## Changes\n\n### Constructor\n\n```go\n// Before\nfunc New(cfg *config.Config, store BeadStore, agents AgentManager, ...) *Orchestrator\n\n// After\nfunc New(cfg *config.Config, store WorkflowStore, agents AgentManager, ...) *Orchestrator\n```\n\n### Main Loop\n\nThe orchestrator processes ALL ready steps in each tick, enabling parallel agent execution.\n\n```go\nfunc (o *Orchestrator) Run(ctx context.Context) error {\n    ticker := time.NewTicker(o.cfg.PollInterval)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case \u003c-ctx.Done():\n            return ctx.Err()\n        case msg := \u003c-o.ipcChan:\n            o.handleIPC(ctx, msg) // Handle meow done, meow prime requests\n        case \u003c-ticker.C:\n            if err := o.tick(ctx); err != nil {\n                if err == errAllDone {\n                    return nil\n                }\n                o.logger.Error(\"tick error\", \"error\", err)\n            }\n        }\n    }\n}\n\nfunc (o *Orchestrator) tick(ctx context.Context) error {\n    workflows, _ := o.store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n\n    allComplete := true\n    for _, wf := range workflows {\n        if err := o.processWorkflow(ctx, wf); err != nil {\n            return err\n        }\n        if wf.Status == types.WorkflowStatusRunning {\n            allComplete = false\n        }\n    }\n\n    if allComplete \u0026\u0026 len(workflows) \u003e 0 {\n        return errAllDone\n    }\n    return nil\n}\n\nfunc (o *Orchestrator) processWorkflow(ctx context.Context, wf *types.Workflow) error {\n    // Check timeouts for running agent steps\n    o.checkStepTimeouts(ctx, wf)\n    \n    readySteps := wf.GetReadySteps()\n    if len(readySteps) == 0 {\n        if wf.AllDone() {\n            wf.Complete()\n            return o.store.Save(ctx, wf)\n        }\n        return nil // Waiting for external completion\n    }\n\n    // Sort by priority: orchestrator executors first, then by creation time\n    sort.Slice(readySteps, func(i, j int) bool {\n        if readySteps[i].Executor.IsOrchestrator() != readySteps[j].Executor.IsOrchestrator() {\n            return readySteps[i].Executor.IsOrchestrator()\n        }\n        return readySteps[i].ID \u003c readySteps[j].ID\n    })\n\n    // Process ALL ready steps (enables parallel agent execution)\n    for _, step := range readySteps {\n        // For agent steps, only inject if agent is idle\n        if step.Executor == types.ExecutorAgent {\n            if !o.agentIsIdle(wf, step.Agent.Agent) {\n                continue\n            }\n        }\n        if err := o.dispatch(ctx, wf, step); err != nil {\n            o.logger.Error(\"dispatch error\", \"step\", step.ID, \"error\", err)\n        }\n    }\n\n    return o.store.Save(ctx, wf)\n}\n```\n\n### Dispatch (6 Executors Only)\n\n```go\nfunc (o *Orchestrator) dispatch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    o.logger.Info(\"dispatching step\", \"id\", step.ID, \"executor\", step.Executor)\n\n    switch step.Executor {\n    case types.ExecutorShell:\n        return o.handleShell(ctx, wf, step)\n    case types.ExecutorSpawn:\n        return o.handleSpawn(ctx, wf, step)\n    case types.ExecutorKill:\n        return o.handleKill(ctx, wf, step)\n    case types.ExecutorExpand:\n        return o.handleExpand(ctx, wf, step)\n    case types.ExecutorBranch:\n        return o.handleBranch(ctx, wf, step)\n    case types.ExecutorAgent:\n        return o.handleAgent(ctx, wf, step)\n    default:\n        return fmt.Errorf(\"unknown executor: %s\", step.Executor)\n    }\n}\n\n// agentIsIdle returns true if no step assigned to this agent is running/completing\nfunc (o *Orchestrator) agentIsIdle(wf *types.Workflow, agentID string) bool {\n    for _, step := range wf.Steps {\n        if step.Agent != nil \u0026\u0026 step.Agent.Agent == agentID {\n            if step.Status == types.StepStatusRunning || step.Status == types.StepStatusCompleting {\n                return false\n            }\n        }\n    }\n    return true\n}\n```\n\n## Key Points\n\n- **6 executors only** - NO gate case (gate is branch + await-approval pattern)\n- **Process ALL ready steps** - enables parallel agent execution\n- **Agent idle check** - don't inject prompt to busy agent\n- **IPC integration** - handle meow done messages\n- **Timeout checking** - monitor running agent steps\n\n## Acceptance Criteria\n\n- [ ] Constructor takes WorkflowStore (not BeadStore)\n- [ ] Main loop with IPC message handling\n- [ ] dispatch() with exactly 6 cases (NO gate)\n- [ ] agentIsIdle() helper for parallel dispatch\n- [ ] Process ALL ready steps per tick\n- [ ] Orchestrator executors before agent executors\n- [ ] Save workflow after processing\n- [ ] Unit tests with WorkflowStore\n","notes":"**UPDATED for v2 spec**:\n1. Only 6 executors (no gate - it's a branch pattern)\n2. Must process ALL ready steps in each tick (parallel execution)\n3. Must handle IPC messages from agents (meow done)\n4. Must check step timeouts for running agent steps\n5. Must send ESC + inject prompts to agents directly","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:31Z","created_by":"claude","updated_at":"2026-01-08T23:51:21.052303601-05:00","closed_at":"2026-01-08T23:51:21.052303601-05:00","close_reason":"Refactored orchestrator to use WorkflowStore instead of BeadStore. All 6 executor dispatch cases implemented with stubs. Tests pass with manually-created Workflow/Step objects.","dependencies":[{"issue_id":"meow-401","depends_on_id":"meow-202","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"},{"issue_id":"meow-401","depends_on_id":"meow-303","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"}]}
{"id":"meow-402","title":"Implement shell executor handler","description":"# Implement Shell Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleShell(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Shell == nil {\n        return fmt.Errorf(\"shell step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Execute command\n    outputs, err := o.executor.Execute(ctx, step.Shell)\n    if err != nil {\n        if step.Shell.OnError == \"continue\" {\n            o.logger.Warn(\"shell failed, continuing\", \"step\", step.ID, \"error\", err)\n            step.Complete(outputs)\n            return nil\n        }\n        step.Fail(\u0026types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(outputs)\n    return nil\n}\n```\n\n## Shell Executor Interface\n\n```go\ntype ShellExecutor interface {\n    Execute(ctx context.Context, cfg *types.ShellConfig) (map[string]any, error)\n}\n```\n\nThis should already exist from the old CodeExecutor - just needs interface rename.\n\n## Output Capture\n\nOutputs captured based on outputs config in template:\n- `stdout` - trimmed stdout\n- `stderr` - trimmed stderr\n- `exit_code` - integer exit code\n- `file:/path` - file contents\n\n## Acceptance Criteria\n\n- [ ] handleShell implementation\n- [ ] Uses ShellConfig from step\n- [ ] Respects on_error setting\n- [ ] Captures outputs correctly\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:32Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.97127465-05:00","closed_at":"2026-01-08T23:55:57.97127465-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"meow-402","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T12:00:32Z","created_by":"claude"}]}
{"id":"meow-403","title":"Implement spawn executor handler","description":"# Implement Spawn Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleSpawn(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Spawn == nil {\n        return fmt.Errorf(\"spawn step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Build agent start config\n    cfg := \u0026agent.StartConfig{\n        AgentID:       step.Spawn.Agent,\n        Workdir:       step.Spawn.Workdir,\n        Env:           step.Spawn.Env,\n        Prompt:        step.Spawn.Prompt,\n        ResumeSession: step.Spawn.ResumeSession,\n    }\n\n    // Set default prompt\n    if cfg.Prompt == \"\" {\n        cfg.Prompt = \"meow prime\"\n    }\n\n    // Always set MEOW_AGENT env var\n    if cfg.Env == nil {\n        cfg.Env = make(map[string]string)\n    }\n    cfg.Env[\"MEOW_AGENT\"] = step.Spawn.Agent\n    cfg.Env[\"MEOW_WORKFLOW\"] = wf.ID\n\n    // Start agent\n    if err := o.agents.Start(ctx, cfg); err != nil {\n        step.Fail(\u0026types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Agent Manager Interface\n\n```go\ntype AgentManager interface {\n    Start(ctx context.Context, cfg *agent.StartConfig) error\n    Stop(ctx context.Context, cfg *agent.StopConfig) error\n    IsRunning(ctx context.Context, agentID string) (bool, error)\n}\n```\n\n## Key Behaviors\n\n1. Sets MEOW_AGENT and MEOW_WORKFLOW env vars\n2. Default prompt is \"meow prime\"\n3. Creates tmux session meow-{agent}\n4. Auto-completes when agent starts\n\n## Acceptance Criteria\n\n- [ ] handleSpawn implementation\n- [ ] Sets MEOW_AGENT env var\n- [ ] Sets MEOW_WORKFLOW env var\n- [ ] Default prompt handling\n- [ ] Resume session support\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:33Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.973322479-05:00","closed_at":"2026-01-08T23:55:57.973322479-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"meow-403","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T12:00:33Z","created_by":"claude"}]}
{"id":"meow-404","title":"Implement kill executor handler","description":"# Implement Kill Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleKill(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Kill == nil {\n        return fmt.Errorf(\"kill step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    cfg := \u0026agent.StopConfig{\n        AgentID:  step.Kill.Agent,\n        Graceful: step.Kill.Graceful,\n        Timeout:  step.Kill.Timeout,\n    }\n\n    // Defaults\n    if cfg.Timeout == 0 {\n        cfg.Timeout = 10\n    }\n\n    if err := o.agents.Stop(ctx, cfg); err != nil {\n        // Log but don't fail - agent might already be dead\n        o.logger.Warn(\"kill step error\", \"step\", step.ID, \"error\", err)\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Graceful shutdown by default (SIGTERM, wait, SIGKILL)\n2. Default timeout 10 seconds\n3. Doesn't fail if agent already dead\n\n## Acceptance Criteria\n\n- [ ] handleKill implementation\n- [ ] Graceful shutdown support\n- [ ] Default timeout handling\n- [ ] Handles already-dead agents\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:34Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.975141081-05:00","closed_at":"2026-01-08T23:55:57.975141081-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"meow-404","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T12:00:34Z","created_by":"claude"}]}
{"id":"meow-405","title":"Implement expand executor handler","description":"# Implement Expand Executor Handler\n\n## File: internal/orchestrator/executors/expand.go\n\n## Purpose\n\nExpand a template's steps into the current workflow. Handles:\n- Template resolution (same file, external file)\n- Variable substitution\n- Step ID prefixing for uniqueness\n- Tracking ExpandedFrom/ExpandedInto for crash recovery\n- Resource limit checking (depth and total steps)\n\n## Implementation\n\n\\`\\`\\`go\npackage executors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \n    \"github.com/meow-stack/meow-machine/internal/config\"\n    \"github.com/meow-stack/meow-machine/internal/template\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\ntype ExpandExecutor struct {\n    loader *template.Loader\n    limits *config.Limits\n}\n\nfunc NewExpandExecutor(loader *template.Loader, limits *config.Limits) *ExpandExecutor {\n    return \u0026ExpandExecutor{loader: loader, limits: limits}\n}\n\n// ExpansionContext tracks depth for resource limit checking.\ntype ExpansionContext struct {\n    Depth    int\n    MaxDepth int\n}\n\nfunc (e *ExpandExecutor) Execute(\n    ctx context.Context,\n    step *types.Step,\n    wf *types.Workflow,\n    subCtx *template.SubstitutionContext,\n    expCtx *ExpansionContext,\n) error {\n    // Check expansion depth limit\n    if expCtx.Depth \u003e= expCtx.MaxDepth {\n        return \u0026LimitExceededError{\n            Limit: \"max_expansion_depth\",\n            Value: expCtx.Depth,\n            Max:   expCtx.MaxDepth,\n        }\n    }\n    \n    cfg := step.Expand\n    \n    // Resolve template reference\n    tmpl, err := e.loader.Load(cfg.Template)\n    if err != nil {\n        return fmt.Errorf(\"loading template %s: %w\", cfg.Template, err)\n    }\n    \n    // Create substitution context with step's variables\n    childCtx := subCtx.WithVariables(cfg.Variables)\n    \n    // Expand template steps\n    expandedIDs := make([]string, 0)\n    for _, tmplStep := range tmpl.Steps {\n        // Prefix step ID with parent step ID for uniqueness\n        newID := step.ID + \".\" + tmplStep.ID\n        \n        // Clone and substitute\n        newStep, err := e.expandStep(tmplStep, newID, step.ID, childCtx)\n        if err != nil {\n            return fmt.Errorf(\"expanding step %s: %w\", tmplStep.ID, err)\n        }\n        \n        // Update dependencies to use prefixed IDs\n        newStep.Needs = e.prefixNeeds(tmplStep.Needs, step.ID, tmpl.Steps)\n        \n        // Track expansion relationship\n        newStep.ExpandedFrom = step.ID\n        \n        // Add to workflow\n        if err := wf.AddStep(newStep); err != nil {\n            return err\n        }\n        \n        expandedIDs = append(expandedIDs, newID)\n    }\n    \n    // Track what this step expanded into\n    step.ExpandedInto = expandedIDs\n    \n    // Check total steps limit\n    if len(wf.Steps) \u003e e.limits.MaxTotalSteps {\n        // Rollback: delete the steps we just added\n        for _, id := range expandedIDs {\n            delete(wf.Steps, id)\n        }\n        step.ExpandedInto = nil\n        \n        return \u0026LimitExceededError{\n            Limit: \"max_total_steps\",\n            Value: len(wf.Steps),\n            Max:   e.limits.MaxTotalSteps,\n        }\n    }\n    \n    // Success - mark step done\n    step.Status = types.StepStatusDone\n    \n    return nil\n}\n\nfunc (e *ExpandExecutor) expandStep(\n    tmpl *types.Step,\n    newID string,\n    parentID string,\n    ctx *template.SubstitutionContext,\n) (*types.Step, error) {\n    // Clone the step\n    newStep := \u0026types.Step{\n        ID:       newID,\n        Executor: tmpl.Executor,\n        Status:   types.StepStatusPending,\n    }\n    \n    // Substitute variables in config based on executor type\n    // ... (executor-specific substitution)\n    \n    return newStep, nil\n}\n\nfunc (e *ExpandExecutor) prefixNeeds(needs []string, parentID string, tmplSteps []*types.Step) []string {\n    // Build set of step IDs in template\n    tmplIDs := make(map[string]bool)\n    for _, s := range tmplSteps {\n        tmplIDs[s.ID] = true\n    }\n    \n    result := make([]string, len(needs))\n    for i, need := range needs {\n        if tmplIDs[need] {\n            // Internal dependency - prefix\n            result[i] = parentID + \".\" + need\n        } else {\n            // External dependency - keep as-is\n            result[i] = need\n        }\n    }\n    \n    // Add dependency on parent expand step\n    result = append(result, parentID)\n    \n    return result\n}\n\\`\\`\\`\n\n## Template Resolution\n\n| Reference | Resolution |\n|-----------|------------|\n| \\`.tdd\\` | Same file, workflow named \\`tdd\\` |\n| \\`main\\` | Same file, workflow named \\`main\\` |\n| \\`helpers#tdd\\` | File \\`helpers.meow.toml\\`, workflow \\`tdd\\` |\n| \\`helpers\\` | File \\`helpers.meow.toml\\`, workflow \\`main\\` |\n| \\`./lib/utils#helper\\` | Relative path |\n\n## Step ID Prefixing\n\nExpanded steps get prefixed IDs for uniqueness:\n- Parent step: \\`implement\\`\n- Template steps: \\`load\\`, \\`test\\`, \\`code\\`\n- Expanded IDs: \\`implement.load\\`, \\`implement.test\\`, \\`implement.code\\`\n\nRecursive expansion continues prefixing:\n- \\`implement.continue.find-work\\`\n- \\`implement.continue.continue.find-work\\`\n\n## Acceptance Criteria\n\n- [ ] Template loading via Loader\n- [ ] Variable substitution in expanded steps\n- [ ] Step ID prefixing for uniqueness\n- [ ] Dependency prefixing for internal refs\n- [ ] ExpandedFrom set on child steps\n- [ ] ExpandedInto set on parent step\n- [ ] Expansion depth limit checking\n- [ ] Total steps limit checking with rollback\n- [ ] Unit tests for template resolution\n- [ ] Unit tests for step prefixing\n- [ ] Unit tests for limit enforcement\n- [ ] Integration test with nested expansions","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:35Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.9769778-05:00","closed_at":"2026-01-08T23:55:57.9769778-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"meow-405","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T12:00:35Z","created_by":"claude"},{"issue_id":"meow-405","depends_on_id":"meow-303","type":"blocks","created_at":"2026-01-08T22:21:45.600436695-05:00","created_by":"ubuntu"}]}
{"id":"meow-406","title":"Implement branch executor handler","description":"# Implement Branch Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\nBranch evaluation runs in a goroutine because the condition may block.\n\n```go\nfunc (o *Orchestrator) handleBranch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Branch == nil {\n        return fmt.Errorf(\"branch step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Save initial state\n    o.store.Save(ctx, wf)\n\n    // Run condition in goroutine (may block)\n    go o.evalBranch(ctx, wf.ID, step.ID)\n\n    return nil\n}\n\nfunc (o *Orchestrator) evalBranch(ctx context.Context, workflowID, stepID string) {\n    // Load fresh workflow state\n    wf, err := o.store.Get(ctx, workflowID)\n    if err != nil {\n        o.logger.Error(\"loading workflow for branch\", \"error\", err)\n        return\n    }\n    step := wf.Steps[stepID]\n\n    // Parse timeout\n    var timeout time.Duration\n    if step.Branch.Timeout != \"\" {\n        timeout, _ = time.ParseDuration(step.Branch.Timeout)\n    }\n\n    // Execute condition\n    execCtx := ctx\n    if timeout \u003e 0 {\n        var cancel context.CancelFunc\n        execCtx, cancel = context.WithTimeout(ctx, timeout)\n        defer cancel()\n    }\n\n    shellCfg := \u0026types.ShellConfig{Command: step.Branch.Condition}\n    outputs, err := o.executor.Execute(execCtx, shellCfg)\n\n    // Determine which branch to take\n    var target *types.BranchTarget\n    if execCtx.Err() == context.DeadlineExceeded {\n        target = step.Branch.OnTimeout\n        if target == nil {\n            target = step.Branch.OnFalse\n        }\n    } else if err != nil {\n        target = step.Branch.OnFalse\n    } else {\n        exitCode, _ := outputs[\"exit_code\"].(int)\n        if exitCode == 0 {\n            target = step.Branch.OnTrue\n        } else {\n            target = step.Branch.OnFalse\n        }\n    }\n\n    // Expand target\n    if target != nil {\n        if err := o.expandBranchTarget(ctx, wf, step, target); err != nil {\n            o.logger.Error(\"expanding branch\", \"step\", stepID, \"error\", err)\n        }\n    }\n\n    // Complete step\n    step.Complete(nil)\n    o.store.Save(ctx, wf)\n}\n```\n\n## Key Behaviors\n\n1. Condition runs in goroutine (non-blocking)\n2. Timeout support with fallback to on_false\n3. Exit code 0 = true, anything else = false\n4. Expand either template or inline steps\n\n## Acceptance Criteria\n\n- [ ] handleBranch implementation\n- [ ] Goroutine execution\n- [ ] Timeout handling\n- [ ] True/false/timeout branching\n- [ ] Template expansion\n- [ ] Inline step expansion\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:36Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.978783086-05:00","closed_at":"2026-01-08T23:55:57.978783086-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"meow-406","depends_on_id":"meow-405","type":"blocks","created_at":"2026-01-08T12:00:36Z","created_by":"claude"},{"issue_id":"meow-406","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T22:21:47.176976117-05:00","created_by":"ubuntu"}]}
{"id":"meow-407","title":"Implement agent executor handler","description":"# Implement Agent Executor Handler\n\n## File: internal/orchestrator/executors/agent.go\n\n## Purpose\n\nHandle agent steps: inject prompt, wait for meow done, validate outputs. Key responsibilities:\n- Mark step running and inject prompt via tmux\n- Handle meow done IPC with completing status transition\n- Validate outputs against definitions (including file_path scope)\n- Handle autonomous vs interactive mode for stop hook\n\n## Implementation\n\n\\`\\`\\`go\npackage executors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \n    \"github.com/meow-stack/meow-machine/internal/ipc\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\ntype AgentExecutor struct {\n    agents    *AgentManager\n    validator *OutputValidator\n    tmux      *TmuxManager\n}\n\nfunc NewAgentExecutor(agents *AgentManager, validator *OutputValidator, tmux *TmuxManager) *AgentExecutor {\n    return \u0026AgentExecutor{\n        agents:    agents,\n        validator: validator,\n        tmux:      tmux,\n    }\n}\n\n// Start marks step running and injects prompt.\nfunc (e *AgentExecutor) Start(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    cfg := step.Agent\n    \n    // Mark step running\n    step.Status = types.StepStatusRunning\n    \n    // Update agent's current step\n    e.agents.SetCurrentStep(cfg.Agent, step.ID)\n    \n    // Build prompt with expected outputs\n    prompt := e.buildPrompt(cfg)\n    \n    // Inject prompt via tmux send-keys\n    session := e.agents.GetSession(cfg.Agent)\n    if err := e.tmux.SendKeys(ctx, session, prompt); err != nil {\n        return fmt.Errorf(\"injecting prompt: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (e *AgentExecutor) buildPrompt(cfg *types.AgentConfig) string {\n    prompt := cfg.Prompt\n    \n    // Add output expectations if defined\n    if len(cfg.Outputs) \u003e 0 {\n        prompt += \"\\n\\n## Expected Outputs\\n\\n\"\n        prompt += \"When complete, run: meow done --output \u003ckey\u003e=\u003cvalue\u003e\\n\\n\"\n        for name, def := range cfg.Outputs {\n            required := \"\"\n            if def.Required {\n                required = \" (required)\"\n            }\n            prompt += fmt.Sprintf(\"- %s (%s)%s\", name, def.Type, required)\n            if def.Description != \"\" {\n                prompt += \": \" + def.Description\n            }\n            prompt += \"\\n\"\n        }\n    } else {\n        prompt += \"\\n\\nWhen complete, run: meow done\"\n    }\n    \n    return prompt\n}\n\n// HandleCompletion processes meow done from agent.\nfunc (e *AgentExecutor) HandleCompletion(\n    ctx context.Context,\n    step *types.Step,\n    wf *types.Workflow,\n    msg *ipc.StepDoneMessage,\n) error {\n    cfg := step.Agent\n    \n    // Transition to completing\n    if err := step.SetCompleting(); err != nil {\n        return err\n    }\n    \n    // Validate outputs if defined\n    if cfg.Outputs != nil {\n        errs := e.validator.ValidateOutputs(msg.Outputs, cfg.Outputs, cfg.Agent)\n        if len(errs) \u003e 0 {\n            // Validation failed - back to running\n            step.Status = types.StepStatusRunning\n            \n            // Return error message to agent\n            return \u0026ValidationFailedError{\n                Errors: errs,\n                Defs:   cfg.Outputs,\n            }\n        }\n    }\n    \n    // Validation passed - complete\n    step.Complete(msg.Outputs)\n    \n    // Mark agent as idle (no current step)\n    e.agents.SetIdle(cfg.Agent)\n    \n    return nil\n}\n\n// GetPromptForHook returns prompt for stop hook query.\nfunc (e *AgentExecutor) GetPromptForHook(step *types.Step) string {\n    cfg := step.Agent\n    \n    // Check step status\n    switch step.Status {\n    case types.StepStatusCompleting:\n        // Transition in progress, stay quiet\n        return \"\"\n        \n    case types.StepStatusRunning:\n        // Check mode\n        if cfg.Mode == types.AgentModeInteractive {\n            // Interactive mode - allow human conversation\n            return \"\"\n        }\n        // Autonomous mode - re-inject prompt as nudge\n        return e.buildPrompt(cfg)\n        \n    default:\n        // Not running/completing - agent is idle\n        return \"\"\n    }\n}\n\\`\\`\\`\n\n## Mode Handling\n\n\\`\\`\\`go\n// AgentMode determines stop hook behavior.\ntype AgentMode string\n\nconst (\n    AgentModeAutonomous  AgentMode = \"autonomous\"  // Default - stop hook re-injects prompt\n    AgentModeInteractive AgentMode = \"interactive\" // Stop hook returns empty, allows conversation\n)\n\\`\\`\\`\n\n**Autonomous mode (default):**\n- Stop hook fires → meow prime → returns current prompt\n- This \"nudges\" Claude to continue working\n- Ralph Wiggum loop ensures persistence\n\n**Interactive mode:**\n- Stop hook fires → meow prime → returns empty\n- Claude waits for human input\n- Enables natural conversation during step execution\n\n## Step Completion Flow\n\n\\`\\`\\`\n1. Agent calls: meow done --output x=y\n2. meow done CLI → IPC → Orchestrator\n3. Orchestrator: step.SetCompleting()\n4. Orchestrator: validate outputs\n   - If invalid: step.Status = running, return error to agent\n   - If valid: step.Complete(outputs)\n5. Orchestrator: send ESC to agent tmux session\n6. Orchestrator: find next step for this agent\n7. If found: inject next prompt\n8. If not found: agent sits idle (stop hook returns empty)\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Start() marks step running and injects prompt\n- [ ] buildPrompt() includes output expectations\n- [ ] HandleCompletion() uses completing status\n- [ ] Output validation with file_path scope\n- [ ] Validation failure returns step to running\n- [ ] GetPromptForHook() handles all statuses\n- [ ] Mode handling (autonomous vs interactive)\n- [ ] Agent state updates (current step, idle)\n- [ ] Unit tests for prompt building\n- [ ] Unit tests for completion flow\n- [ ] Unit tests for mode handling\n- [ ] Integration with IPC server","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:37Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.980625152-05:00","closed_at":"2026-01-08T23:55:57.980625152-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"meow-407","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T12:00:37Z","created_by":"claude"},{"issue_id":"meow-407","depends_on_id":"meow-410","type":"blocks","created_at":"2026-01-08T22:21:49.071762935-05:00","created_by":"ubuntu"}]}
{"id":"meow-408","title":"Implement gate executor handler","description":"# Implement Gate Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleGate(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Gate == nil {\n        return fmt.Errorf(\"gate step %s missing config\", step.ID)\n    }\n\n    // Mark running - human will complete via meow approve/reject\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    o.logger.Info(\"gate awaiting approval\",\n        \"workflow\", wf.ID,\n        \"step\", step.ID,\n    )\n\n    return nil\n}\n```\n\n## Key Points\n\n1. **External completion** - Human runs `meow approve` or `meow reject`\n2. **No assignee** - Gates are human-facing, not agent-facing\n3. **Timeout handling** - Future enhancement (auto-reject after timeout)\n\n## Completion Flow\n\n```\n1. handleGate marks step running\n2. Human sees gate via meow gates\n3. Human runs meow approve wf-xxx step-id\n4. meow approve finds step, marks done\n5. Next tick, orchestrator sees step is done\n\nOR\n\n3. Human runs meow reject wf-xxx step-id --reason \"...\"\n4. meow reject finds step, marks failed with reason\n5. Workflow may fail depending on error handling\n```\n\n## Acceptance Criteria\n\n- [ ] handleGate implementation\n- [ ] Marks step running\n- [ ] Logs for visibility\n- [ ] Unit tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:38Z","created_by":"claude","updated_at":"2026-01-08T22:15:50.196156243-05:00","closed_at":"2026-01-08T22:15:50.196156243-05:00","close_reason":"Gates are NOT a primitive executor in v2 spec. Human approval is implemented via branch executor + 'meow await-approval' command as the condition.","dependencies":[{"issue_id":"meow-408","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T12:00:38Z","created_by":"claude"}]}
{"id":"meow-40s","title":"Implement load context tracking","description":"LoadContext struct for current file, module, cycle detection. See IMPLEMENTATION-PLAN section meow-modules-loader-context.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.320905842-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented LoadContext struct with cycle detection, child context creation, and comprehensive tests","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-410","title":"Implement IPC server (Unix domain socket)","description":"Implement Unix domain socket IPC server with single-line JSON protocol. This is the communication channel between orchestrator and Claude agents per MVP-SPEC-v2 architecture. Critical path for agent integration.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T22:18:52.972179284-05:00","created_by":"ubuntu","updated_at":"2026-01-08T23:01:56.449145993-05:00","closed_at":"2026-01-08T23:01:56.449145993-05:00","close_reason":"Implemented IPC server and client with Unix domain socket support. Server provides Handler interface for orchestrator integration.","dependencies":[{"issue_id":"meow-410","depends_on_id":"meow-106","type":"blocks","created_at":"2026-01-08T22:21:37.803443503-05:00","created_by":"ubuntu"},{"issue_id":"meow-410","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T22:21:39.577554602-05:00","created_by":"ubuntu"},{"issue_id":"meow-410","depends_on_id":"meow-401","type":"blocks","created_at":"2026-01-08T22:21:39.577554602-05:00","created_by":"ubuntu"}]}
{"id":"meow-411","title":"Implement parallel step dispatch and agent idle checking","description":"Implement parallel dispatch of independent steps to multiple agents. Track agent idle state to determine when to send next steps per MVP-SPEC-v2 orchestrator requirements. Critical path for parallel execution.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T22:18:54.177050297-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:18:54.177050297-05:00","dependencies":[{"issue_id":"meow-411","depends_on_id":"pivot-407","type":"blocks","created_at":"2026-01-08T22:21:49.91386081-05:00","created_by":"ubuntu"},{"issue_id":"meow-411","depends_on_id":"meow-407","type":"blocks","created_at":"2026-01-08T22:21:49.91386081-05:00","created_by":"ubuntu"}]}
{"id":"meow-412","title":"Implement step timeouts and resource limits enforcement","description":"Implement timeout enforcement for steps and resource limit checking. Handle timeout expiration gracefully per MVP-SPEC-v2 orchestrator robustness requirements.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T22:18:55.020393615-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:18:55.020393615-05:00","dependencies":[{"issue_id":"meow-412","depends_on_id":"meow-411","type":"blocks","created_at":"2026-01-08T22:21:51.998905899-05:00","created_by":"ubuntu"}]}
{"id":"meow-461","title":"Implement helpful error messages for loading","description":"Typed errors with context and hints for reference failures. See IMPLEMENTATION-PLAN section meow-modules-loader-errors.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.605093738-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-46218984","title":"Manual task: Hook Test","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent","created_at":"2026-01-08T03:00:14.219899843-05:00","updated_at":"2026-01-08T03:03:02.718661421-05:00","closed_at":"2026-01-08T03:03:02.718661421-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-4941d5fa","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"test-agent1","created_at":"2026-01-08T03:46:14.163899172-05:00","updated_at":"2026-01-08T22:19:40.82908161-05:00","closed_at":"2026-01-08T22:19:40.82908161-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-4af","title":"Feature: Simulator Adapter","description":"# Feature: Simulator Adapter\n\n## Parent Epic\nmeow-qai: E2E Testing Infrastructure with Claude Simulator\n\n## Overview\n\nCreate a MEOW adapter configuration for the simulator. This allows workflows to spawn the simulator instead of Claude Code by specifying `adapter = \"simulator\"` in spawn steps.\n\n## Background: MEOW Adapter System\n\nMEOW is agent-agnostic. The adapter system encapsulates agent-specific behavior:\n\n- **Spawn command**: How to start the agent\n- **Prompt injection**: Pre-keys, method (literal/keys), post-keys\n- **Graceful stop**: What keys to send for shutdown\n- **Events**: Event translator script path\n\nAdapters live in `~/.meow/adapters/\u003cname\u003e/adapter.toml`.\n\n## Simulator Adapter\n\n```toml\n# ~/.meow/adapters/simulator/adapter.toml\n\n[adapter]\nname = \"simulator\"\ndescription = \"Claude Code simulator for E2E testing\"\n\n[spawn]\n# Command to start simulator\n# {{sim_config}} is a workflow variable pointing to behavior config\ncommand = \"meow-agent-sim --config {{sim_config}}\"\n\n# Resume command (simulator accepts but ignores session ID)\nresume_command = \"meow-agent-sim --config {{sim_config}} --resume {{session_id}}\"\n\n# Much faster than real Claude (3s)\nstartup_delay = \"100ms\"\n\n[environment]\n# Same as claude adapter - prevent tmux nesting detection\nTMUX = \"\"\n\n[prompt_injection]\n# Simulator is always ready, no need for Escape pre-key\npre_keys = []\npre_delay = \"0ms\"\nmethod = \"literal\"\npost_keys = [\"Enter\"]\n# Faster than real Claude (500ms)\npost_delay = \"50ms\"\n\n[graceful_stop]\nkeys = [\"C-c\"]\nwait = \"200ms\"\n\n[events]\n# Simulator calls meow commands directly, but keep translator\n# for consistency and potential external hook testing\ntranslator = \"./event-translator.sh\"\n\n[events.agent_config]\nStop = \"{{adapter_dir}}/event-translator.sh Stop\"\nPreToolUse = \"{{adapter_dir}}/event-translator.sh PreToolUse $TOOL_NAME\"\nPostToolUse = \"{{adapter_dir}}/event-translator.sh PostToolUse $TOOL_NAME\"\n```\n\n## Event Translator\n\nThe simulator doesn't need an external event translator (it calls IPC directly), but we include one for:\n1. Consistency with claude adapter\n2. Testing hook configuration itself\n3. Potential hybrid scenarios\n\n```bash\n# ~/.meow/adapters/simulator/event-translator.sh\n#!/bin/bash\n# Simulator event translator - delegates to meow CLI\n\nHOOK_TYPE=\"$1\"\nshift\n\ncase \"$HOOK_TYPE\" in\n  Stop)\n    meow event agent-stopped 2\u003e/dev/null || true\n    ;;\n  PreToolUse)\n    meow event tool-starting --data tool=\"$1\" 2\u003e/dev/null || true\n    ;;\n  PostToolUse)\n    meow event tool-completed --data tool=\"$1\" 2\u003e/dev/null || true\n    ;;\nesac\n\nexit 0\n```\n\n## Usage in Workflows\n\nTest workflows specify the simulator adapter:\n\n```toml\n# templates/test-with-simulator.meow.toml\n\n[main.variables]\nsim_config = { required = true, description = \"Path to simulator behavior config\" }\n\n[[main.steps]]\nid = \"spawn\"\nexecutor = \"spawn\"\nagent = \"test-agent\"\nadapter = \"simulator\"    # \u003c-- Use simulator, not claude\nworkdir = \"{{workdir}}\"\n```\n\n## Installation\n\nThe adapter should be installed:\n1. **During development**: symlink to repo's adapter dir\n2. **In CI**: copy adapter files before running tests\n3. **For users**: `meow adapter install` (future)\n\n```bash\n# Development installation\nmkdir -p ~/.meow/adapters\nln -sf $(pwd)/test/adapters/simulator ~/.meow/adapters/simulator\n\n# CI installation\ncp -r test/adapters/simulator ~/.meow/adapters/\n```\n\n## Acceptance Criteria\n\n1. [ ] Adapter config file created at correct location\n2. [ ] Event translator script is executable\n3. [ ] Adapter loads without errors: `meow adapter show simulator`\n4. [ ] Spawn step with adapter=simulator starts the simulator\n5. [ ] Prompt injection works (simulator receives prompts)\n6. [ ] Graceful stop terminates simulator cleanly\n\n## Dependencies\n\n- meow-a0z: Core Simulator Binary (need binary to spawn)\n- meow-ur9: Hook Emulation System (for event translator)\n\n## File Structure\n\n```\ntest/adapters/simulator/\n├── adapter.toml         # Adapter configuration\n├── event-translator.sh  # Event hook translator\n└── README.md            # Documentation\n```\n\n## Reference\n\n- `docs/MVP-SPEC-v2.md` - Section: Agent Adapters\n- `internal/adapter/builtin/claude_adapter.toml` - Claude adapter (template)\n- `internal/adapter/registry.go` - Adapter loading logic","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T19:54:19.599258899-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:19.599258899-05:00","dependencies":[{"issue_id":"meow-4af","depends_on_id":"meow-a0z","type":"blocks","created_at":"2026-01-09T19:54:24.965365064-05:00","created_by":"ubuntu"},{"issue_id":"meow-4af","depends_on_id":"meow-ur9","type":"blocks","created_at":"2026-01-09T19:54:25.080432107-05:00","created_by":"ubuntu"}]}
{"id":"meow-4wg","title":"vars.go: Code field not substituted in SubstituteStep()","description":"## Location\n`internal/template/vars.go:298-376`\n\n## Problem\nThe `SubstituteStep()` function substitutes many fields but NOT the `Code` field:\n\nSubstituted:\n- ✅ Description\n- ✅ Instructions\n- ✅ Condition\n- ✅ Template\n- ✅ Validation\n- ✅ Timeout\n- ✅ Variables\n- ✅ OnTrue, OnFalse, OnTimeout\n\nNOT substituted:\n- ❌ Code\n\n## Impact\nCode beads with variable references will NOT have variables replaced:\n```toml\n[[steps]]\nid = \"setup\"\ntype = \"code\"\ncode = \"echo {{agent}} \u003e /tmp/agent.txt\"  # {{agent}} stays literal!\n```\n\nThis breaks:\n- Worktree setup scripts\n- Session ID capture\n- Any dynamic shell code\n\n## Fix\nAdd Code field substitution in SubstituteStep():\n```go\nif result.Code != \"\" {\n    result.Code, err = c.Substitute(result.Code)\n    if err != nil {\n        return nil, fmt.Errorf(\"substitute code: %w\", err)\n    }\n}\n```\n\n## Severity\nHIGH - Code beads are essential for orchestration (worktree, sessions, git ops)","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T02:22:28.194025757-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:32:55.141969596-05:00","closed_at":"2026-01-08T02:32:55.141969596-05:00","close_reason":"Fixed: Added Code field substitution in SubstituteStep() with tests"}
{"id":"meow-505","title":"Implement meow stop command","description":"Implement 'meow stop' CLI command for graceful workflow termination. Should signal orchestrator, wait for cleanup, and persist final state per MVP-SPEC-v2 CLI requirements. Critical for operator control.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T22:18:56.534859332-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:37:34.338535621-05:00","dependencies":[{"issue_id":"meow-505","depends_on_id":"meow-202","type":"blocks","created_at":"2026-01-08T12:00:55Z","created_by":"claude"},{"issue_id":"meow-505","depends_on_id":"meow-205","type":"blocks","created_at":"2026-01-08T22:21:58.051496026-05:00","created_by":"ubuntu"}]}
{"id":"meow-507","title":"Implement meow await-approval command","description":"Implement 'meow await-approval' CLI command that blocks until approval is granted. Used for branch conditions and human gates per MVP-SPEC-v2 CLI requirements. Critical for gate workflow.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T22:18:57.710680704-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:18:57.710680704-05:00","dependencies":[{"issue_id":"meow-507","depends_on_id":"meow-505","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"meow-507","depends_on_id":"pivot-406","type":"blocks","created_at":"2026-01-08T22:21:58.964449245-05:00","created_by":"ubuntu"},{"issue_id":"meow-507","depends_on_id":"meow-406","type":"blocks","created_at":"2026-01-08T22:21:58.964449245-05:00","created_by":"ubuntu"},{"issue_id":"meow-507","depends_on_id":"meow-410","type":"blocks","created_at":"2026-01-08T22:22:00.230857222-05:00","created_by":"ubuntu"}]}
{"id":"meow-508","title":"Implement meow session-id command","description":"Implement 'meow session-id' CLI command to retrieve the current Claude session ID. Enables workflow resume after context limits per MVP-SPEC-v2 CLI requirements.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T22:19:00.371751356-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:19:00.371751356-05:00","dependencies":[{"issue_id":"meow-508","depends_on_id":"pivot-403","type":"blocks","created_at":"2026-01-08T22:22:02.0873759-05:00","created_by":"ubuntu"},{"issue_id":"meow-508","depends_on_id":"meow-403","type":"blocks","created_at":"2026-01-08T22:22:02.0873759-05:00","created_by":"ubuntu"}]}
{"id":"meow-509","title":"Implement meow gates command","description":"Implement 'meow gates' CLI command to list all pending approval gates in the current workflow. Helps operators see what needs attention per MVP-SPEC-v2 CLI requirements.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T22:19:01.940530524-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:24:18.670988394-05:00","closed_at":"2026-01-08T22:24:18.670988394-05:00","close_reason":"Duplicate of pivot-506 (meow gates command)","dependencies":[{"issue_id":"meow-509","depends_on_id":"meow-507","type":"blocks","created_at":"2026-01-08T22:22:03.091430292-05:00","created_by":"ubuntu"}]}
{"id":"meow-58l","title":"Implement module validation","description":"Validate local references, detect cycles, check internal visibility. See IMPLEMENTATION-PLAN section meow-modules-parser-validate.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:38:36.217177591-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented module validation: local reference validation, internal visibility checks, hooks_to validation, variable reference checking, type-specific validation rules. Added 40+ comprehensive tests.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-5d8","title":"Create implement-tdd module","description":"TDD workflow as part of work-loop module. See IMPLEMENTATION-PLAN.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.459141219-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by v2 pivot - templates will be recreated","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-5ex","title":"Define ForeachConfig type and fields","description":"Define the ForeachConfig struct in internal/types/step.go:\n\nFields:\n- Items: string (expression evaluating to JSON array)\n- ItemVar: string (variable name for current item)\n- IndexVar: string (optional, variable name for index)\n- Template: string (template reference to expand)\n- Variables: map[string]string (variables to pass)\n- Parallel: bool (default true)\n- MaxConcurrent: int (optional limit)\n- Join: bool (default true)\n\nAdd validation for required fields and add ForeachConfig to the executor config union in StepConfig.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:31.0788532-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:31.0788532-05:00"}
{"id":"meow-5tm","title":"baker.go: Start/Stop specs use unsubstituted assignee","description":"## Location\n`internal/template/baker.go:475-490`\n\n## Problem\nIn `setTypeSpec()`, the `StartSpec.Agent` and `StopSpec.Agent` use `step.Assignee` directly, but this is the raw template value (e.g., `{{agent}}`), not the substituted value.\n\nThe substituted assignee IS computed in `workflowStepToBead()` (lines 194-205), but it's never passed to `setTypeSpec()` - the function receives the original step.\n\n```go\ncase types.BeadTypeStart:\n    spec := \u0026types.StartSpec{\n        Agent: step.Assignee,  // Uses raw \"{{agent}}\", not substituted value\n    }\n```\n\n## Impact\n- Start beads will try to spawn agent literally named \"{{agent}}\"\n- Stop beads will try to kill agent literally named \"{{agent}}\"\n- Agent lifecycle management broken for any template using variable assignees\n\n## Fix\nEither:\n1. Pass the substituted assignee to `setTypeSpec()`, or\n2. Substitute within `setTypeSpec()`, or\n3. Create a modified step copy with substituted values before calling\n\n## Severity\nHIGH - Agent start/stop broken for templates with variable assignees","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T02:22:26.443811687-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:30:41.159025876-05:00","closed_at":"2026-01-08T02:30:41.159025876-05:00","close_reason":"Fixed: setTypeSpec() now uses bead.Assignee (substituted value) instead of step.Assignee (raw template value) for Start/Stop specs. Added test to verify variable substitution in Start/Stop steps."}
{"id":"meow-5u6","title":"Create work-loop module template","description":"Main loop: select work, implement, repeat. Module format example. See IMPLEMENTATION-PLAN section meow-modules-templates-workloop.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.337170169-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by v2 pivot - will be recreated","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-5y2m","title":"Write execution mode E2E tests","description":"Implement E2E tests for autonomous/interactive/fire_forget modes. Verify: autonomous re-injects on stop, interactive stays at prompt, fire_forget completes immediately after injection.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:03:47.666759769-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:03:47.666759769-05:00","dependencies":[{"issue_id":"meow-5y2m","depends_on_id":"meow-jd7d","type":"blocks","created_at":"2026-01-09T20:03:53.015516083-05:00","created_by":"ubuntu"}]}
{"id":"meow-5yi","title":"Orchestrator: Tier-Aware Processing","description":"Update orchestrator for three-tier bead model. Phase 3.","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.937979017-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:17.077250825-05:00","closed_at":"2026-01-08T22:14:17.077250825-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot (pivot-000). The three-tier bead model is replaced by workflow-centric architecture."}
{"id":"meow-603","title":"Delete old bead-centric code and types","description":"Remove legacy bead-centric architecture code and types that are superseded by the workflow-centric model in MVP-SPEC-v2. Clean up dead code to reduce confusion.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T22:19:02.856508454-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:19:02.856508454-05:00","dependencies":[{"issue_id":"meow-603","depends_on_id":"meow-204","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"},{"issue_id":"meow-603","depends_on_id":"meow-507","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"},{"issue_id":"meow-603","depends_on_id":"pivot-106","type":"blocks","created_at":"2026-01-08T22:22:08.985280962-05:00","created_by":"ubuntu"},{"issue_id":"meow-603","depends_on_id":"meow-106","type":"blocks","created_at":"2026-01-08T22:22:08.985280962-05:00","created_by":"ubuntu"}]}
{"id":"meow-629ae87d","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello","created_at":"2026-01-08T03:41:53.546432921-05:00","updated_at":"2026-01-08T22:19:40.832850582-05:00","closed_at":"2026-01-08T22:19:40.832850582-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-6dcee4c3","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"hello1","created_at":"2026-01-08T03:47:17.315958926-05:00","updated_at":"2026-01-08T22:19:40.834712533-05:00","closed_at":"2026-01-08T22:19:40.834712533-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-74b","title":"Create MEOW beads fork strategy and implementation","description":"Per SPEC-ADDENDUM-WISPS-AND-MODULES.md (lines 63-109), MEOW Stack requires a fork of the beads CLI/library.\n\n## Rationale\n\nThe upstream `beads` project is general-purpose issue tracking. MEOW requires:\n\n1. **New bead types** - `start`, `stop`, `condition`, `code`, `expand`, `gate` as first-class `IssueType` values\n2. **Tier field** - Explicit `Tier` enum on the Issue struct (not computed from labels)\n3. **Workflow metadata** - `HookBead`, `SourceWorkflow`, `WorkflowID` fields\n4. **Custom statuses** - Potentially workflow-specific status values\n5. **Output storage** - `Outputs map[string]any` for bead-to-bead data flow\n6. **Type-specific specs** - `ConditionSpec`, `StartSpec`, etc. on the Issue struct\n\n## Fork Strategy\n\n```\ngithub.com/anthropics/beads           # Upstream (general issue tracking)\ngithub.com/meow-stack/meow-beads      # Fork (workflow orchestration)\n```\n\n## Implementation Options\n\n**Option A: Internal Types (Current Approach)**\n- Define MEOW-specific types in `internal/types/bead.go`\n- Adapter layer to convert to/from upstream beads format\n- Pros: No fork maintenance, gradual adoption\n- Cons: Type conversion overhead, schema drift\n\n**Option B: True Fork**\n- Fork upstream beads to meow-beads repo\n- Extend Issue struct directly\n- Pros: Clean integration, single source of truth\n- Cons: Fork maintenance burden\n\n**Recommendation**: Start with Option A (internal types), evaluate fork if needed.\n\n## Current State\n\nThe existing `internal/types/bead.go` already defines MEOW-specific Bead struct. This task is to:\n1. Document the relationship to upstream beads\n2. Ensure type conversion works correctly\n3. Plan for potential future fork if internal types become unwieldy\n\n## Acceptance Criteria\n- [ ] Document fork strategy in ARCHITECTURE.md\n- [ ] Verify internal types cover all MEOW requirements\n- [ ] Add type conversion helpers if using upstream beads storage\n- [ ] Update meow-e8.1 (beads integration) with this context","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T17:53:04.241715524-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"No fork needed - internal types in internal/types/bead.go already implement MEOW-specific fields. The beads CLI uses JSONL format which we can read/write directly. Document this decision in ARCHITECTURE.md as part of normal docs work.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-74g","title":"Define error types per executor","description":"Define error type constants and add error type field to step failure state.\n\nIn internal/types/step.go or internal/types/errors.go:\n\nError types by executor:\n- Agent: timeout, agent_not_found, agent_crashed\n- Shell: command_failed, timeout\n- Spawn: spawn_failed\n- Expand: template_not_found, expansion_limit\n- Branch: condition_error, expansion_limit\n- Foreach: invalid_items, expansion_limit, child_failed\n\nAdd ErrorType field to step error struct:\ntype StepError struct {\n    Type    string  // error type constant\n    Message string\n    Code    int     // exit code for shell\n    Output  string  // captured output\n}","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:25.44740068-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:25.44740068-05:00","dependencies":[{"issue_id":"meow-74g","depends_on_id":"meow-ljo","type":"blocks","created_at":"2026-01-09T15:04:04.350485088-05:00","created_by":"ubuntu"}]}
{"id":"meow-74h","title":"Implement meow close with output validation","description":"Validate required outputs before closing wisp steps per SPEC-ADDENDUM.\n\n## Usage\n\n```bash\n# Close with required outputs\nmeow close select-work \\\n    --output work_bead=gt-123 \\\n    --output rationale=\"Highest priority, unblocks 3 others\"\n\n# Or with JSON\nmeow close select-work --output-json '{\n    \"work_bead\": \"gt-123\",\n    \"rationale\": \"Highest priority, unblocks 3 others\"\n}'\n```\n\n## Validation\n\n```go\nfunc CloseWispStep(ctx context.Context, store Store, stepID string, outputs map[string]string) error {\n    step, _ := store.Get(ctx, stepID)\n    \n    // Validate outputs against TaskOutputSpec\n    if err := validateOutputs(step, outputs); err \\!= nil {\n        return err  // Reject close if outputs invalid\n    }\n    \n    step.Outputs = outputs\n    step.Status = StatusClosed  // Direct to closed, no 'hooked' intermediate\n    step.ClosedAt = time.Now()\n    \n    return store.Update(ctx, step)\n}\n```\n\n## Output Types (from types.TaskOutputType)\n\n| Type | Validation |\n|------|------------|\n| string | Non-empty |\n| bead_id | Bead exists in store |\n| number | Parseable as float |\n| boolean | \"true\" or \"false\" |\n| file_path | File exists |\n\n## Key Changes from Implementation Plan\n\n- **No hooked status** - Status goes directly from in_progress to closed\n- **bead_id validation** - Validates bead exists, not just string format\n\n## File Location\nModify: `cmd/meow/cmd/close.go`\n\n## Acceptance Criteria\n- [ ] Validates required outputs before close\n- [ ] bead_id type validates bead exists\n- [ ] Stores outputs on bead\n- [ ] Helpful error messages for missing/invalid outputs","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:25.095279763-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Verified working: meow close validates required outputs, bead_id type validates existence, stores outputs on bead, shows helpful error messages","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-7bbb265a","title":"Setup test: integration","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881469714-05:00","updated_at":"2026-01-08T03:03:03.083696409-05:00","closed_at":"2026-01-08T03:03:03.083696409-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-7e1","title":"Implement fire_forget mode for agent executor","description":"Add fire_forget mode to the agent executor that injects prompts and immediately marks the step done without waiting for meow done.\n\n## Background\n\nThe agent executor currently supports two modes:\n- `autonomous`: Wait for meow done, re-inject on stop hook\n- `interactive`: Wait for meow done, allow human conversation\n\nWe need a third mode `fire_forget` that:\n- Injects the prompt using the full reliable injection mechanism\n- Immediately marks the step as done (no waiting for meow done)\n- Cannot have outputs (since we don't wait for completion)\n- Timeout is not applicable\n\n## Use Cases\n\n- Sending `/compact` to trigger context compaction\n- Sending `Escape` key to pause agent mid-work\n- Any fire-and-forget command injection\n\n## Implementation\n\n### 1. Update AgentConfig type (internal/types/step.go)\n\nThe `Mode` field already exists as a string. Document the valid values:\n- `autonomous` (default)\n- `interactive`\n- `fire_forget`\n\n### 2. Add validation (internal/orchestrator/executor_agent.go)\n\nIn `StartAgentStep()`, validate that fire_forget mode cannot have outputs:\n```go\nif cfg.Mode == \"fire_forget\" \u0026\u0026 len(cfg.Outputs) \u003e 0 {\n    return nil, \u0026types.StepError{Message: \"fire_forget mode cannot have outputs\"}\n}\n```\n\n### 3. Update buildAgentPrompt (internal/orchestrator/executor_agent.go)\n\nDon't append \"meow done\" instructions for fire_forget mode:\n```go\nfunc buildAgentPrompt(cfg *types.AgentConfig) string {\n    var sb strings.Builder\n    sb.WriteString(cfg.Prompt)\n    \n    // Only add meow done instructions if NOT fire_forget\n    if cfg.Mode != \"fire_forget\" {\n        // existing output/meow done logic\n    }\n    \n    return sb.String()\n}\n```\n\n### 4. Update handleAgent (internal/orchestrator/orchestrator.go)\n\nComplete immediately for fire_forget mode:\n```go\nfunc (o *Orchestrator) handleAgent(...) error {\n    // ... existing injection logic ...\n    \n    // Fire-and-forget mode completes immediately\n    if step.Agent.Mode == \"fire_forget\" {\n        if err := step.Complete(nil); err != nil {\n            return fmt.Errorf(\"completing fire-forget step: %w\", err)\n        }\n    }\n    // Otherwise step stays \"running\" until meow done\n    \n    return nil\n}\n```\n\n### 5. Tests\n\nAdd tests in `internal/orchestrator/executor_agent_test.go`:\n- Test fire_forget mode builds prompt without meow done instructions\n- Test fire_forget mode validation rejects outputs\n- Test fire_forget step completes immediately after injection\n\n## Acceptance Criteria\n\n- [ ] fire_forget mode injects prompt and completes immediately\n- [ ] fire_forget mode uses full injection reliability (copy mode, readiness, retry)\n- [ ] fire_forget mode rejects outputs with clear error\n- [ ] fire_forget prompt does not include \"meow done\" instructions\n- [ ] All existing tests pass\n- [ ] New tests cover fire_forget behavior\n\n## References\n\n- Spec: docs/MVP-SPEC-v2.md (search for \"fire_forget\")\n- Context Monitor Pattern in spec shows usage","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-01-09T15:33:16.022033034-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:39:54.037867473-05:00","closed_at":"2026-01-09T15:39:54.037867473-05:00","close_reason":"Closed"}
{"id":"meow-7hf","title":"Implement retry count tracking","description":"Track retry count across recovery attempts for a step.\n\nImplementation:\n- Track retries per original step ID\n- Increment _failed_step.retries each recovery attempt\n- Reset on successful completion\n- Make available in recovery template context\n- Useful for 'retry N times then escalate' patterns","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:30.010384161-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:30.010384161-05:00","dependencies":[{"issue_id":"meow-7hf","depends_on_id":"meow-ljo","type":"blocks","created_at":"2026-01-09T15:04:11.997656783-05:00","created_by":"ubuntu"},{"issue_id":"meow-7hf","depends_on_id":"meow-cql","type":"blocks","created_at":"2026-01-09T15:04:12.11007881-05:00","created_by":"ubuntu"}]}
{"id":"meow-7x5","title":"Maintain legacy format compatibility","description":"ParseAny() that handles both formats, Template.ToModule() conversion. See IMPLEMENTATION-PLAN section meow-modules-parser-legacy.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:38:36.313359455-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"No legacy compatibility in pre-customer MVP - only one format exists","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-8x2","title":"Define module-level parser types","description":"Define module-level parser types per SPEC-ADDENDUM-WISPS-AND-MODULES.md.\n\n## Types to Define\n\n```go\n// FileFormat indicates the template file format\ntype FileFormat int\n\nconst (\n    FormatLegacy FileFormat = iota  // [meta] + [[steps]]\n    FormatModule                     // [workflow-name] sections\n)\n\n// Module represents a parsed module file\ntype Module struct {\n    Path      string               // File path for error messages\n    Workflows map[string]*Workflow // Named workflows\n}\n\n// Workflow represents a single workflow within a module\ntype Workflow struct {\n    Name        string           `toml:\"name\"`\n    Description string           `toml:\"description,omitempty\"`\n    Ephemeral   bool             `toml:\"ephemeral,omitempty\"`\n    Internal    bool             `toml:\"internal,omitempty\"`\n    HooksTo     string           `toml:\"hooks_to,omitempty\"`    // Links wisps to this variable's bead ID\n    Variables   map[string]*Var  `toml:\"variables,omitempty\"`\n    Steps       []*Step          `toml:\"steps\"`\n}\n\n// Step type field accepts:\n// - task | collaborative | gate | condition | code | start | stop | expand\n```\n\n## Key Addition: HooksTo Property\n\nThe `HooksTo` field declares which variable contains the work bead ID that all wisps from this workflow should link to:\n\n```toml\n[implement]\nephemeral = true\nhooks_to = \"work_bead\"   # All wisps link to {{work_bead}}\n```\n\nThis replaces magic variable name detection with explicit declaration.\n\n## Step Type Validation\n\nValid step types per SPEC-ADDENDUM:\n- `task` - Agent work, auto-continues\n- `collaborative` - Agent + human conversation, pauses\n- `gate` - Human approval (no assignee)\n- `condition` - Branch/loop/wait\n- `code` - Shell execution\n- `start` - Spawn agent\n- `stop` - Kill agent\n- `expand` - Template expansion\n\n## File Location\nCreate: `internal/template/module.go`\n\n## Acceptance Criteria\n- [ ] FileFormat enum defined\n- [ ] Module struct with Workflows map\n- [ ] Workflow struct with HooksTo field\n- [ ] Step type validation includes all 8 types\n- [ ] Helper methods: GetWorkflow(), DefaultWorkflow(), IsInternal()\n- [ ] Unit tests for helper methods","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:35.94360773-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented minimal viable slice: module parser, tier tracking, and meow prime command","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-97m","title":"Implement wisp-aware meow prime","description":"Show workflow progression, work bead, current step per SPEC-ADDENDUM. **Crucially, returns empty output for in-progress collaborative steps** to disable auto-continuation.\n\n## Output Format\n\n```\n═══════════════════════════════════════════════════════════════\nYour workflow: implement-tdd (step 2/4)\nWork bead: gt-123 \"Implement auth endpoint\"\n═══════════════════════════════════════════════════════════════\n\n  ✓ load-context\n  → write-tests [in_progress] ← YOU ARE HERE\n  ○ implement\n  ○ commit\n\n───────────────────────────────────────────────────────────────\nInstructions:\n  Write failing tests that define the expected behavior.\n  Tests MUST fail at this point.\n\nRequired outputs: (none)\n───────────────────────────────────────────────────────────────\n```\n\n## Implementation with Collaborative Support\n\n```go\nfunc Prime(ctx context.Context, store Store, agentID string, format string) (*PrimeOutput, error) {\n    // Check for in-progress collaborative step first\n    inProgress, _ := store.List(ctx, BeadFilter{\n        Tier:     TierWisp,\n        Assignee: agentID,\n        Status:   StatusInProgress,\n    })\n    \n    for _, step := range inProgress {\n        if step.Type == BeadTypeCollaborative {\n            // Collaborative step in progress - don't auto-continue!\n            if format == \"prompt\" {\n                return nil, nil  // Empty output = no injection\n            }\n            // For non-prompt format, show status with conversation mode flag\n            return \u0026PrimeOutput{\n                Workflow:         getWorkflowInfo(step),\n                WorkBead:         getHookBead(step),\n                ConversationMode: true,  // Signal to UI\n            }, nil\n        }\n    }\n    \n    // Normal flow: filter wisps for this agent (Tier field, not labels)\n    wispSteps, _ := store.List(ctx, BeadFilter{\n        Tier:     TierWisp,\n        Assignee: agentID,\n        Statuses: []BeadStatus{StatusOpen, StatusInProgress},\n    })\n    \n    // Get linked work bead via HookBead field\n    var workBead *types.Bead\n    if current.HookBead != \"\" {\n        workBead, _ = store.Get(ctx, current.HookBead)\n    }\n    // ...\n}\n```\n\n## Stop Hook Integration\n\nThe stop hook relies on empty output for collaborative steps:\n\n```bash\n#!/bin/bash\n# .claude/hooks/stop-hook.sh\n\noutput=$(meow prime --format prompt 2\u003e/dev/null)\n\nif [ -z \"$output\" ]; then\n    # Empty = collaborative mode OR no more work\n    exit 0\nfi\n\n# Normal task - inject the next prompt\necho \"$output\"\n```\n\n## Key Changes from Original Plan\n\n- **Collaborative check first** - Before finding next step, check for in-progress collaborative\n- **Empty output for collaborative** - `--format prompt` returns nothing\n- **ConversationMode flag** - Non-prompt formats can indicate conversation mode\n- **No hooked status** - Only open, in_progress, closed\n- **Filter on Tier field** - Not labels\n\n## File Location\nModify: `cmd/meow/cmd/prime.go`\n\n## Acceptance Criteria\n- [ ] Shows workflow progression (step N/M)\n- [ ] Shows linked work bead title\n- [ ] Shows current step instructions\n- [ ] Shows required outputs if any\n- [ ] Only shows agent's wisps (tier + assignee filter)\n- [ ] Returns empty for in-progress collaborative steps (--format prompt)\n- [ ] ConversationMode flag for non-prompt formats","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.846649317-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Completed: Added required outputs display to meow prime command with tests","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-99z","title":"Implement wildcard pattern matching in needs","description":"Implement pattern matching logic for the needs field.\n\nIn internal/orchestrator/dependency.go:\n- Detect wildcard patterns in needs (contains '*')\n- Implement pattern matching against step IDs\n- Use glob-like semantics (* matches one path segment)\n- Handle multiple wildcards (e.g., '*.*.done')\n- Return list of matching step IDs","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:20.060661458-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:20.060661458-05:00","dependencies":[{"issue_id":"meow-99z","depends_on_id":"meow-vhy","type":"blocks","created_at":"2026-01-09T15:03:42.053333171-05:00","created_by":"ubuntu"}]}
{"id":"meow-a02","title":"Add foreach executor tests","description":"Comprehensive tests for the foreach executor.\n\nTest cases:\n- Basic iteration over array\n- Empty array handling\n- Parallel execution (verify concurrent)\n- Sequential execution (verify order)\n- max_concurrent limiting\n- Implicit join (downstream waits)\n- join=false (immediate completion)\n- item_var and index_var access\n- Nested object item access\n- Error handling (invalid items)\n- Integration with existing executors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:41.166513866-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:41.166513866-05:00","dependencies":[{"issue_id":"meow-a02","depends_on_id":"meow-5ex","type":"blocks","created_at":"2026-01-09T15:04:20.795498803-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-qvy","type":"blocks","created_at":"2026-01-09T15:04:20.926124585-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-1mc","type":"blocks","created_at":"2026-01-09T15:04:21.075153735-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-mfr","type":"blocks","created_at":"2026-01-09T15:04:21.198805894-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-ako","type":"blocks","created_at":"2026-01-09T15:04:21.314930841-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-je8","type":"blocks","created_at":"2026-01-09T15:04:21.426472101-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-fus","type":"blocks","created_at":"2026-01-09T15:04:21.563434313-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-p8v","type":"blocks","created_at":"2026-01-09T15:04:21.677127368-05:00","created_by":"ubuntu"},{"issue_id":"meow-a02","depends_on_id":"meow-3xa","type":"blocks","created_at":"2026-01-09T15:04:21.798182949-05:00","created_by":"ubuntu"}]}
{"id":"meow-a0z","title":"Feature: Core Simulator Binary","description":"# Feature: Core Simulator Binary\n\n## Parent Epic\nmeow-qai: E2E Testing Infrastructure with Claude Simulator\n\n## Overview\n\nCreate `meow-agent-sim`, a Go binary that implements Claude Code's behavioral contract. This is the foundation of the E2E testing infrastructure - everything else depends on this working correctly.\n\n## Why Go (not Bash)?\n\nThe existing `MockClaudeScript` in `internal/testutil/mock_claude.go` is a bash script. We're replacing it with Go because:\n\n1. **State machine rigor** - Go's type system enforces valid state transitions\n2. **Better IPC** - Direct socket communication, not shelling out to `meow` CLI\n3. **Structured logging** - JSON logs for test assertions\n4. **Error handling** - Explicit error paths, not silent failures\n5. **Testability** - The simulator itself can have unit tests\n\n## Behavioral Contract\n\nThe simulator MUST behave exactly like Claude Code from MEOW's perspective:\n\n### Startup\n```\n1. Accept CLI flags: --dangerously-skip-permissions, --resume \u003csession_id\u003e\n2. Print startup messages (optional, configurable)\n3. Wait startup_delay (100ms default, vs 3s for real Claude)\n4. Show prompt indicator \"\u003e \" on stdout\n```\n\n### Prompt Reception\n```\n1. Read lines from stdin (tmux send-keys -l embeds newlines)\n2. Detect end of prompt (Enter key sends newline)\n3. Transition state: IDLE → WORKING\n```\n\n### Work Execution\n```\n1. Match received prompt against configured behaviors\n2. Execute action (complete, ask, fail, hang, crash)\n3. For 'complete': call meow done with outputs\n4. For 'ask': print question, stay at prompt\n5. For 'fail': print error, stay at prompt (triggers retry)\n```\n\n### Completion Signaling\n```\n1. Build IPC message: {\"type\":\"step_done\",\"outputs\":{...}}\n2. Connect to $MEOW_ORCH_SOCK\n3. Send message, read response\n4. If error: handle based on config (retry or give up)\n5. If ack: transition to IDLE\n```\n\n## State Machine\n\n```\n┌──────────┐     ┌──────────┐     ┌──────────┐\n│ STARTING │────►│   IDLE   │────►│ WORKING  │\n└──────────┘     └──────────┘     └──────────┘\n                      ▲                │\n                      │                │\n                      └────────────────┘\n                           │\n                      ┌────┴────┐\n                      │ ASKING  │ (sub-state of IDLE)\n                      └─────────┘\n```\n\n- **STARTING**: Initializing, waiting startup_delay\n- **IDLE**: Showing prompt, waiting for input\n- **WORKING**: Processing prompt, executing action\n- **ASKING**: Special IDLE state - asked a question, waiting for human response\n\n## File Structure\n\n```\ncmd/meow-agent-sim/\n├── main.go           # Entry point, CLI parsing\n├── state.go          # State machine implementation\n├── behavior.go       # Behavior matching and execution\n├── ipc.go            # Direct IPC client (not shelling out)\n├── config.go         # YAML config loading\n└── main_test.go      # Unit tests for simulator\n```\n\n## Environment Variables\n\nMust respect (set by orchestrator):\n- `MEOW_AGENT` - Agent identifier\n- `MEOW_WORKFLOW` - Workflow ID\n- `MEOW_ORCH_SOCK` - Path to orchestrator IPC socket\n- `MEOW_STEP` - Current step ID (updated by orchestrator)\n\nSimulator-specific:\n- `MEOW_SIM_CONFIG` - Path to behavior config (override CLI)\n- `MEOW_SIM_LOG_LEVEL` - Logging verbosity (debug/info/warn/error)\n- `MEOW_SIM_DETERMINISTIC` - Disable any randomization\n\n## Acceptance Criteria\n\n1. [ ] Binary builds: `go build ./cmd/meow-agent-sim`\n2. [ ] Shows \"\u003e \" prompt after startup\n3. [ ] Reads multiline input from stdin\n4. [ ] Matches prompts to configured behaviors\n5. [ ] Calls meow done with specified outputs\n6. [ ] Transitions states correctly (IDLE→WORKING→IDLE)\n7. [ ] Logs all actions in JSON format to stderr\n8. [ ] Respects MEOW_* environment variables\n\n## Dependencies\n\nNone - this is the foundation\n\n## Testing\n\nThe simulator itself needs unit tests:\n- State transitions\n- Behavior matching (regex, substring)\n- IPC message formatting\n- Config loading\n\n## Reference\n\n- `docs/E2E-TESTING-DESIGN.md` - Section: Simulator Architecture\n- `internal/testutil/mock_claude.go` - Existing mock (for reference)\n- `internal/ipc/messages.go` - IPC message types","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T19:52:59.503670867-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:52:59.503670867-05:00","dependencies":[{"issue_id":"meow-a0z","depends_on_id":"meow-qai","type":"blocks","created_at":"2026-01-09T19:53:05.343623073-05:00","created_by":"ubuntu"}]}
{"id":"meow-a28","title":"baker.go: BakeInline() doesn't set Tier or Instructions fields","description":"## Location\n`internal/template/baker.go:522-603`\n\n## Problem\nInline beads created by `BakeInline()` are missing critical fields:\n\n```go\nbead := \u0026types.Bead{\n    ID:          beadID,\n    Type:        beadType,\n    Title:       description,\n    Description: instructions,\n    Status:      types.BeadStatusOpen,\n    Assignee:    b.Assignee,\n    Needs:       needs,\n    Parent:      parentBeadID,\n    CreatedAt:   b.Now(),\n    // Missing: Tier field (will be empty string)\n    // Missing: Instructions field (only Description is set)\n}\n```\n\n## Impact\n1. **Tier not set**: Inline beads have empty tier, breaking tier-based filtering\n   - `meow prime` may not show them correctly\n   - Orchestrator priority sorting affected (empty tier → default to work tier priority)\n\n2. **Instructions not set**: `meow prime` uses Instructions for display, will show empty\n\n## Fix\nAdd the missing fields:\n```go\nbead := \u0026types.Bead{\n    // ... existing fields ...\n    Tier:         types.TierWisp,  // Inline beads from conditions are wisps\n    Instructions: instructions,\n}\n```\n\n## Severity\nMEDIUM - Affects inline beads from condition branches","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:00.59265739-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:30:45.511135272-05:00","closed_at":"2026-01-08T02:30:45.511135272-05:00","close_reason":"Fixed: BakeInline() now sets Tier (TierWisp) and Instructions fields on created beads. Added test to verify both fields are correctly populated."}
{"id":"meow-a85","title":"Add filter types for tier-based queries","description":"Add filter types for tier-based queries. Per SPEC-ADDENDUM, filter on explicit Tier field, not labels.\n\n## Filter Structure\n\n```go\ntype BeadFilter struct {\n    // Existing filters...\n    Status     *BeadStatus\n    Assignee   *string\n    \n    // NEW: Tier-based filtering (explicit field, not labels)\n    Tier       *BeadTier      // Filter by tier: work, wisp, orchestrator\n    \n    // Workflow context\n    WorkflowID *string        // Filter by workflow instance\n    HookBead   *string        // Filter wisps for specific work bead\n    \n    // Exclusions\n    ExcludeTiers []BeadTier   // Exclude specific tiers\n}\n```\n\n## Key Design Decisions\n\n1. **Filter on Tier field** - O(1) comparison, not label scanning\n2. **ExcludeTiers** - For `bd ready` to exclude wisps/orchestrator beads\n3. **HookBead filter** - Find all wisps implementing a work bead\n\n## File Location\nModify: `internal/types/bead.go` or new `internal/types/filter.go`\n\n## Acceptance Criteria\n- [ ] BeadFilter struct with Tier field\n- [ ] ExcludeTiers slice for exclusion filtering\n- [ ] WorkflowID and HookBead filters\n- [ ] Unit tests for filter matching","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:53.281343266-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Filter types are part of the unified filtering implementation.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-ab26b34d","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"tiertest","created_at":"2026-01-08T03:56:40.737449805-05:00","updated_at":"2026-01-08T22:19:40.818780961-05:00","closed_at":"2026-01-08T22:19:40.818780961-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-ag6","title":"Feature: Core E2E Test Suite","description":"# Feature: Core E2E Test Suite\n\n## Parent Epic\nmeow-qai: E2E Testing Infrastructure with Claude Simulator\n\n## Overview\n\nImplement the foundational E2E test suite covering the most critical orchestration behaviors. These tests validate that MEOW works correctly end-to-end.\n\n## Test Categories\n\n### 1. Happy Path Tests\n\nVerify basic workflow execution:\n\n```go\nfunc TestE2E_SimpleWorkflow(t *testing.T) {\n    // Single agent, single task, completes successfully\n}\n\nfunc TestE2E_MultiStepWorkflow(t *testing.T) {\n    // Single agent, multiple sequential tasks\n}\n\nfunc TestE2E_OutputChaining(t *testing.T) {\n    // Output from step 1 used by step 2\n}\n```\n\n### 2. Stop Hook Tests\n\nVerify the stop hook → meow prime → re-injection cycle:\n\n```go\nfunc TestE2E_StopHookFiresOnIdle(t *testing.T) {\n    // Simulator reaches prompt → stop hook fires\n    // Verifies: meow event agent-stopped called\n}\n\nfunc TestE2E_StopHookReturnsPrompt(t *testing.T) {\n    // Autonomous mode: meow prime returns current prompt\n    // Simulator receives prompt and continues\n}\n\nfunc TestE2E_StopHookReturnsEmpty_Interactive(t *testing.T) {\n    // Interactive mode: meow prime returns empty\n    // Simulator stays at prompt, waits for user\n}\n\nfunc TestE2E_StopHookRetry(t *testing.T) {\n    // Simulator fails first attempt\n    // Stop hook fires → meow prime returns prompt → retry\n    // Second attempt succeeds\n}\n```\n\n### 3. Output Validation Tests\n\nVerify output type checking and rejection:\n\n```go\nfunc TestE2E_OutputValidation_Success(t *testing.T) {\n    // Correct output types pass validation\n}\n\nfunc TestE2E_OutputValidation_WrongType(t *testing.T) {\n    // Wrong type rejected, agent can retry\n}\n\nfunc TestE2E_OutputValidation_MissingRequired(t *testing.T) {\n    // Missing required output rejected\n}\n\nfunc TestE2E_OutputValidation_FilePath(t *testing.T) {\n    // file_path type validates file exists\n}\n```\n\n### 4. Mode Tests\n\nVerify autonomous vs interactive modes:\n\n```go\nfunc TestE2E_Mode_Autonomous(t *testing.T) {\n    // Default mode: orchestrator re-injects on stop\n}\n\nfunc TestE2E_Mode_Interactive(t *testing.T) {\n    // Interactive: stays at prompt for human\n}\n\nfunc TestE2E_Mode_FireForget(t *testing.T) {\n    // fire_forget: step completes immediately after injection\n}\n```\n\n## Test File Organization\n\n```\ntest/e2e/\n├── happy_path_test.go      # Basic workflow tests\n├── stop_hook_test.go       # Stop hook behavior\n├── output_test.go          # Output validation\n├── mode_test.go            # Execution modes\n├── testdata/\n│   ├── templates/          # Test workflow templates\n│   │   ├── simple.meow.toml\n│   │   ├── multi-step.meow.toml\n│   │   ├── interactive.meow.toml\n│   │   └── output-validation.meow.toml\n│   └── configs/            # Simulator configs for specific tests\n│       ├── always-succeed.yaml\n│       ├── fail-then-succeed.yaml\n│       └── ask-question.yaml\n└── README.md               # Test documentation\n```\n\n## Test Workflow Templates\n\n### simple.meow.toml\n```toml\n[main]\nname = \"simple\"\n\n[main.variables]\nsim_config = { required = true }\n\n[[main.steps]]\nid = \"spawn\"\nexecutor = \"spawn\"\nagent = \"worker\"\nadapter = \"simulator\"\n\n[[main.steps]]\nid = \"task\"\nexecutor = \"agent\"\nagent = \"worker\"\nprompt = \"do the work\"\nneeds = [\"spawn\"]\n\n[main.steps.outputs]\nresult = { required = true, type = \"string\" }\n\n[[main.steps]]\nid = \"cleanup\"\nexecutor = \"kill\"\nagent = \"worker\"\nneeds = [\"task\"]\n```\n\n### output-validation.meow.toml\n```toml\n[main]\nname = \"output-validation\"\n\n[[main.steps]]\nid = \"spawn\"\nexecutor = \"spawn\"\nagent = \"worker\"\nadapter = \"simulator\"\n\n[[main.steps]]\nid = \"produce-output\"\nexecutor = \"agent\"\nagent = \"worker\"\nprompt = \"produce a number\"\nneeds = [\"spawn\"]\n\n[main.steps.outputs]\ncount = { required = true, type = \"number\" }\noptional_file = { required = false, type = \"file_path\" }\n\n[[main.steps]]\nid = \"cleanup\"\nexecutor = \"kill\"\nagent = \"worker\"\nneeds = [\"produce-output\"]\n```\n\n## Simulator Configs\n\n### always-succeed.yaml\n```yaml\ntiming:\n  startup_delay: 100ms\n  default_work_delay: 50ms\n\nbehaviors:\n  - match: \".*\"\n    action:\n      type: complete\n      outputs:\n        result: \"success\"\n```\n\n### fail-then-succeed.yaml\n```yaml\nbehaviors:\n  - match: \"do the work\"\n    action:\n      type: fail_then_succeed\n      fail_count: 1\n      fail_message: \"First attempt failed\"\n      success_outputs:\n        result: \"succeeded on retry\"\n```\n\n## Acceptance Criteria\n\n1. [ ] Happy path tests pass consistently\n2. [ ] Stop hook tests verify event emission\n3. [ ] Output validation tests cover all types\n4. [ ] Mode tests verify autonomous/interactive/fire_forget\n5. [ ] All tests complete in \u003c30 seconds total\n6. [ ] No flaky tests (run 10x without failure)\n\n## Dependencies\n\n- meow-gnf: E2E Test Framework\n\n## Test Execution\n\n```bash\n# Run all E2E tests\ngo test ./test/e2e/... -v\n\n# Run specific test file\ngo test ./test/e2e/stop_hook_test.go -v\n\n# Run with verbose simulator logging\nMEOW_SIM_LOG_LEVEL=debug go test ./test/e2e/... -v\n```\n\n## Reference\n\n- `docs/E2E-TESTING-DESIGN.md` - Section: Test Scenarios\n- `.meow/templates/test-stop-hook.meow.toml` - Existing stop hook test template","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T19:55:48.394626791-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:55:48.394626791-05:00","dependencies":[{"issue_id":"meow-ag6","depends_on_id":"meow-gnf","type":"blocks","created_at":"2026-01-09T19:55:53.827520285-05:00","created_by":"ubuntu"}]}
{"id":"meow-aga","title":"Epic: Concurrency Model Overhaul","description":"# Epic: Concurrency Model Overhaul\n\n## Context\n\nA comprehensive code review of the workflow file locking and mutex logic revealed a **critical architectural flaw** in MEOW's concurrency model. This epic tracks all work needed to fix these issues and harden the persistence layer.\n\n## Background: The Core Problem\n\nThe MEOW orchestrator currently has **two independent code paths** for handling IPC messages from agents:\n\n1. **IPCHandler** (`internal/orchestrator/ipc_handler.go`) - Used by the IPC server, has NO mutex\n2. **Orchestrator.handleIPC** (`internal/orchestrator/orchestrator.go`) - Has mutex, but NEVER CALLED\n\nLooking at `cmd/meow/cmd/run.go`:\n\\`\\`\\`go\n// Creates orchestrator with its own IPC channel and mutex\norch := orchestrator.New(cfg, store, agentManager, ...)\n\n// Creates SEPARATE IPC handler that talks directly to store\nipcHandler := orchestrator.NewIPCHandler(store, agentManager, ...)\n\n// IPC server uses the handler, NOT the orchestrator's channel\nipcServer := ipc.NewServer(workflowID, ipcHandler, ...)\n\\`\\`\\`\n\nThe orchestrator creates an \\`ipcChan\\` but it's never connected. IPC messages go directly to IPCHandler which has no coordination with the orchestrator's main loop.\n\n## Impact\n\nThese issues directly threaten MEOW's core value proposition:\n\n1. **Durable Execution Violated:** Race conditions can lose step completions\n2. **Single Writer Violated:** The spec promises orchestrator is \"single writer to workflow state file\" \n3. **Agent Contract Broken:** If \\`meow done\\` is silently lost, agents think work is complete but workflow stalls\n\n## Related Documentation\n\n- Full analysis: \\`docs/CONCURRENCY-ANALYSIS.md\\`\n- MVP Spec: \\`docs/MVP-SPEC-v2.md\\` §8, §10, §11\n\n## Tasks in This Epic\n\n| Bead ID | Title | Priority | Depends On |\n|---------|-------|----------|------------|\n| **meow-ilr** | CRITICAL: Unify IPC handling with orchestrator coordination | P0 | - |\n| **meow-ji8** | Remove/simplify merge logic after IPC unification | P1 | meow-ilr |\n| **meow-cta** | Consolidate lock strategy and remove dead StatePersister code | P2 | - |\n| **meow-si8** | Add fsync for durable atomic writes | P3 | - |\n| **meow-c0w** | Add temp file validation in crash recovery | P3 | - |\n\n## Dependency Graph\n\n\\`\\`\\`\nmeow-ilr (P0 - CRITICAL)\n    │\n    └──► meow-ji8 (P1 - blocked until IPC unified)\n\nmeow-cta (P2 - independent)\nmeow-si8 (P3 - independent)  \nmeow-c0w (P3 - independent)\n\\`\\`\\`\n\n## Recommended Execution Order\n\n1. **meow-ilr** - Critical, fixes the race condition\n2. **meow-ji8** - Cleanup after meow-ilr\n3. **meow-cta** - Can be done any time, reduces confusion\n4. **meow-si8** and **meow-c0w** - Low priority, can be batched\n\n## Success Criteria\n\n- [ ] Single code path for all workflow state mutations\n- [ ] All store operations protected by mutex\n- [ ] No lost updates under concurrent \\`meow done\\` calls\n- [ ] Clean lock strategy with no dead code\n- [ ] Hardened persistence layer\n\n## Non-Goals\n\n- Distributed orchestration (future work)\n- Multi-workflow orchestrator mode (separate epic)","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-09T19:49:04.694321061-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:52:01.44907756-05:00"}
{"id":"meow-ako","title":"Implement parallel iteration with max_concurrent","description":"Implement parallel execution with concurrency limiting.\n\nWhen parallel=true (default):\n- All iterations can run concurrently\n- If max_concurrent is set, limit concurrent running iterations\n- Track how many iterations are currently running\n- Only start new iteration when running count \u003c max_concurrent\n- Orchestrator main loop should respect this limit when finding ready steps","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:35.529470432-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:35.529470432-05:00","dependencies":[{"issue_id":"meow-ako","depends_on_id":"meow-mfr","type":"blocks","created_at":"2026-01-09T15:04:18.583778175-05:00","created_by":"ubuntu"}]}
{"id":"meow-ao5","title":"Implement module parsing","description":"Two-phase TOML parsing for dynamic [workflow-name] sections. See IMPLEMENTATION-PLAN section meow-modules-parser-parse.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:36.123911948-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Module parsing implementation is complete. Two-phase TOML parsing for dynamic [workflow-name] sections is fully implemented in internal/template/module.go with comprehensive tests in mvp_test.go. All 108 template tests pass.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-aqt","title":"Implement statusline-based context tracking for MEOW agents","description":"Create a reliable mechanism for MEOW to track Claude agent context usage by intercepting the statusline hook data rather than screen-scraping tmux.\n\n## Background\n\nCurrently the context monitor in lib/claude-utils.meow.toml uses fragile tmux screen-scraping:\n```bash\ntmux capture-pane -p -t \"$SESSION\" -S -100 | grep -oE '[0-9]+k/[0-9]+k \\([0-9]+%\\)'\n```\n\nThis is problematic because:\n1. Only works if user has statusline configured with context display\n2. Depends on exact statusline output format (user-specific)\n3. May not be visible if scrolled off screen\n4. Race conditions with statusline updates\n\n## The Solution\n\nClaude Code already passes exact context data to the statusline hook via stdin JSON:\n```json\n{\n  \"session_id\": \"0361084b-...\",\n  \"transcript_path\": \"/home/ubuntu/.claude/projects/.../session.jsonl\",\n  \"current_usage\": 144975,  // Direct token count (v2.0.70+)\n  \"exceeds_200k_tokens\": false\n}\n```\n\nWe can intercept this data and write it to a known location per-agent.\n\n## Implementation\n\n### 1. Create MEOW statusline wrapper\n\nFile: `~/.meow/adapters/claude/statusline-interceptor.sh`\n\n```bash\n#!/bin/bash\n# MEOW Statusline Interceptor\n# Captures context data from Claude Code and writes to per-agent file\n# Then forwards to user's original statusline\n\ninput=$(cat)\n\n# Extract context data\nsession_id=$(echo \"$input\" | jq -r '.session_id // empty')\ncurrent_usage=$(echo \"$input\" | jq -r '.current_usage // empty')\ntranscript_path=$(echo \"$input\" | jq -r '.transcript_path // empty')\n\n# If running under MEOW orchestration, write context to known location\nif [[ -n \"$MEOW_WORKFLOW\" \u0026\u0026 -n \"$MEOW_AGENT\" ]]; then\n    CONTEXT_FILE=\"/tmp/meow-context-${MEOW_WORKFLOW}-${MEOW_AGENT}\"\n    \n    # Write current usage if available (v2.0.70+)\n    if [[ -n \"$current_usage\" \u0026\u0026 \"$current_usage\" != \"null\" ]]; then\n        echo \"$current_usage\" \u003e \"$CONTEXT_FILE\"\n    elif [[ -n \"$transcript_path\" \u0026\u0026 -f \"$transcript_path\" ]]; then\n        # Fallback: calculate from transcript\n        total=$(tail -20 \"$transcript_path\" | jq -s '\n            map(select(.type == \"assistant\" and .message.usage != null)) |\n            last | .message.usage |\n            (.input_tokens // 0) + (.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0)\n        ' 2\u003e/dev/null)\n        [[ -n \"$total\" \u0026\u0026 \"$total\" != \"null\" ]] \u0026\u0026 echo \"$total\" \u003e \"$CONTEXT_FILE\"\n    fi\nfi\n\n# Forward to user's original statusline (if exists)\nORIGINAL_STATUSLINE=\"${MEOW_ORIGINAL_STATUSLINE:-}\"\nif [[ -n \"$ORIGINAL_STATUSLINE\" \u0026\u0026 -x \"$ORIGINAL_STATUSLINE\" ]]; then\n    echo \"$input\" | \"$ORIGINAL_STATUSLINE\"\nelse\n    # Default: just output empty (no statusline configured)\n    echo \"\"\nfi\n```\n\n### 2. Update adapter setup to install interceptor\n\nWhen MEOW spawns a Claude agent, the adapter setup should:\n1. Backup user's current statusline command\n2. Install the interceptor as the statusline\n3. Set MEOW_ORIGINAL_STATUSLINE env var to chain to original\n\nFile: `~/.meow/adapters/claude/setup.sh` (update)\n\n```bash\n# ... existing setup ...\n\n# Install statusline interceptor for context tracking\nsetup_statusline_interceptor() {\n    local worktree=\"$1\"\n    local settings_file=\"$worktree/.claude/settings.json\"\n    \n    # Read current statusline config\n    if [[ -f \"$settings_file\" ]]; then\n        current_statusline=$(jq -r '.statusLine.command // empty' \"$settings_file\")\n        \n        # Backup original if not already our interceptor\n        if [[ -n \"$current_statusline\" \u0026\u0026 ! \"$current_statusline\" =~ \"statusline-interceptor\" ]]; then\n            export MEOW_ORIGINAL_STATUSLINE=\"$current_statusline\"\n        fi\n    fi\n    \n    # Update settings to use interceptor\n    mkdir -p \"$worktree/.claude\"\n    jq '.statusLine = {\"type\": \"command\", \"command\": \"bash ~/.meow/adapters/claude/statusline-interceptor.sh\"}' \\\n        \"$settings_file\" \u003e \"$settings_file.tmp\" \u0026\u0026 mv \"$settings_file.tmp\" \"$settings_file\"\n}\n```\n\n### 3. Update lib/claude-utils.meow.toml context monitor\n\nReplace the screen-scraping shell command with file reading:\n\n```toml\n[[check-and-maybe-compact.steps]]\nid = \"get-context\"\nexecutor = \"shell\"\ncommand = \"\"\"\nCONTEXT_FILE=\"/tmp/meow-context-${MEOW_WORKFLOW}-{{agent}}\"\nif [[ -f \"$CONTEXT_FILE\" ]]; then\n    TOKENS=$(cat \"$CONTEXT_FILE\")\n    # Calculate percentage (200k context window)\n    echo \"$((TOKENS * 100 / 200000))\"\nelse\n    echo \"0\"\nfi\n\"\"\"\n```\n\n### 4. Cleanup on agent kill\n\nAdd cleanup to remove context files when agent is killed:\n\n```bash\n# In kill executor or cleanup script\nrm -f \"/tmp/meow-context-${MEOW_WORKFLOW}-${MEOW_AGENT}\" 2\u003e/dev/null\n```\n\n## Files to Create/Modify\n\n1. `~/.meow/adapters/claude/statusline-interceptor.sh` - New interceptor script\n2. `~/.meow/adapters/claude/setup.sh` - Update to install interceptor\n3. `lib/claude-utils.meow.toml` - Update context monitor to read from file\n\n## Acceptance Criteria\n\n- [ ] Statusline interceptor captures context data from Claude Code JSON\n- [ ] Context written to /tmp/meow-context-{workflow}-{agent} per agent\n- [ ] Works with current_usage field (v2.0.70+)\n- [ ] Falls back to transcript parsing for older versions\n- [ ] Chains to user's original statusline (preserves their display)\n- [ ] Context monitor template reads from file instead of screen-scraping\n- [ ] Context files cleaned up when agent killed\n- [ ] Works in multi-agent scenarios (each agent has own file)\n\n## Testing\n\n1. Spawn a Claude agent with MEOW\n2. Verify /tmp/meow-context-* file is created and updated\n3. Verify context percentage matches statusline display\n4. Verify user's original statusline still works\n5. Kill agent, verify context file is removed\n\n## Dependencies\n\n- Requires claude adapter to be implemented (meow-354.3)\n- Should update lib/claude-utils.meow.toml after implementation","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T16:06:40.133739595-05:00","created_by":"ubuntu","updated_at":"2026-01-09T16:06:40.133739595-05:00","dependencies":[{"issue_id":"meow-aqt","depends_on_id":"meow-354.3","type":"blocks","created_at":"2026-01-09T16:06:47.277469425-05:00","created_by":"ubuntu"}]}
{"id":"meow-b8e93fc4","title":"Final verification","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881513221-05:00","updated_at":"2026-01-08T03:03:02.837518938-05:00","closed_at":"2026-01-08T03:03:02.837518938-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-b91","title":"Implement output validation with file_path scope","description":"# Implement Output Validation with file_path Scope\n\n## File: internal/orchestrator/validation.go\n\n## Purpose\n\nValidate agent outputs against their definitions. Key addition: file_path type validates against the agent's working directory.\n\n## Output Types\n\n| Type | Validation |\n|------|------------|\n| string | Non-empty string |\n| number | Parseable as int or float |\n| boolean | \\`true\\` or \\`false\\` (case-insensitive) |\n| json | Valid JSON |\n| file_path | File exists on filesystem |\n\n## File Path Validation Scope\n\n- **Absolute paths** are validated directly\n- **Relative paths** are resolved against the **agent's working directory**\n- The orchestrator tracks each agent's workdir from its spawn step\n\n## Implementation\n\n\\`\\`\\`go\npackage orchestrator\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strconv\"\n    \"strings\"\n    \n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// OutputValidator validates agent outputs against their definitions.\ntype OutputValidator struct {\n    agentWorkdirs map[string]string // agent ID -\u003e working directory\n}\n\n// NewOutputValidator creates a validator.\nfunc NewOutputValidator() *OutputValidator {\n    return \u0026OutputValidator{\n        agentWorkdirs: make(map[string]string),\n    }\n}\n\n// SetAgentWorkdir records an agent's working directory.\n// Called when spawn step completes.\nfunc (v *OutputValidator) SetAgentWorkdir(agentID, workdir string) {\n    v.agentWorkdirs[agentID] = workdir\n}\n\n// ValidationError describes a validation failure.\ntype ValidationError struct {\n    Field   string\n    Type    string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    return fmt.Sprintf(\"output %s (%s): %s\", e.Field, e.Type, e.Message)\n}\n\n// ValidateOutputs checks outputs against step's output definitions.\nfunc (v *OutputValidator) ValidateOutputs(\n    outputs map[string]any,\n    defs map[string]types.OutputDef,\n    agentID string,\n) []error {\n    var errs []error\n    \n    // Check required outputs are present\n    for name, def := range defs {\n        value, exists := outputs[name]\n        \n        if !exists {\n            if def.Required {\n                errs = append(errs, \u0026ValidationError{\n                    Field:   name,\n                    Type:    def.Type,\n                    Message: \"required output not provided\",\n                })\n            }\n            continue\n        }\n        \n        // Validate type\n        if err := v.validateType(name, value, def.Type, agentID); err != nil {\n            errs = append(errs, err)\n        }\n    }\n    \n    return errs\n}\n\nfunc (v *OutputValidator) validateType(name string, value any, typ string, agentID string) error {\n    strVal := fmt.Sprintf(\"%v\", value)\n    \n    switch typ {\n    case \"string\":\n        if strVal == \"\" {\n            return \u0026ValidationError{name, typ, \"empty string\"}\n        }\n        \n    case \"number\":\n        if _, err := strconv.ParseFloat(strVal, 64); err != nil {\n            return \u0026ValidationError{name, typ, \"not a valid number\"}\n        }\n        \n    case \"boolean\":\n        lower := strings.ToLower(strVal)\n        if lower != \"true\" \u0026\u0026 lower != \"false\" {\n            return \u0026ValidationError{name, typ, \"must be true or false\"}\n        }\n        \n    case \"json\":\n        var js json.RawMessage\n        if err := json.Unmarshal([]byte(strVal), \u0026js); err != nil {\n            return \u0026ValidationError{name, typ, \"invalid JSON: \" + err.Error()}\n        }\n        \n    case \"file_path\":\n        path := strVal\n        \n        // Resolve relative paths against agent's workdir\n        if !filepath.IsAbs(path) {\n            workdir, ok := v.agentWorkdirs[agentID]\n            if !ok {\n                return \u0026ValidationError{name, typ, \"no workdir known for agent \" + agentID}\n            }\n            path = filepath.Join(workdir, path)\n        }\n        \n        if _, err := os.Stat(path); err != nil {\n            if os.IsNotExist(err) {\n                return \u0026ValidationError{name, typ, \"file does not exist: \" + strVal}\n            }\n            return \u0026ValidationError{name, typ, \"cannot access file: \" + err.Error()}\n        }\n        \n    default:\n        // Unknown type - treat as string\n    }\n    \n    return nil\n}\n\n// FormatValidationErrors creates a user-friendly error message.\nfunc FormatValidationErrors(errs []error, defs map[string]types.OutputDef) string {\n    var sb strings.Builder\n    sb.WriteString(\"Error: Invalid outputs\\n\\n\")\n    \n    for _, err := range errs {\n        sb.WriteString(fmt.Sprintf(\"  ✗ %s\\n\", err.Error()))\n    }\n    \n    sb.WriteString(\"\\nRequired outputs:\\n\")\n    for name, def := range defs {\n        if def.Required {\n            sb.WriteString(fmt.Sprintf(\"  - %s (%s)\", name, def.Type))\n            if def.Description != \"\" {\n                sb.WriteString(\": \" + def.Description)\n            }\n            sb.WriteString(\"\\n\")\n        }\n    }\n    \n    return sb.String()\n}\n\\`\\`\\`\n\n## Integration with Orchestrator\n\n\\`\\`\\`go\n// In spawn executor\nfunc (e *SpawnExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    // ... spawn agent ...\n    \n    // Record workdir for file_path validation\n    e.validator.SetAgentWorkdir(step.Spawn.Agent, step.Spawn.Workdir)\n    \n    // ...\n}\n\n// In handleStepCompletion\nfunc (o *Orchestrator) handleStepCompletion(msg StepDoneMessage) {\n    step := wf.Steps[msg.Step]\n    \n    if step.Agent != nil \u0026\u0026 step.Agent.Outputs != nil {\n        errs := o.validator.ValidateOutputs(msg.Outputs, step.Agent.Outputs, msg.Agent)\n        if len(errs) \u003e 0 {\n            // Send error back to agent\n            errorMsg := FormatValidationErrors(errs, step.Agent.Outputs)\n            o.sendError(msg.Agent, errorMsg)\n            \n            // Keep step running (agent will retry)\n            step.Status = types.StepStatusRunning\n            return\n        }\n    }\n    \n    // Validation passed\n    step.Complete(msg.Outputs)\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] OutputValidator with type validation\n- [ ] string: non-empty check\n- [ ] number: ParseFloat validation\n- [ ] boolean: case-insensitive true/false\n- [ ] json: valid JSON check\n- [ ] file_path: existence check with workdir resolution\n- [ ] SetAgentWorkdir for file_path scope\n- [ ] FormatValidationErrors for user-friendly messages\n- [ ] Unit tests for each type\n- [ ] Unit tests for file_path with relative/absolute paths\n- [ ] Integration with step completion flow","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T20:28:55.908902702-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:35.283848223-05:00","closed_at":"2026-01-08T22:14:35.283848223-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These features will be implemented as part of the new orchestrator architecture.","dependencies":[{"issue_id":"meow-b91","depends_on_id":"pivot-104","type":"blocks","created_at":"2026-01-08T20:29:48.547456728-05:00","created_by":"ubuntu"},{"issue_id":"meow-b91","depends_on_id":"meow-104","type":"blocks","created_at":"2026-01-08T20:29:48.547456728-05:00","created_by":"ubuntu"},{"issue_id":"meow-b91","depends_on_id":"meow-0h7","type":"blocks","created_at":"2026-01-08T20:29:48.644275494-05:00","created_by":"ubuntu"}]}
{"id":"meow-b9299e98","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"test-hello2","created_at":"2026-01-08T03:44:17.019993792-05:00","updated_at":"2026-01-08T22:19:40.830988378-05:00","closed_at":"2026-01-08T22:19:40.830988378-05:00","close_reason":"Old test beads - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-bba","title":"Add wisp tracking fields to Bead struct","description":"Add workflow metadata fields AND new bead types to MEOW's internal Bead struct.\n\n**Context**: Per the overlay approach (no beads fork), MEOW defines its own `Bead` type in `internal/types/bead.go`. This type serializes to JSON and is written to the shared `.beads/issues.jsonl` file. Upstream `bd` CLI will preserve but ignore MEOW-specific fields.\n\n**CONSOLIDATED**: Now includes meow-1l1 (collaborative type) and meow-x9z (gate type).\n\n## Fields to Add\n\n```go\ntype Bead struct {\n    // ... existing fields ...\n    \n    // MEOW-specific: Explicit tier (ignored by upstream bd)\n    Tier          BeadTier       `json:\"tier,omitempty\"`           // work | wisp | orchestrator\n    \n    // MEOW-specific: Workflow tracking (ignored by upstream bd)\n    HookBead       string        `json:\"hook_bead,omitempty\"`      // Work bead this wisp implements\n    SourceWorkflow string        `json:\"source_workflow,omitempty\"` // Workflow that created this\n    WorkflowID     string        `json:\"workflow_id,omitempty\"`    // Unique workflow instance ID\n    \n    // Optional heartbeat\n    LastSeen       time.Time     `json:\"last_seen,omitempty\"`      // Agent heartbeat timestamp\n}\n\ntype BeadTier string\n\nconst (\n    TierWork        BeadTier = \"work\"        // Permanent deliverables  \n    TierWisp        BeadTier = \"wisp\"        // Agent workflow steps (ephemeral)\n    TierOrchestrator BeadTier = \"orchestrator\" // Infrastructure machinery (ephemeral)\n)\n```\n\n## Bead Types (8 total - was 6)\n\n```go\nconst (\n    // Agent-executable\n    BeadTypeTask          BeadType = \"task\"          // Agent does work, auto-continues\n    BeadTypeCollaborative BeadType = \"collaborative\" // Agent + human conversation, pauses\n    BeadTypeGate          BeadType = \"gate\"          // Human approval point (no assignee)\n    \n    // Orchestrator-executable  \n    BeadTypeStart     BeadType = \"start\"\n    BeadTypeStop      BeadType = \"stop\"\n    BeadTypeCondition BeadType = \"condition\"\n    BeadTypeCode      BeadType = \"code\"\n    BeadTypeExpand    BeadType = \"expand\"\n)\n```\n\n## Type-Specific Validation Rules\n\n**collaborative**:\n- MUST have assignee (agent runs the conversation)\n- Auto-continue: NO (meow prime returns empty for in-progress)\n- Tier: wisp (if in ephemeral workflow) or work\n\n**gate**:\n- MUST NOT have assignee (human-facing, not agent-facing)\n- Auto-continue: NO\n- Tier: always orchestrator\n\n## JSON Interoperability\n\nWhen serialized to `issues.jsonl`:\n```json\n{\n  \"id\": \"meow-abc.load-context\",\n  \"title\": \"Load context for bd-task-123\",\n  \"status\": \"open\",\n  \"tier\": \"wisp\",\n  \"hook_bead\": \"bd-task-123\",\n  \"source_workflow\": \"implement-tdd\",\n  \"workflow_id\": \"meow-abc\"\n}\n```\n\nUpstream `bd` will:\n- ✅ Read and display `id`, `title`, `status`\n- ✅ Preserve `tier`, `hook_bead`, etc. when modifying\n- ❌ Not understand MEOW-specific fields (but won't break)\n\n## File Location\nModify: `internal/types/bead.go`\n\n## Acceptance Criteria\n- [ ] BeadTier enum defined with work/wisp/orchestrator\n- [ ] Tier field added to Bead struct with `omitempty`\n- [ ] HookBead, SourceWorkflow, WorkflowID fields added with `omitempty`\n- [ ] BeadTypeCollaborative added with validation (must have assignee)\n- [ ] BeadTypeGate added with validation (must NOT have assignee)\n- [ ] Valid() updated for all 8 types\n- [ ] JSON round-trip test (serialize → deserialize preserves all fields)\n- [ ] Unit tests for tier and type validation","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:52.992979411-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented minimal viable slice: module parser, tier tracking, and meow prime command","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-bc3","title":"orchestrator.go: expandInlineSteps() doesn't set Tier field","description":"## Location\n`internal/orchestrator/orchestrator.go:836-846`\n\n## Problem\nInline beads created by the orchestrator's `expandInlineSteps()` are missing the Tier field:\n\n```go\nbead := \u0026types.Bead{\n    ID:           beadID,\n    Type:         beadType,\n    Title:        step.Description,\n    Description:  step.Instructions,\n    Instructions: step.Instructions,\n    Status:       types.BeadStatusOpen,\n    Needs:        needs,\n    Parent:       parentBead.ID,\n    CreatedAt:    time.Now(),\n    // Missing: Tier field\n}\n```\n\n## Impact\n- Inline beads have empty tier string\n- Breaks tier-based filtering in `meow prime`\n- Affects orchestrator priority sorting (defaults to work tier priority)\n\n## Relationship\nSimilar to the BakeInline() issue in baker.go - both create inline beads without Tier.\n\n## Fix\nSet appropriate tier (likely TierWisp for inline condition beads):\n```go\nTier: types.TierWisp,\n```\n\n## Severity\nMEDIUM - Affects tier filtering for condition-generated beads","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:04.675626132-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:33:01.84401074-05:00","closed_at":"2026-01-08T02:33:01.84401074-05:00","close_reason":"Fixed in commit 5ea5226. Added Tier: types.TierWisp to bead struct in expandInlineSteps()."}
{"id":"meow-byi","title":"Implement meow handoff command","description":"## Current State\n\nThe `meow handoff` command is a stub that prints \"not yet implemented\".\n\n## Required Functionality\n\nRequest context refresh/handoff for an agent:\n\n```bash\nmeow handoff --notes \"Stopping for context refresh\"\n# Triggers handoff workflow:\n# 1. Saves current progress notes\n# 2. Triggers refresh template\n```\n\n## Per MVP Spec\n\nFrom handoff template pattern:\n1. Agent writes notes to current bead\n2. Agent triggers handoff\n3. Creates handoff record and stops session\n4. New session sees notes via meow prime\n\n## File\n`cmd/meow/cmd/handoff.go`\n\n## Acceptance Criteria\n- [ ] Updates current bead with handoff notes\n- [ ] Triggers refresh workflow if configured\n- [ ] Records handoff in agent state","status":"closed","priority":2,"issue_type":"task","assignee":"agent3","created_at":"2026-01-08T03:04:50.982975891-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:31.018182083-05:00","closed_at":"2026-01-08T03:27:31.018182083-05:00","close_reason":"Closed","labels":["agents","cli"]}
{"id":"meow-c0w","title":"Add temp file validation in crash recovery","description":"# Add Temp File Validation in Crash Recovery\n\n## Summary\n\nThe crash recovery logic in \\`recoverInterruptedWrites()\\` promotes temp files to main files without validating they contain valid YAML. A corrupted temp file could replace valid state.\n\n## Current Implementation\n\n\\`\\`\\`go\n// yamlstore.go:60-84\nfunc recoverInterruptedWrites(dir string) error {\n    entries, err := os.ReadDir(dir)\n    // ...\n    \n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml.tmp\") {\n            continue\n        }\n        \n        tmpPath := filepath.Join(dir, entry.Name())\n        mainPath := strings.TrimSuffix(tmpPath, \".tmp\")\n        \n        if _, err := os.Stat(mainPath); err == nil {\n            // Main file exists, delete orphan temp\n            os.Remove(tmpPath)\n        } else {\n            // Main file missing, promote temp\n            os.Rename(tmpPath, mainPath)  // NO VALIDATION!\n        }\n    }\n    return nil\n}\n\\`\\`\\`\n\n## The Problem\n\nIf a write was interrupted mid-write, the temp file could be:\n- **Truncated:** Partial YAML, missing closing braces\n- **Corrupted:** Invalid UTF-8 or malformed YAML\n- **Empty:** 0 bytes if crash happened before any write\n\nPromoting such a file means the workflow is unrecoverable.\n\n## Scenario\n\n\\`\\`\\`\nT0: Save() starts, creates wf-abc.yaml.tmp\nT1: Write() writes first 50% of data\nT2: Power failure (or SIGKILL, OOM, etc.)\nT3: Temp file exists with partial data, main file doesn't exist\nT4: On restart, recoverInterruptedWrites() runs\nT5: Main file doesn't exist → Promote temp to main\nT6: Workflow state is corrupted/incomplete\n\\`\\`\\`\n\n## The Fix\n\nValidate temp files before promotion:\n\n\\`\\`\\`go\nfunc recoverInterruptedWrites(dir string) error {\n    entries, err := os.ReadDir(dir)\n    if err != nil {\n        return err\n    }\n\n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml.tmp\") {\n            continue\n        }\n\n        tmpPath := filepath.Join(dir, entry.Name())\n        mainPath := strings.TrimSuffix(tmpPath, \".tmp\")\n\n        // Check if main file exists\n        if _, err := os.Stat(mainPath); err == nil {\n            // Main file exists, temp is orphan - delete it\n            os.Remove(tmpPath)\n            continue\n        }\n\n        // Main file missing - validate temp before promotion\n        data, err := os.ReadFile(tmpPath)\n        if err != nil {\n            // Can't read temp - delete it\n            slog.Warn(\"removing unreadable temp file\", \"path\", tmpPath, \"error\", err)\n            os.Remove(tmpPath)\n            continue\n        }\n\n        // Check for empty file\n        if len(data) == 0 {\n            slog.Warn(\"removing empty temp file\", \"path\", tmpPath)\n            os.Remove(tmpPath)\n            continue\n        }\n\n        // Validate YAML structure\n        var wf types.Workflow\n        if err := yaml.Unmarshal(data, \u0026wf); err != nil {\n            slog.Warn(\"removing invalid temp file\", \"path\", tmpPath, \"error\", err)\n            os.Remove(tmpPath)\n            continue\n        }\n\n        // Validate required fields\n        if wf.ID == \"\" {\n            slog.Warn(\"removing temp file with missing ID\", \"path\", tmpPath)\n            os.Remove(tmpPath)\n            continue\n        }\n\n        // Valid - promote\n        slog.Info(\"recovering workflow from temp file\", \"path\", tmpPath, \"id\", wf.ID)\n        if err := os.Rename(tmpPath, mainPath); err != nil {\n            slog.Error(\"failed to promote temp file\", \"path\", tmpPath, \"error\", err)\n        }\n    }\n    return nil\n}\n\\`\\`\\`\n\n## Edge Cases\n\n1. **Valid temp, valid main (both exist):** Keep main, delete temp (already handled)\n2. **Valid temp, no main:** Promote temp (with validation)\n3. **Invalid temp, no main:** Delete temp, workflow is lost (log warning)\n4. **Invalid temp, valid main:** Delete temp (already handled)\n\nFor case 3, the workflow is lost - but that's better than corrupted state. The alternative is an orchestrator that crashes on startup trying to load invalid YAML.\n\n## Files to Modify\n\n- \\`internal/orchestrator/yamlstore.go\\` - Add validation to recoverInterruptedWrites()\n- \\`internal/orchestrator/yamlstore_test.go\\` - Add tests for validation\n\n## Acceptance Criteria\n\n- [ ] Empty temp files are deleted, not promoted\n- [ ] Invalid YAML temp files are deleted, not promoted\n- [ ] Valid temp files are promoted\n- [ ] Warnings logged for deleted temp files\n- [ ] Tests for each validation case\n\n## Test Cases\n\n\\`\\`\\`go\nfunc TestRecoverInterruptedWrites_EmptyTemp(t *testing.T) {\n    // Create empty .yaml.tmp file\n    // Run recovery\n    // Verify temp deleted, no main created\n}\n\nfunc TestRecoverInterruptedWrites_TruncatedYAML(t *testing.T) {\n    // Create temp with \"id: wf-abc\\nstatus: run\" (truncated)\n    // Run recovery\n    // Verify temp deleted\n}\n\nfunc TestRecoverInterruptedWrites_ValidTemp(t *testing.T) {\n    // Create valid temp file\n    // Run recovery\n    // Verify temp promoted to main\n}\n\nfunc TestRecoverInterruptedWrites_MissingID(t *testing.T) {\n    // Create temp with valid YAML but no ID field\n    // Run recovery\n    // Verify temp deleted\n}\n\\`\\`\\`\n\n## Dependencies\n\nNone - can be done independently.\n\n## Related\n\n- Parent epic: meow-aga\n- Related: meow-si8 (fsync - prevents some of these scenarios)\n- Analysis: docs/CONCURRENCY-ANALYSIS.md \"Low Issue: Temp File Promotion Without Validation\"","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-09T19:51:41.101061771-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:51:41.101061771-05:00"}
{"id":"meow-c32","title":"Add tier-based filtering to bead queries","description":"BeadStore methods for filtered queries by Tier field per SPEC-ADDENDUM.\n\n## Key Change: Tier Field, Not Labels\n\nFilter on explicit `Tier` field for O(1) comparison:\n\n```go\n// Filter by tier field directly\nfilter := BeadFilter{\n    Tier: TierWisp,\n    Assignee: agentID,\n}\n\n// NOT label scanning\n// BAD: Labels: []string{\"meow:wisp\"}\n```\n\n## Methods to Update\n\n```go\ntype BeadStore interface {\n    // Existing...\n    \n    // Add tier-aware filtering\n    ListByTier(ctx context.Context, tier BeadTier) ([]*types.Bead, error)\n    GetReadyByTier(ctx context.Context, tier BeadTier) ([]*types.Bead, error)\n    \n    // Generic filter with tier support\n    List(ctx context.Context, filter BeadFilter) ([]*types.Bead, error)\n}\n\ntype BeadFilter struct {\n    Tier         *BeadTier\n    ExcludeTiers []BeadTier\n    Status       *BeadStatus\n    Assignee     *string\n    WorkflowID   *string\n    HookBead     *string\n}\n```\n\n## Performance\n\n- **Before**: O(n * labels) to scan labels for tier\n- **After**: O(n) with direct field comparison\n\n## File Location\nModify: `internal/orchestrator/beadstore.go`\n\n## Acceptance Criteria\n- [ ] BeadFilter supports Tier field\n- [ ] ExcludeTiers for negative filtering\n- [ ] Direct field comparison (no label scanning)\n- [ ] Unit tests for tier filtering","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.607344386-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Query implementation is part of the unified filtering implementation.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-c6x","title":"Implement _failed_step context variables","description":"Implement the _failed_step context for recovery templates.\n\nWhen expanding a recovery template, inject these variables:\n- _failed_step.id: ID of the failed step\n- _failed_step.executor: executor type\n- _failed_step.error_type: error classification\n- _failed_step.error_message: human-readable message\n- _failed_step.started_at: when step started\n- _failed_step.duration: how long it ran\n- _failed_step.retries: recovery attempt count\n- _failed_step.agent: agent ID (for agent steps)\n- _failed_step.prompt: original prompt (for agent steps)\n\nStore these in a special variable namespace accessible during substitution.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:28.272585862-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:28.272585862-05:00","dependencies":[{"issue_id":"meow-c6x","depends_on_id":"meow-ljo","type":"blocks","created_at":"2026-01-09T15:04:09.155720804-05:00","created_by":"ubuntu"},{"issue_id":"meow-c6x","depends_on_id":"meow-cql","type":"blocks","created_at":"2026-01-09T15:04:09.270276595-05:00","created_by":"ubuntu"}]}
{"id":"meow-cac","title":"CRITICAL: Minimal vertical slice - validate architecture end-to-end","description":"## Purpose\n\nValidate the three-tier architecture works end-to-end BEFORE implementing all edge cases. This is a focused integration test, not production code.\n\n## The Slice\n\nImplement the **smallest possible working flow**:\n\n```\nSimple module → Parse → Bake with tiers → meow prime shows wisps\n```\n\n### Input: Minimal Test Module\n\n```toml\n# test-slice.meow.toml\n\n[main]\nname = \"test-slice\"\ndescription = \"Minimal vertical slice test\"\nephemeral = true\nhooks_to = \"work_bead\"\n\n[main.variables]\nwork_bead = { required = true, type = \"bead_id\" }\nagent = { required = true, type = \"string\" }\n\n[[main.steps]]\nid = \"step-1\"\ntype = \"task\"\ntitle = \"First wisp step\"\nassignee = \"{{agent}}\"\ninstructions = \"Do the first thing\"\n\n[[main.steps]]\nid = \"step-2\" \ntype = \"task\"\ntitle = \"Second wisp step\"\nassignee = \"{{agent}}\"\nneeds = [\"step-1\"]\ninstructions = \"Do the second thing\"\n```\n\n### Expected Output from `meow prime`\n\n```\n═══════════════════════════════════════════════════════════════\nYour workflow: test-slice (step 1/2)\nWork bead: gt-test-123 \"Test work bead\"\n═══════════════════════════════════════════════════════════════\n\n  → step-1 [in_progress] ← YOU ARE HERE\n  ○ step-2\n\n───────────────────────────────────────────────────────────────\nInstructions:\n  Do the first thing\n───────────────────────────────────────────────────────────────\n```\n\n## Implementation Steps\n\n1. **Module parsing** (use existing parser, extend minimally)\n   - Detect module format (has workflow sections, no [meta])\n   - Parse [main] workflow with steps\n   - Parse variables and hooks_to\n\n2. **Baking with tiers** (extend Baker)\n   - Set Tier = TierWisp for tasks in ephemeral workflow\n   - Set HookBead from hooks_to variable\n   - Set SourceWorkflow and WorkflowID\n\n3. **meow prime output** (new implementation)\n   - Filter beads by Tier = TierWisp AND Assignee = current agent\n   - Format as workflow progression view\n   - Show linked work bead\n\n4. **Integration test**\n   - End-to-end test that:\n     a. Creates a work bead\n     b. Parses the test module\n     c. Bakes with work_bead variable\n     d. Verifies beads have correct tiers\n     e. Calls prime and verifies output format\n\n## What This Validates\n\n- [ ] Module format detection works\n- [ ] Workflow parsing captures ephemeral and hooks_to\n- [ ] Baker correctly sets Tier field based on ephemeral\n- [ ] Baker correctly sets HookBead from hooks_to\n- [ ] Prime filters by tier and formats correctly\n- [ ] Three-tier separation actually works\n\n## What This Does NOT Include\n\n- Legacy format support (separate task)\n- Local references (.implement syntax)\n- External references (file#workflow syntax)\n- Output validation\n- collaborative/gate types\n- Wisp burning/cleanup\n- Full CLI argument handling\n\n## Files to Create/Modify\n\n- `internal/template/module.go` - Minimal module parsing\n- `internal/template/baker.go` - Tier assignment\n- `cmd/meow/cmd/prime.go` - Wisp-aware output\n- `internal/orchestrator/beadstore.go` - Tier filtering\n- `internal/integration_test.go` - End-to-end test\n\n## Success Criteria\n\nThe integration test passes. That's it. This validates the architecture.\n\n## Why This Matters\n\nIf this slice doesn't work, we need to revisit the architecture before building out 40+ other tasks. Fail fast.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T18:15:23.71154853-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented minimal viable slice: module parser, tier tracking, and meow prime command","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-cf8","title":"Add error handling tests","description":"Comprehensive tests for advanced error handling.\n\nTest cases:\n- on_error: 'fail' behavior\n- on_error: 'continue' behavior\n- on_error: '.template' expansion\n- _failed_step variable access\n- Error type classification per executor\n- Recovery depth limiting\n- Retry count tracking\n- Nested recovery (recovery template fails)\n- Integration with foreach (child failure)\n- Complex recovery workflow example","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:31.164027104-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:31.164027104-05:00","dependencies":[{"issue_id":"meow-cf8","depends_on_id":"meow-ljo","type":"blocks","created_at":"2026-01-09T15:04:13.55187546-05:00","created_by":"ubuntu"},{"issue_id":"meow-cf8","depends_on_id":"meow-74g","type":"blocks","created_at":"2026-01-09T15:04:13.664258071-05:00","created_by":"ubuntu"},{"issue_id":"meow-cf8","depends_on_id":"meow-33i","type":"blocks","created_at":"2026-01-09T15:04:13.779222326-05:00","created_by":"ubuntu"},{"issue_id":"meow-cf8","depends_on_id":"meow-cql","type":"blocks","created_at":"2026-01-09T15:04:13.899978732-05:00","created_by":"ubuntu"},{"issue_id":"meow-cf8","depends_on_id":"meow-c6x","type":"blocks","created_at":"2026-01-09T15:04:14.030173887-05:00","created_by":"ubuntu"},{"issue_id":"meow-cf8","depends_on_id":"meow-p3h","type":"blocks","created_at":"2026-01-09T15:04:14.163808247-05:00","created_by":"ubuntu"},{"issue_id":"meow-cf8","depends_on_id":"meow-7hf","type":"blocks","created_at":"2026-01-09T15:04:14.308647679-05:00","created_by":"ubuntu"}]}
{"id":"meow-cql","title":"Implement template-based on_error","description":"Extend on_error handling to support template references.\n\nIn step execution logic:\n1. Check if on_error starts with '.' (template reference)\n2. If template reference:\n   a. Mark step as failed\n   b. Set up _failed_step context variables\n   c. Expand the recovery template\n   d. Continue workflow from recovery template\n3. If 'continue': skip and continue\n4. If 'fail' or unset: fail workflow\n\nAdd on_error field parsing to template parser.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:27.39141606-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:27.39141606-05:00","dependencies":[{"issue_id":"meow-cql","depends_on_id":"meow-ljo","type":"blocks","created_at":"2026-01-09T15:04:07.071938499-05:00","created_by":"ubuntu"},{"issue_id":"meow-cql","depends_on_id":"meow-33i","type":"blocks","created_at":"2026-01-09T15:04:07.178432663-05:00","created_by":"ubuntu"}]}
{"id":"meow-cta","title":"Consolidate lock strategy and remove dead StatePersister code","description":"# Consolidate Lock Strategy and Remove Dead StatePersister Code\n\n## Summary\n\nThe codebase has **two different lock mechanisms** that were intended for different purposes, but only one is actually used. This creates confusion and dead code.\n\n## Current State\n\n**Lock 1: YAMLWorkflowStore** (USED)\n\\`\\`\\`go\n// yamlstore.go:23-48\nlockPath := filepath.Join(dir, \".lock\")  // .meow/workflows/.lock\nlockFile, err := os.OpenFile(lockPath, os.O_CREATE|os.O_RDWR, 0644)\nsyscall.Flock(int(lockFile.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)\n\\`\\`\\`\n\n**Lock 2: StatePersister** (UNUSED)\n\\`\\`\\`go\n// state.go:47-83\nlockPath := filepath.Join(p.stateDir, \"orchestrator.lock\")  // .meow/orchestrator.lock\n// Also writes PID, has heartbeat, tracks active conditions, etc.\n\\`\\`\\`\n\nLooking at \\`run.go\\`, only YAMLWorkflowStore is created. StatePersister is never instantiated.\n\n## What StatePersister Was Designed For\n\nBased on the code, StatePersister provides:\n\n1. **Process lock with PID:** Writes PID to lock file for crash detection\n2. **Heartbeat mechanism:** \\`UpdateHeartbeat()\\` writes timestamp file\n3. **Stale detection:** \\`CheckStaleHeartbeat()\\` detects dead orchestrators\n4. **State persistence:** Tracks workflow ID, tick count, active conditions\n5. **Lock status query:** \\`IsLockHeld()\\` lets external tools check status\n\nThese are **useful features** that aren't being utilized.\n\n## Options\n\n### Option A: Remove StatePersister (Simpler)\n\nDelete the dead code entirely:\n- Remove \\`internal/orchestrator/state.go\\`\n- Remove \\`internal/orchestrator/state_test.go\\`\n- Simplify to single lock mechanism\n\n**Pros:** Less code, less confusion\n**Cons:** Lose useful crash detection features\n\n### Option B: Integrate StatePersister (More Features)\n\nWire up StatePersister alongside YAMLWorkflowStore:\n\\`\\`\\`go\n// run.go\nstatePersister := orchestrator.NewStatePersister(stateDir)\nif err := statePersister.AcquireLock(); err != nil {\n    return err\n}\ndefer statePersister.ReleaseLock()\n\n// Start heartbeat goroutine\ngo func() {\n    for {\n        statePersister.UpdateHeartbeat()\n        time.Sleep(10 * time.Second)\n    }\n}()\n\\`\\`\\`\n\n**Pros:** Better crash detection, external monitoring\n**Cons:** More complexity, two locks to manage\n\n### Option C: Merge Into YAMLWorkflowStore (Recommended)\n\nMerge StatePersister features into YAMLWorkflowStore:\n- Single lock location: \\`.meow/workflows/.lock\\`\n- Write PID to lock file (like StatePersister does)\n- Add heartbeat file in same directory\n- Remove separate StatePersister type\n\n\\`\\`\\`go\ntype YAMLWorkflowStore struct {\n    dir      string\n    lockFile *os.File\n    pid      int  // Our PID for crash detection\n}\n\nfunc (s *YAMLWorkflowStore) UpdateHeartbeat() error {\n    // Write heartbeat to .meow/workflows/.heartbeat\n}\n\\`\\`\\`\n\n**Pros:** Single source of truth, useful features preserved\n**Cons:** YAMLWorkflowStore does more than just file I/O\n\n## Recommendation\n\n**Option C** provides the best balance. The YAMLWorkflowStore already owns the lock, so adding heartbeat and PID tracking is natural.\n\n## Implementation Plan\n\n1. Add PID field to YAMLWorkflowStore\n2. Write PID to lock file on acquisition (already done in StatePersister)\n3. Add UpdateHeartbeat() method\n4. Add heartbeat goroutine in run.go\n5. Delete state.go and state_test.go\n6. Update tests\n\n## Files to Modify\n\n- \\`internal/orchestrator/yamlstore.go\\` - Add heartbeat, PID\n- \\`internal/orchestrator/yamlstore_test.go\\` - Add tests\n- \\`cmd/meow/cmd/run.go\\` - Start heartbeat goroutine\n- DELETE: \\`internal/orchestrator/state.go\\`\n- DELETE: \\`internal/orchestrator/state_test.go\\`\n\n## Acceptance Criteria\n\n- [ ] Single lock mechanism (no duplicate locks)\n- [ ] PID written to lock file\n- [ ] Heartbeat mechanism for liveness detection\n- [ ] StatePersister files deleted\n- [ ] All tests pass\n- [ ] \\`meow status\\` can detect stale orchestrators (future CLI work)\n\n## Dependencies\n\nNone - can be done independently of IPC unification.\n\n## Related\n\n- Parent epic: meow-aga\n- Analysis: docs/CONCURRENCY-ANALYSIS.md \"Medium Issue: Unused StatePersister Lock\"","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T19:50:52.746061946-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:50:52.746061946-05:00"}
{"id":"meow-cxt","title":"Apply tier labels and metadata","description":"Apply tier and metadata when baking beads. Set explicit Tier field as primary mechanism.\n\n## Tier Assignment Logic\n\n```go\nfunc (b *Baker) determineTier(step *Step, workflow *Workflow) BeadTier {\n    // Non-agent-executable types are always orchestrator\n    if step.Type != \"task\" \u0026\u0026 step.Type != \"collaborative\" \u0026\u0026 step.Type != \"gate\" {\n        return TierOrchestrator\n    }\n    \n    // Gates are orchestrator (human-facing, no agent assignee)\n    if step.Type == \"gate\" {\n        return TierOrchestrator\n    }\n    \n    // Tasks and collaborative in ephemeral workflow → wisp\n    if workflow.Ephemeral {\n        return TierWisp\n    }\n    \n    // Default: work bead\n    return TierWork\n}\n```\n\n## Metadata to Set\n\n1. **Tier** - From determineTier()\n2. **SourceWorkflow** - workflow.Name\n3. **WorkflowID** - Unique instance ID\n4. **HookBead** - From workflow.HooksTo variable (see meow-p84)\n\n## Key Changes from Original Plan\n\n- `collaborative` type handled same as `task` for tier purposes\n- Set `bead.Tier` field directly (not via labels)\n- Labels are optional (`meow:workflow:{id}` for grouping)\n- No `meow:wisp` or `meow:orchestrator` labels needed\n\n## File Location\nModify: `internal/template/baker.go`\n\n## Acceptance Criteria\n- [ ] determineTier() handles task, collaborative, gate correctly\n- [ ] SourceWorkflow set from workflow name\n- [ ] WorkflowID set from baker context\n- [ ] Unit tests for tier assignment including collaborative","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.891186647-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Covered by meow-cac (vertical slice). determineTier(), SourceWorkflow, WorkflowID are all part of the minimal baking implementation. Production hardening can happen incrementally after slice validates approach.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-cy5","title":"Bug: meow run does not start orchestrator loop","description":"## Problem\n\nThe `meow run` command creates beads from a template but does NOT start the orchestrator loop to execute them. This means workflows never actually run.\n\n## Current Behavior\n\n```bash\nmeow run template.toml --var key=value\n# Output:\n# Created 3 beads from template: template.toml\n# Workflow ID: meow-12345\n# Run 'meow prime' to see your first task.\n# \u003c- Command exits here\n```\n\nThe orchestrator's `Run()` method is never called.\n\n## Expected Behavior\n\nOption A: `meow run` should start the orchestrator loop (blocking or background):\n```bash\nmeow run template.toml  # Starts orchestrator, processes beads\nmeow run template.toml --background  # Starts in background\n```\n\nOption B: Separate commands:\n```bash\nmeow bake template.toml   # Just creates beads (current behavior)\nmeow orchestrate          # Starts orchestrator loop\n```\n\n## Impact\n\n- Workflows don't execute automatically\n- `start` beads never spawn agents\n- `code` beads never execute\n- `condition` beads never evaluate\n- The entire orchestrator is unused\n\n## File\n`cmd/meow/cmd/run.go` - Lines 117-143\n\nThe code loads beads but never calls `orchestrator.Run()`\n\n## Acceptance Criteria\n- [ ] `meow run` actually runs the orchestrator\n- [ ] Orchestrator dispatches start/code/condition/expand beads\n- [ ] Task beads wait for agent to close them\n- [ ] Workflow completes when all beads closed","status":"closed","priority":0,"issue_type":"bug","assignee":"agent1","created_at":"2026-01-08T03:03:54.459815506-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:28:44.805591314-05:00","closed_at":"2026-01-08T03:28:44.805591314-05:00","close_reason":"Closed","labels":["cli","critical","orchestrator"]}
{"id":"meow-d1h","title":"Prioritize orchestrator beads in ready selection","description":"Update GetNextReady to prioritize by tier per SPEC-ADDENDUM.\n\n## Priority Order\n\n1. **Orchestrator beads** (start, stop, condition, code, expand, gate)\n2. **Wisp beads** (task beads with Tier=wisp)\n3. **Work beads** (task beads with Tier=work)\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) GetNextReady(ctx context.Context) (*types.Bead, error) {\n    ready, _ := o.store.GetReady(ctx, BeadFilter{\n        Statuses: []BeadStatus{StatusOpen},\n    })\n    \n    if len(ready) == 0 {\n        return nil, nil\n    }\n    \n    // Sort by tier priority (orchestrator first)\n    sort.Slice(ready, func(i, j int) bool {\n        return tierPriority(ready[i].Tier) \u003c tierPriority(ready[j].Tier)\n    })\n    \n    return ready[0], nil\n}\n\nfunc tierPriority(tier BeadTier) int {\n    switch tier {\n    case TierOrchestrator:\n        return 0  // Highest priority\n    case TierWisp:\n        return 1\n    case TierWork:\n        return 2\n    default:\n        return 3\n    }\n}\n```\n\n## Why Orchestrator First\n\nOrchestrator beads (start, stop, condition, expand) set up the environment for agent work. They must complete before agents see their tasks:\n- `start` spawns the agent\n- `expand` creates the wisps the agent will execute\n- `condition` determines branching before agent proceeds\n\n## File Location\nModify: `internal/orchestrator/orchestrator.go`\n\n## Acceptance Criteria\n- [ ] GetNextReady sorts by tier\n- [ ] Orchestrator beads processed before wisps\n- [ ] Wisps processed before work beads\n- [ ] Tie-breaker by creation time","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.359113179-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Consolidated into meow-dax (tier-based bead filtering). Priority selection is part of the unified filtering implementation.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-d4e5493e","title":"Verify test completed","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T03:46:14.163900255-05:00","updated_at":"2026-01-08T22:14:41.41283484-05:00","closed_at":"2026-01-08T22:14:41.41283484-05:00","close_reason":"Old test workflow bead - cleaning up","labels":["meow:ephemeral"]}
{"id":"meow-dax","title":"Implement tier-based bead filtering (consolidated)","description":"Consolidated task merging [deleted:meow-00g], [deleted:meow-a85], [deleted:meow-c32].\n\n## Scope\n\nImplement complete tier-based filtering in one coherent piece:\n\n### 1. Label Conventions (was [deleted:meow-00g])\nDefine standard labels:\n- `meow:tier:work` / `meow:tier:wisp` / `meow:tier:orchestrator`\n- `meow:workflow:{id}` for workflow instance tracking\n- `meow:ephemeral` (existing, keep for backward compat)\n\n### 2. Filter Types (was [deleted:meow-a85])\n```go\ntype BeadFilter struct {\n    Tier       BeadTier   // Filter by tier\n    WorkflowID string     // Filter by workflow instance\n    Assignee   string     // Filter by agent\n    Status     BeadStatus // Filter by status\n    HookBead   string     // Filter by linked work bead\n}\n```\n\n### 3. Query Implementation (was [deleted:meow-c32])\nAdd to BeadStore interface:\n```go\nListByTier(ctx, tier BeadTier) ([]*Bead, error)\nListWispsForAgent(ctx, agentID string) ([]*Bead, error)\nListOrchestrator(ctx, workflowID string) ([]*Bead, error)\n```\n\n### 4. Ready Selection Priority (was [deleted:meow-d1h])\nOrchestrator beads processed before agent beads:\n```go\nfunc (o *Orchestrator) GetNextReady() *Bead {\n    // 1. Check orchestrator tier first (machinery)\n    // 2. Then wisp tier (agent workflow steps)\n    // 3. Never return work tier from here (agent selects those)\n}\n```\n\n## Files to Modify\n- `internal/types/bead.go` - BeadFilter struct\n- `internal/orchestrator/beadstore.go` - Query methods\n- `internal/orchestrator/orchestrator.go` - Priority selection\n\n## Acceptance Criteria\n- [ ] Label conventions documented\n- [ ] BeadFilter struct with tier field\n- [ ] ListByTier, ListWispsForAgent, ListOrchestrator methods\n- [ ] GetNextReady prioritizes orchestrator \u003e wisp\n- [ ] Unit tests for filtering","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T18:13:47.860295186-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.362718505-05:00","close_reason":"Implemented tier-based bead filtering: BeadFilter with HookBead field, ListByTier/ListWispsForAgent/ListOrchestrator methods, tier-based priority in GetNextReady (orchestrator \u003e wisp \u003e work), and comprehensive unit tests","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-db2","title":"Add hooked status for wisp beads","description":"New BeadStatusHooked for when agent claims wisp step. See IMPLEMENTATION-PLAN section meow-modules-types-status.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:38:53.088124645-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Spec refinement: No hooked status. The SPEC-ADDENDUM-WISPS-AND-MODULES.md explicitly removes the hooked status (lines 179-210). Three statuses only: open, in_progress, closed. Use LastSeen timestamp for heartbeat tracking if needed.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-dd0b9f2b","title":"Say hello world","status":"closed","priority":0,"issue_type":"task","assignee":"testx","created_at":"2026-01-08T03:53:32.750420123-05:00","updated_at":"2026-01-08T03:54:38.672099979-05:00","closed_at":"2026-01-08T03:54:38.672099979-05:00","close_reason":"Said hello world successfully","labels":["meow:ephemeral"]}
{"id":"meow-dlh","title":"Add wildcard needs tests","description":"Comprehensive tests for wildcard dependencies.\n\nTest cases:\n- Simple wildcard: needs: ['foo.*']\n- Middle wildcard: needs: ['foo.*.bar']\n- Multiple wildcards: needs: ['*.*.done']\n- No matches (empty set = satisfied)\n- Integration with foreach expanded steps\n- Pattern caching and invalidation\n- Mixed literal and wildcard needs","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:22.238666405-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:22.238666405-05:00","dependencies":[{"issue_id":"meow-dlh","depends_on_id":"meow-vhy","type":"blocks","created_at":"2026-01-09T15:03:43.759917731-05:00","created_by":"ubuntu"}]}
{"id":"meow-dor","title":"Feature: CI Integration for E2E Tests","description":"# Feature: CI Integration for E2E Tests\n\n## Parent Epic\nmeow-qai: E2E Testing Infrastructure with Claude Simulator\n\n## Overview\n\nIntegrate E2E tests into the CI/CD pipeline. This ensures all E2E tests run on every PR and main branch push, catching regressions early.\n\n## Background\n\nE2E tests have unique CI requirements:\n\n1. **tmux dependency**: Tests need tmux installed\n2. **Longer runtime**: E2E tests take 30-60s vs \u0026lt;5s for unit tests\n3. **Potential flakiness**: Async operations need care\n4. **Isolation**: Tests must not interfere with each other\n\n## CI Configuration\n\n### GitHub Actions Workflow\n\n```yaml\n# .github/workflows/e2e.yml\n\nname: E2E Tests\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  e2e:\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.22'\n          cache: true\n\n      - name: Install tmux\n        run: sudo apt-get update \u0026\u0026 sudo apt-get install -y tmux\n\n      - name: Build simulator\n        run: go build -o bin/meow-agent-sim ./cmd/meow-agent-sim\n\n      - name: Build meow CLI\n        run: go build -o bin/meow ./cmd/meow\n\n      - name: Add binaries to PATH\n        run: echo \"bin-path\" \u003e\u003e GITHUB_PATH\n\n      - name: Install simulator adapter\n        run: |\n          mkdir -p ~/.meow/adapters\n          cp -r test/adapters/simulator ~/.meow/adapters/\n\n      - name: Run E2E tests\n        run: go test ./test/e2e/... -tags e2e -v -timeout 5m\n        env:\n          MEOW_SIM_DETERMINISTIC: \"true\"\n          MEOW_SIM_LOG_LEVEL: \"info\"\n\n      - name: Upload test logs\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: e2e-logs\n          path: |\n            /tmp/Test*/\n            ~/.meow/workflows/\n```\n\n### Stress Tests (Separate Job)\n\n```yaml\n  stress:\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n    if: github.event_name == 'push' \u0026\u0026 github.ref == 'refs/heads/main'\n\n    steps:\n      # ... same setup ...\n\n      - name: Run stress tests\n        run: go test ./test/e2e/... -tags 'e2e stress' -v -timeout 20m\n```\n\n## Makefile Targets\n\n```makefile\n# Makefile\n\n.PHONY: test-e2e test-e2e-stress test-all\n\n# Build E2E dependencies\nbuild-e2e: build-sim build-meow install-sim-adapter\n\nbuild-sim:\n\tgo build -o bin/meow-agent-sim ./cmd/meow-agent-sim\n\ninstall-sim-adapter:\n\tmkdir -p ~/.meow/adapters\n\tcp -r test/adapters/simulator ~/.meow/adapters/\n\n# Run E2E tests\ntest-e2e: build-e2e\n\tgo test ./test/e2e/... -tags e2e -v -timeout 5m\n\n# Run stress tests\ntest-e2e-stress: build-e2e\n\tgo test ./test/e2e/... -tags 'e2e stress' -v -timeout 20m\n\n# Run all tests\ntest-all: test test-e2e\n\t@echo \"All tests passed\"\n```\n\n## Flakiness Prevention\n\n### 1. Retry on Failure\n\nUse gotestsum for automatic retries.\n\n### 2. Parallel Test Isolation\n\nEach test uses unique resources (temp dir, tmux socket).\n\n### 3. Timeout Assertions\n\nAll waits have explicit timeouts.\n\n### 4. CI-Specific Environment\n\nShorter timeouts when CI=true.\n\n## Acceptance Criteria\n\n1. [ ] E2E tests run on every PR\n2. [ ] Tests complete in \u0026lt;5 minutes\n3. [ ] Flaky tests are auto-retried\n4. [ ] Failures upload debug logs\n5. [ ] Coverage reported with E2E included\n6. [ ] Stress tests run on main only\n\n## Dependencies\n\n- meow-ag6: Core E2E Test Suite\n- meow-1lh: Advanced E2E Test Suite\n\n## Reference\n\n- .github/workflows/test.yml - Existing unit test workflow\n- Makefile - Existing build targets","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-09T19:57:41.863902675-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:57:41.863902675-05:00","dependencies":[{"issue_id":"meow-dor","depends_on_id":"meow-ag6","type":"blocks","created_at":"2026-01-09T19:57:47.40672597-05:00","created_by":"ubuntu"},{"issue_id":"meow-dor","depends_on_id":"meow-1lh","type":"blocks","created_at":"2026-01-09T19:57:47.521548973-05:00","created_by":"ubuntu"}]}
{"id":"meow-dvr","title":"Implement external reference resolution","description":"Resolve file#workflow external references with cycle detection. See IMPLEMENTATION-PLAN section meow-modules-loader-external.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.509975604-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1","title":"Foundation: Project setup and core infrastructure","description":"Establish the foundational infrastructure for MEOW Stack including project\nstructure, core types, CLI skeleton, and build system.\n","notes":"## Why This Epic Matters\n\nA solid foundation prevents technical debt. Every component depends on\nthese core types and patterns. Getting this right saves refactoring later.\n\n## Deliverables\n1. Go project structure with modules\n2. Core types (Bead, Agent, Template, Config)\n3. CLI skeleton using Cobra\n4. Build system (Makefile)\n5. Basic configuration handling\n\n## Success Criteria\n- `go build` produces working `meow` binary\n- `meow --version` and `meow --help` work\n- Core types are defined and usable\n- Basic project structure matches architecture doc\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Foundation epic complete: Go project structure, core types (Bead/Agent/Config), CLI skeleton with Cobra, Makefile build system, config loading, structured logging, error types. All tests pass, binary builds and runs.","labels":["epic","foundation","phase-1"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1.1","title":"Initialize Go project with module structure","description":"Create the Go project structure for MEOW Stack.","notes":"## Directory Structure\n```\nmeow-machine/\n├── cmd/meow/                  # CLI entry point\n├── internal/\n│   ├── config/               # Configuration handling\n│   ├── types/                # Core data types\n│   ├── orchestrator/         # Orchestrator engine\n│   ├── template/             # Template system\n│   ├── agent/                # Agent management\n│   └── primitive/            # Primitive handlers\n├── pkg/meow/                 # Public API (if needed)\n├── templates/                # Default templates (embedded)\n├── go.mod\n├── Makefile\n└── README.md\n```\n\n## Commands\n```bash\ngo mod init github.com/your-org/meow-machine\nmkdir -p cmd/meow internal/{config,types,orchestrator,template,agent,primitive}\n```\n\n## Acceptance Criteria\n- [ ] `go mod init` creates valid go.mod\n- [ ] Directory structure matches plan\n- [ ] `.gitignore` includes Go artifacts\n- [ ] Basic `main.go` compiles\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Go project initialized with module structure, .gitignore, and compiling main.go","labels":["foundation","setup"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1.2","title":"Define core data types (Bead, Agent, Template, Config)","description":"Define the fundamental data structures used throughout MEOW.","notes":"## Types to Define\n\n### Bead (internal/types/bead.go)\n- BeadType enum (task, condition, stop, start, code, expand) - 6 primitives\n- BeadStatus enum (open, in_progress, closed)\n- Bead struct with all fields\n- Primitive-specific spec structs (ConditionSpec, StartSpec, CodeSpec, etc.)\n- OutputSpec for code bead outputs (stdout, file capture)\n- TaskOutputSpec for required/optional task outputs with types\n- EphemeralFlag for cleanup behavior\n\n### Agent (internal/types/agent.go)\n- AgentStatus enum (active, stopped)\n- Agent struct with session tracking\n- Session ID storage (for resume composition)\n\n### Config (internal/config/config.go)\n- Config struct for TOML loading\n- DefaultsConfig for default values\n- EphemeralCleanup settings\n\n## Design Decisions\n\n**Why 6 primitives instead of 8?**\ncheckpoint and resume are now composed from code + start:\n- checkpoint → code bead running `meow session-id`\n- resume → start bead with `resume_session` parameter\n\n**Why separate spec structs?**\nEach primitive has different fields. Using embedded structs keeps the\nmain Bead type clean while allowing type-safe access.\n\n## Acceptance Criteria\n- [ ] All types compile without errors\n- [ ] JSON marshaling/unmarshaling works correctly\n- [ ] OutputSpec handles stdout, stderr, file capture\n- [ ] TaskOutputSpec handles required/optional with types\n- [ ] Types have appropriate comments/godoc\n- [ ] Unit tests for marshaling edge cases\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Core types defined: Bead (6 primitives), Agent, Config with full test coverage","labels":["foundation","types"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1.3","title":"Create CLI skeleton with Cobra","description":"Set up the CLI framework using Cobra with stub commands.","notes":"## Commands to Stub\n\n### User Commands\n- `meow init` - Initialize .meow directory\n- `meow run \u003ctemplate\u003e` - Start workflow\n- `meow status` - Show current state\n- `meow approve [bead]` - Approve a gate\n- `meow reject [bead]` - Reject a gate\n\n### Agent Commands\n- `meow prime` - Show next task for agent\n- `meow close \u003cbead\u003e` - Close a task\n- `meow handoff` - Request context refresh\n\n### Debug Commands\n- `meow agents` - List agents\n- `meow trace` - Show execution trace\n- `meow validate \u003ctemplate\u003e` - Validate template\n\n## File Structure\n```\ncmd/meow/\n├── main.go\n├── root.go\n├── init.go\n├── run.go\n└── ...\n```\n\n## Acceptance Criteria\n- [ ] `meow --help` shows all commands\n- [ ] `meow \u003ccmd\u003e --help` shows command-specific help\n- [ ] `meow --version` shows version\n- [ ] Commands parse arguments correctly\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"CLI skeleton with Cobra: init, run, status, approve, reject, prime, close, handoff, agents, trace, validate","labels":["cli","foundation"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1.4","title":"Create Makefile and build scripts","description":"Create build automation for the project.","notes":"## Makefile Targets\n- `build` - Build binary to bin/meow\n- `install` - Install to GOPATH/bin\n- `test` - Run all tests\n- `test-short` - Run short tests\n- `lint` - Run golangci-lint\n- `clean` - Remove artifacts\n- `generate` - Run go generate\n\n## Version Embedding\nUse ldflags to embed version from git tags:\n```makefile\nVERSION ?= $(shell git describe --tags --always --dirty)\nLDFLAGS := -ldflags \"-X main.version=$(VERSION)\"\n```\n\n## Acceptance Criteria\n- [ ] `make build` produces binary\n- [ ] `make test` runs tests\n- [ ] `make lint` runs linter\n- [ ] Version embedded correctly\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Makefile created with all targets: build, install, test, test-short, test-cover, lint, fmt, vet, tidy, generate, clean, run, version, check, help. Version embedding works via ldflags.","labels":["build","foundation"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1.5","title":"Implement configuration loading and defaults","description":"Implement configuration file loading and sensible defaults.","notes":"## Config File Locations (priority order)\n1. `.meow/config.toml` (project-local)\n2. `~/.config/meow/config.toml` (user global)\n3. Built-in defaults\n\n## Default Configuration\n```toml\nversion = \"1\"\n\n[paths]\ntemplate_dir = \".meow/templates\"\nbeads_dir = \".beads\"\nstate_dir = \".meow/state\"\n\n[defaults]\nagent = \"claude-1\"\nstop_grace_period = 10\ncondition_timeout = \"1h\"\n\n[orchestrator]\npoll_interval = \"100ms\"\nheartbeat_interval = \"30s\"\n\n[cleanup]\nephemeral = \"on_complete\"  # on_complete | manual | never\n\n[logging]\nlevel = \"info\"  # debug | info | warn | error\nformat = \"json\"  # json | text\nfile = \".meow/state/meow.log\"\n```\n\n## Acceptance Criteria\n- [ ] Default config works with no file present\n- [ ] Project-local config overrides defaults\n- [ ] Unknown fields ignored (forward compatibility)\n- [ ] Invalid config produces helpful error\n- [ ] Unit tests for config loading edge cases\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Configuration loading fully implemented with Load, LoadFromDir, Validate, path helpers, and comprehensive test coverage","labels":["config","foundation"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1.6","title":"Implement structured logging infrastructure","description":"Set up structured logging for debugging and observability.","notes":"## Why Logging Matters\nMEOW orchestrates long-running workflows. When things go wrong, we need:\n- Clear timestamps for every action\n- Structured fields for filtering (agent, bead_id, action)\n- Log levels for verbosity control\n- File output for post-mortem analysis\n\n## Implementation\nUse zerolog or zap for structured JSON logging.\n\n## Log Levels\n- DEBUG: Variable substitution, bead state changes\n- INFO: Bead dispatch, agent spawn/stop, template expansion\n- WARN: Retries, timeouts, missing optional fields\n- ERROR: Validation failures, crashes, unrecoverable states\n\n## Log Fields (always include)\n```json\n{\n  \"ts\": \"2026-01-07T12:00:00Z\",\n  \"level\": \"info\",\n  \"msg\": \"Dispatching bead\",\n  \"bead_id\": \"bd-task-001\",\n  \"bead_type\": \"task\",\n  \"agent\": \"claude-1\",\n  \"workflow_id\": \"meow-run-001\"\n}\n```\n\n## Acceptance Criteria\n- [ ] Logger initialized from config\n- [ ] All major actions logged with context\n- [ ] Log rotation (max file size)\n- [ ] DEBUG level shows internal state\n- [ ] JSON format parseable by jq\n- [ ] Unit tests for log output format\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Structured logging infrastructure implemented: NewFromConfig for config-based initialization, file output with directory creation, JSON/text formats, level parsing, context helpers (WithWorkflow, WithBead, WithAgent), comprehensive test coverage","labels":["foundation","logging"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e1.7","title":"Define error types and codes","description":"Define structured error types for consistent error handling.","notes":"## Error Categories\n- **ConfigError**: Invalid config, missing required fields\n- **TemplateError**: Parse error, validation error, missing template\n- **BeadError**: Invalid state transition, missing dependency, cycle\n- **AgentError**: Spawn failed, session not found, timeout\n- **OutputError**: Type mismatch, missing required, validation failed\n- **IOError**: File not found, permission denied, disk full\n\n## Error Structure\n```go\ntype MeowError struct {\n    Code    string   // \"TMPL_PARSE_001\"\n    Message string   // Human-readable\n    Details map[string]any  // Context\n    Cause   error    // Wrapped error\n}\n```\n\n## Error Codes\n```\nCONFIG_001: Missing required field\nCONFIG_002: Invalid value type\nTMPL_001: Parse error\nTMPL_002: Validation error - missing field\nTMPL_003: Validation error - cycle detected\nBEAD_001: Invalid status transition\nBEAD_002: Dependency not satisfied\nAGENT_001: Session spawn failed\nAGENT_002: Session not found\nOUTPUT_001: Missing required output\nOUTPUT_002: Type validation failed\nOUTPUT_003: Bead ID not found\n```\n\n## Acceptance Criteria\n- [ ] All error types defined\n- [ ] Errors include context (bead_id, template, etc.)\n- [ ] Errors are JSON-serializable\n- [ ] CLI shows human-readable messages\n- [ ] Unit tests for error formatting\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Error types defined: MeowError struct with Code/Message/Details/Cause, all error codes (CONFIG, TMPL, BEAD, AGENT, OUTPUT, IO), factory functions for each error type, JSON serialization, Is/Code helpers, comprehensive test coverage","labels":["errors","foundation"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e10","title":"CLI Completion: All commands","description":"Complete all CLI commands.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["cli","epic","phase-4"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e10.1","title":"Implement meow init command","description":"Initialize .meow directory.","notes":"- Create directory structure\n- Copy default templates\n- Create config.toml\n- Setup Claude Code hooks\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-07T20:39:40.477442716-05:00","closed_at":"2026-01-07T20:39:40.477442716-05:00","close_reason":"Implemented meow init with embedded templates (simple, tdd), Claude Code hooks setup, .beads directory creation, and configurable flags (--hooks, --skip-templates).","labels":["cli","init"]}
{"id":"meow-e10.2","title":"Implement meow run command","description":"Start workflow execution.","notes":"Usage: meow run \u003ctemplate\u003e [--var key=value]...\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented meow run command with template parsing, baking, and bead store integration. Supports --dry-run, --var, and --workflow flags.","labels":["cli","run"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e10.3","title":"Implement meow prime command","description":"Show next task for agent with required outputs.","notes":"## Behavior\n1. Read $MEOW_AGENT to identify current agent\n2. Find assigned ready bead\n3. Output formatted context including:\n   - Task title and description\n   - **Required outputs with types and descriptions**\n   - Example close command\n   - Recently completed beads (optional context)\n\n## Output Format\n```\n=== YOUR CURRENT TASK ===\nBead: bd-select-001\nTitle: Select next task to work on\n\nInstructions:\n  Run: bv --robot-triage\n  Pick the highest priority ready task.\n\nREQUIRED OUTPUTS when closing:\n  work_bead (bead_id): The bead ID to implement\n  rationale (string): Why you chose this bead\n\nExample:\n  meow close bd-select-001 \\\n    --output work_bead=bd-task-XXX \\\n    --output rationale=\"...\"\n\nRECENTLY COMPLETED:\n  bd-task-000 \"Setup project\" (closed 5m ago)\n```\n\n## Acceptance Criteria\n- [ ] Reads agent from environment\n- [ ] Finds ready bead for agent\n- [ ] Shows task details\n- [ ] **Shows required outputs if defined**\n- [ ] Shows example close command\n- [ ] Shows recently completed beads (optional)\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by meow-97m (wisp-aware meow prime). Implementing basic prime first then rewriting for wisps is wasteful - go directly to wisp-aware version.","labels":["cli","prime"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e10.4","title":"Implement meow close command","description":"Close a task bead with optional validated outputs.","notes":"## Usage\n```bash\nmeow close \u003cbead-id\u003e\nmeow close \u003cbead-id\u003e --notes \"...\"\nmeow close \u003cbead-id\u003e --output key=value --output key2=value2\nmeow close \u003cbead-id\u003e --output-json '{\"key\": \"value\"}'\n```\n\n## Output Validation\nIf the bead has required outputs defined, the close command must:\n1. Check all required outputs are provided\n2. Validate output types (string, bead_id, file_path, etc.)\n3. Return error with helpful message if validation fails\n4. Store validated outputs on the bead\n\n## Example Error\n```\nError: Cannot close bd-select-001 - missing required outputs\n\nRequired outputs:\n  ✗ work_bead (bead_id): Not provided\n  ✗ rationale (string): Not provided\n\nUsage:\n  meow close bd-select-001 --output work_bead=\u003cbead_id\u003e --output rationale=\u003cstring\u003e\n```\n\n## Acceptance Criteria\n- [ ] Closes bead with status update\n- [ ] Supports --notes flag\n- [ ] **Supports --output key=value flags**\n- [ ] **Supports --output-json for complex outputs**\n- [ ] **Validates required outputs before closing**\n- [ ] **Returns helpful error for missing/invalid outputs**\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by meow-74h (meow close with output validation). The wisp-aware version is the real target - no point implementing a simpler version first.","labels":["cli","close"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e10.5","title":"Implement meow status command","description":"Show comprehensive workflow status.","notes":"## Usage\n```bash\nmeow status                 # Current workflow status\nmeow status --verbose       # Include all beads\nmeow status --json          # JSON output for scripting\nmeow status --watch         # Live updates\n```\n\n## Output Format\n```\n=== MEOW WORKFLOW STATUS ===\nWorkflow: work-loop (started 2h ago)\nTemplate: work-loop.toml\n\nAGENTS:\n  claude-1        active     (running for 45m)\n  claude-1-worker stopped    (completed 10m ago)\n\nBEADS:\n  Total: 15  Open: 3  In Progress: 1  Closed: 11\n\n  Currently executing:\n    → bd-task-005 \"Implement auth endpoint\" (claude-1, 5m)\n\n  Ready to execute:\n    • bd-task-006 \"Write integration tests\"\n    • bd-task-007 \"Update documentation\"\n\n  Recently closed:\n    ✓ bd-task-004 \"Setup database\" (2m ago)\n    ✓ bd-task-003 \"Create models\" (15m ago)\n\nOUTPUTS (recent):\n  select-task.work_bead = \"bd-task-005\"\n  setup-worktree.path = \".meow/worktrees/worker\"\n\nHEALTH:\n  Orchestrator: running (heartbeat 5s ago)\n  Lock: held by PID 12345\n```\n\n## Acceptance Criteria\n- [ ] Shows agent status\n- [ ] Shows bead counts and states\n- [ ] Shows currently executing beads\n- [ ] Shows recent outputs\n- [ ] --json produces parseable output\n- [ ] --watch updates live\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:22:59.818376637-05:00","closed_at":"2026-01-08T22:22:59.818376637-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["cli","status"]}
{"id":"meow-e10.6","title":"Implement debug commands","description":"agents, beads, trace, peek, clean commands.","notes":"## Commands\n- `meow agents [--active]` - List agents and states\n- `meow beads [--ready] [--include-ephemeral]` - List beads\n- `meow trace [--follow]` - Show execution trace\n- `meow peek \u003cagent\u003e` - Show agent's current output\n- `meow attach \u003cagent\u003e` - Attach to tmux session\n- `meow clean --ephemeral` - Clean up ephemeral beads\n\n## --include-ephemeral Flag\nBy default, beads with `meow:ephemeral` label are hidden.\nThis keeps focus on work beads, not workflow machinery.\n\n## Acceptance Criteria\n- [ ] All debug commands work\n- [ ] Ephemeral beads hidden by default\n- [ ] --include-ephemeral shows all beads\n- [ ] meow clean --ephemeral removes closed ephemeral beads\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:22:59.820282753-05:00","closed_at":"2026-01-08T22:22:59.820282753-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["cli","debug"]}
{"id":"meow-e11","title":"Comprehensive Testing: Unit, Integration, and E2E","description":"Comprehensive test coverage including unit tests, integration tests, and\nend-to-end tests with mock Claude. This epic is CRITICAL for reliability.\n","notes":"## Why This Epic is Non-Negotiable\nMEOW orchestrates long-running AI workflows. Bugs can waste hours of compute\nand cause data loss. We need:\n- Unit tests for every component\n- Integration tests for component interactions\n- E2E tests simulating real workflows\n- Detailed logging for debugging test failures\n\n## Phased Testing Strategy\nTesting is NOT a Phase 4 afterthought. Tests are written alongside code:\n\n| Test Type | Phase | Dependencies |\n|-----------|-------|--------------|\n| Test infrastructure (e11.1) | Phase 2 | E1 (types) |\n| Unit tests (e11.2-e11.5) | Phase 2 | Respective components |\n| Integration tests (e11.6) | Phase 3 | Core primitives |\n| E2E tests (e11.7) | Phase 4 | CLI + full system |\n| Performance (e11.8) | Phase 4 | Full system |\n\n## Test Categories\n1. **Unit Tests**: Individual functions and types (write with component)\n2. **Integration Tests**: Component interactions (write after primitives)\n3. **E2E Tests**: Full workflow execution with mock Claude (write after CLI)\n4. **Stress Tests**: Performance under load (final phase)\n\n## Coverage Requirements\n- Minimum 80% line coverage\n- 100% coverage for critical paths (output validation, bead transitions)\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-08T22:14:29.738517598-05:00","closed_at":"2026-01-08T22:14:29.738517598-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Templates and testing will be recreated for workflow-centric model.","labels":["critical","epic","testing"]}
{"id":"meow-e11.1","title":"Create test infrastructure and fixtures","description":"Set up testing infrastructure, fixtures, and helpers.","notes":"## Test Infrastructure\n\n### Directory Structure\n```\ninternal/testutil/\n├── fixtures.go      # Test data factories\n├── mock_tmux.go     # Mock tmux for agent tests\n├── mock_claude.go   # Mock Claude responses\n├── assertions.go    # Custom assertions\n├── logger.go        # Test logger that captures output\n└── cleanup.go       # Test cleanup helpers\n```\n\n### Test Fixtures\n```go\n// Create test beads\nfunc NewTestBead(t *testing.T, beadType string) *types.Bead\nfunc NewTestTemplate(t *testing.T, name string) *template.Template\nfunc NewTestConfig(t *testing.T) *config.Config\n\n// Create temp directories\nfunc NewTestWorkspace(t *testing.T) (path string, cleanup func())\n\n// Mock tmux\nfunc NewMockTmux(t *testing.T) *MockTmux\n```\n\n### Mock Claude\nScript that simulates Claude Code behavior:\n```bash\n#!/bin/bash\n# mock_claude.sh - Simulates Claude Code for testing\n# Reads meow prime, executes predefined responses, runs meow close\n\ncase \"$1\" in\n  --dangerously-skip-permissions)\n    # Enter mock REPL\n    while read -r line; do\n      if [[ \"$line\" == \"meow prime\" ]]; then\n        # Simulate Claude reading task and closing\n        BEAD_ID=$(meow prime --format json | jq -r .bead_id)\n        sleep 0.1\n        meow close \"$BEAD_ID\" --notes \"Mock completed\"\n      fi\n    done\n    ;;\nesac\n```\n\n### Test Logger\n```go\n// Captures structured logs for assertion\ntype TestLogger struct {\n    Entries []LogEntry\n}\n\nfunc (l *TestLogger) AssertContains(t *testing.T, msg string)\nfunc (l *TestLogger) AssertLevel(t *testing.T, level string, count int)\n```\n\n## Acceptance Criteria\n- [ ] Test fixtures create valid test data\n- [ ] Mock tmux simulates session lifecycle\n- [ ] Mock Claude script runs and responds\n- [ ] Test logger captures structured output\n- [ ] Cleanup removes all temp files\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Closed","labels":["infrastructure","phase-2","testing"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.10","title":"Create example workflows","description":"Complete example projects demonstrating MEOW capabilities.","notes":"## Example Projects\n```\nexamples/\n├── hello-world/           # Simplest possible workflow\n├── tdd-implementation/    # TDD with implement template\n├── multi-agent/           # Parent/child with call template\n├── human-approval/        # Human gate workflow\n└── context-aware/         # Context checking and refresh\n```\n\n## Each Example Includes\n- README with explanation\n- Complete template files\n- Expected output/trace\n- Troubleshooting tips\n\n## Acceptance Criteria\n- [ ] Each example runs standalone\n- [ ] Examples tested in CI\n- [ ] README explains what happens\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:24:06.495011021-05:00","closed_at":"2026-01-08T22:24:06.495011021-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["docs","examples"]}
{"id":"meow-e11.2","title":"Unit tests for core types","description":"Unit tests for Bead, Agent, Config, and Template types.","notes":"## Test Files\n- internal/types/bead_test.go\n- internal/types/agent_test.go\n- internal/config/config_test.go\n- internal/template/template_test.go\n\n## Test Cases\n\n### Bead Tests\n- [ ] JSON marshaling/unmarshaling round-trip\n- [ ] Status transitions (open → in_progress → closed)\n- [ ] Invalid status transition errors\n- [ ] Output storage and retrieval\n- [ ] Ephemeral label detection\n- [ ] Dependency parsing\n\n### Agent Tests\n- [ ] State transitions (active → stopped)\n- [ ] Session ID storage\n- [ ] Environment variable generation\n\n### Config Tests\n- [ ] Default values applied\n- [ ] File override works\n- [ ] Unknown fields ignored\n- [ ] Invalid values error with context\n\n### Template Tests\n- [ ] TOML parsing\n- [ ] Variable definition parsing\n- [ ] Step dependency parsing\n- [ ] Output spec parsing\n\n## Acceptance Criteria\n- [ ] All types have \u003e90% coverage\n- [ ] Edge cases covered (empty, nil, max values)\n- [ ] Error messages tested\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Completed: Unit tests for core types with 100% coverage, plus review fixes for orchestrator and template","labels":["phase-2","testing","unit"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.3","title":"Unit tests for template system","description":"Unit tests for template parsing, validation, and baking.","notes":"## Progress Summary\n\n### Coverage Achieved: 90.1% (target: \u003e90%)\n\n### New Tests Added\n\n#### parser_test.go\n- TestParseString_StepWithID_Empty\n- TestParseString_StepWithCode\n- TestParseString_StepWithAction\n- TestParseString_StepWithValidation\n- TestParseString_MetaFields\n- TestParseString_StepWithTimeout\n- TestParseString_StepWithAssignee\n- TestParseString_StepWithOnTimeout\n- TestParseString_InlineStepsInCondition\n- TestParseString_IntVariable\n- TestParseString_VariableWithDescription\n\n#### baker_test.go\n- TestBaker_BakeWorkflow_CodeStep\n- TestBaker_BakeWorkflow_StartStopSteps\n- TestBaker_BakeWorkflow_ExpandStep\n- TestBaker_BakeWorkflow_ConditionStep\n- TestBaker_BakeWorkflow_NilWorkflow\n- TestBaker_BakeWorkflow_MissingRequiredVariable\n- TestBaker_BakeWorkflow_DefaultVariable\n- TestBaker_BakeWorkflow_VariableOverride\n- TestBaker_BakeWorkflow_EphemeralStep\n- TestBaker_BakeWorkflow_UnknownDependency\n- TestBaker_determineBeadTypeFromString_AllTypes\n- TestBaker_BakeInline_InvalidType\n- TestBaker_BakeInline_ExternalDependency\n- TestBaker_ConditionWithOnTimeout\n\n#### vars_test.go\n- TestVarContext_Get\n- TestVarContext_EmptyPath\n- TestVarContext_NestedOutputAccess\n- TestVarContext_AccessFieldOnNonMap\n- TestVarContext_SubstituteMap_Error\n- TestVarContext_SubstituteStep_* (validation, timeout, ontimeout, all error paths)\n- TestVarContext_MaxDepthRecursion\n- TestVarContext_NonStringOutput\n- TestVarContext_OutputAccessOnNonMap\n\n#### validate_test.go\n- TestValidateFull_InvalidMetaType\n- TestValidateFull_ValidMetaType\n- TestValidateFull_OnTimeoutVariables\n- TestValidationResult_NoErrors\n- TestValidationResult_Add\n- TestValidationError_NoLocation\n- TestValidateFull_VariableInOnTimeoutTemplate\n- TestValidateFull_StepTypeInvalid\n- TestValidateFull_EmptyStepID\n\n#### mvp_test.go (module tests)\n- TestModule_DefaultWorkflow\n- TestWorkflow_IsInternal\n- TestDetectFormat\n- TestParseModuleString_Errors\n- TestWorkflow_Validate_Errors\n- TestParseModuleString_StepMissingID\n- TestParseModuleString_AllStepFields\n- TestParseModuleString_WorkflowAllFields\n\n### Key Coverage Improvements\n- vars.go SubstituteStep: 62.8% -\u003e 100%\n- baker.go setTypeSpec: 59.0% -\u003e 89.7%\n- baker.go BakeWorkflow: 78.6% -\u003e 96.4%\n- module.go functions: 0% -\u003e covered","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Unit tests for template system - achieved 90.1% coverage (target: \u003e90%)","labels":["phase-2","testing","unit"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.4","title":"Unit tests for primitive handlers","description":"Unit tests for all 6 primitive handlers.","notes":"## Test Files\n- internal/primitive/task_test.go\n- internal/primitive/condition_test.go\n- internal/primitive/code_test.go\n- internal/primitive/expand_test.go\n- internal/primitive/start_test.go\n- internal/primitive/stop_test.go\n\n## Test Cases\n\n### Task Handler Tests\n- [ ] Waits for bead to close\n- [ ] Validates required outputs\n- [ ] Rejects invalid output types\n- [ ] Stores validated outputs\n- [ ] Handles agent death\n\n### Condition Handler Tests\n- [ ] Exit 0 expands on_true\n- [ ] Exit non-0 expands on_false\n- [ ] Timeout expands on_timeout\n- [ ] Runs in goroutine (non-blocking)\n- [ ] Cancellation works\n\n### Code Handler Tests\n- [ ] Executes shell command\n- [ ] Captures stdout to output\n- [ ] Captures stderr to output\n- [ ] Reads file to output\n- [ ] Handles on_error: continue\n- [ ] Handles on_error: abort\n- [ ] Handles on_error: retry\n\n### Expand Handler Tests\n- [ ] Loads template\n- [ ] Substitutes variables\n- [ ] Resolves output references\n- [ ] Creates child beads\n- [ ] Sets ephemeral labels\n- [ ] Wires dependencies\n\n### Start Handler Tests\n- [ ] Creates tmux session\n- [ ] Sets workdir from output reference\n- [ ] Fresh start works\n- [ ] Resume with session_id works\n- [ ] Injects meow prime\n\n### Stop Handler Tests\n- [ ] Graceful stop sends interrupt\n- [ ] Force kill after timeout\n- [ ] Works if session doesn't exist\n- [ ] Updates agent state\n\n## Acceptance Criteria\n- [ ] Each handler has \u003e90% coverage\n- [ ] All error conditions tested\n- [ ] Mock tmux used (no real sessions)\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Added 40+ unit tests for all 6 primitive handlers in orchestrator_test.go. Coverage increased from 67% to 75.4%. Tests cover: Task (wait for close, dead agent), Condition (true/false/timeout/goroutine/cancel), Code (stdout/stderr/on_error modes), Expand (template/variables/parent/inline steps), Start (session/workdir/resume/prompt), Stop (graceful/force). Also added ephemeral cleanup test.","labels":["phase-2","testing","unit"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.5","title":"Unit tests for output binding","description":"Unit tests for output capture, storage, and resolution.","notes":"## Test Files\n- internal/output/capture_test.go\n- internal/output/storage_test.go\n- internal/output/resolver_test.go\n- internal/output/validator_test.go\n\n## Test Cases\n\n### Output Capture Tests\n- [ ] Captures stdout (trimmed)\n- [ ] Captures stderr (trimmed)\n- [ ] Reads file contents\n- [ ] Handles missing file gracefully\n- [ ] Handles empty output\n\n### Output Storage Tests\n- [ ] Stores outputs on bead\n- [ ] Persists across save/load\n- [ ] Visible in bd show\n\n### Output Resolver Tests\n- [ ] Resolves {{bead.outputs.field}}\n- [ ] Errors on non-existent bead\n- [ ] Errors on unclosed bead\n- [ ] Errors on missing field\n- [ ] Suggests similar beads on typo\n\n### Output Validator Tests\n- [ ] string type validation\n- [ ] number type validation\n- [ ] boolean type validation\n- [ ] bead_id type validation (checks existence)\n- [ ] file_path type validation (checks existence)\n- [ ] string[] type validation\n- [ ] json type validation\n- [ ] Error messages include expected type\n\n## Acceptance Criteria\n- [ ] All output types have validation tests\n- [ ] Error messages are helpful\n- [ ] Edge cases covered (empty, null, unicode)\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Templates and testing will be recreated for workflow-centric model.","labels":["outputs","phase-2","testing","unit"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.6","title":"Integration tests for orchestrator","description":"Integration tests for orchestrator main loop and state management.","notes":"## Test Files\n- internal/orchestrator/integration_test.go\n\n## Test Scenarios\n\n### Basic Execution\n- [ ] Simple linear workflow (3 code beads)\n- [ ] Workflow with dependencies (diamond pattern)\n- [ ] Workflow completes when all beads closed\n\n### State Management\n- [ ] State persists across loop iterations\n- [ ] Crash recovery resumes from last state\n- [ ] Lock prevents concurrent orchestrators\n- [ ] Heartbeat updates regularly\n\n### Bead Transitions\n- [ ] open → in_progress → closed\n- [ ] Dependency blocking works\n- [ ] Ready detection is correct\n\n### Logging\n- [ ] All dispatch actions logged\n- [ ] Log includes bead_id, agent, type\n- [ ] Errors logged with context\n\n## Test Setup\n```go\nfunc TestOrchestrator_LinearWorkflow(t *testing.T) {\n    workspace := testutil.NewTestWorkspace(t)\n    defer workspace.Cleanup()\n\n    // Create test beads\n    beads := []types.Bead{\n        testutil.NewCodeBead(\"step1\", \"echo hello\"),\n        testutil.NewCodeBead(\"step2\", \"echo world\", \"step1\"),\n        testutil.NewCodeBead(\"step3\", \"echo done\", \"step2\"),\n    }\n\n    // Run orchestrator\n    orch := orchestrator.New(testutil.NewTestConfig(t))\n    err := orch.Run(context.Background(), beads)\n\n    require.NoError(t, err)\n    // Assert all beads closed\n}\n```\n\n## Acceptance Criteria\n- [ ] All scenarios pass\n- [ ] No real tmux sessions created\n- [ ] Tests run in \u003c5s\n- [ ] Parallel test execution works\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Completed: Added comprehensive integration tests for orchestrator in internal/orchestrator/integration_test.go. Tests cover: linear workflows (3 sequential beads), diamond dependency patterns, state persistence across iterations, crash recovery (dead agent beads reset, live agent beads preserved), lock conflict prevention, bead status transitions, dependency blocking, ready detection, logging verification, mixed bead types workflow, parallel test execution safety. All 19 integration tests pass in \u003c0.2s. No real tmux sessions created.","labels":["integration","phase-3","testing"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.7","title":"E2E tests with mock Claude","description":"End-to-end tests simulating real workflows with mock Claude.","notes":"## E2E Test Framework\n\n### Mock Claude Script\n```bash\n# test/mock_claude.sh\n#!/bin/bash\nset -e\n\nLOG_FILE=\"${MEOW_TEST_LOG:-/tmp/mock_claude.log}\"\n\nlog() {\n    echo \"[$(date -Iseconds)] $*\" \u003e\u003e \"$LOG_FILE\"\n}\n\nlog \"Mock Claude started with args: $*\"\n\n# Simulate Claude startup\nsleep 0.2\necho \"Claude Code ready\"\n\n# Wait for prompts\nwhile IFS= read -r line; do\n    log \"Received: $line\"\n\n    if [[ \"$line\" == *\"meow prime\"* ]]; then\n        log \"Executing meow prime\"\n        PRIME_OUTPUT=$(meow prime --format json 2\u003e/dev/null || echo '{}')\n        BEAD_ID=$(echo \"$PRIME_OUTPUT\" | jq -r '.bead_id // empty')\n\n        if [[ -n \"$BEAD_ID\" ]]; then\n            log \"Found bead: $BEAD_ID\"\n\n            # Check for required outputs\n            OUTPUTS=$(echo \"$PRIME_OUTPUT\" | jq -r '.required_outputs // []')\n            OUTPUT_ARGS=\"\"\n\n            if [[ \"$OUTPUTS\" != \"[]\" ]]; then\n                # Generate mock outputs\n                for output in $(echo \"$OUTPUTS\" | jq -r '.[].name'); do\n                    OUTPUT_ARGS=\"$OUTPUT_ARGS --output $output=mock_value\"\n                done\n            fi\n\n            # Close the bead\n            log \"Closing bead: meow close $BEAD_ID $OUTPUT_ARGS\"\n            meow close \"$BEAD_ID\" --notes \"Mock completed\" $OUTPUT_ARGS\n        fi\n    fi\ndone\n```\n\n### E2E Test Scenarios\n```\ntest/e2e/\n├── simple_workflow_test.go      # Linear code beads\n├── condition_branching_test.go  # on_true/on_false\n├── output_passing_test.go       # Code outputs to start\n├── task_outputs_test.go         # Claude provides outputs\n├── parent_child_test.go         # Call template\n├── crash_recovery_test.go       # Kill and resume\n├── human_gate_test.go           # meow approve flow\n└── ephemeral_cleanup_test.go    # Ephemeral bead cleanup\n```\n\n### Test Structure\n```go\nfunc TestE2E_ParentChildOrchestration(t *testing.T) {\n    if testing.Short() {\n        t.Skip(\"Skipping E2E test\")\n    }\n\n    workspace := testutil.NewTestWorkspace(t)\n    defer workspace.Cleanup()\n\n    // Setup mock Claude\n    mockClaude := testutil.NewMockClaude(t)\n    mockClaude.OnTask(\"select-task\", func(b *types.Bead) {\n        return map[string]string{\"work_bead\": \"bd-task-001\"}\n    })\n\n    // Run workflow\n    result := runE2EWorkflow(t, \"work-loop\", map[string]string{\n        \"agent\": \"claude-1\",\n    })\n\n    // Assertions\n    assert.True(t, result.Completed)\n    assert.Equal(t, 3, result.BeadsExecuted)\n    assertLogContains(t, \"Resuming parent\")\n}\n```\n\n## Acceptance Criteria - Infrastructure\n- [ ] Mock Claude script works reliably\n- [ ] Test fixtures create valid test data\n- [ ] Tests complete in \u003c30s each\n- [ ] Detailed logging for debugging failures\n- [ ] No real Claude API calls\n- [ ] Cleanup removes all temp files/sessions\n\n## Acceptance Criteria - Core Scenarios\nEach of these scenarios must pass:\n\n### Simple Workflow (simple_workflow_test.go)\n- [ ] Linear code beads execute in order\n- [ ] Dependencies are respected\n\n### Condition Branching (condition_branching_test.go)\n- [ ] on_true path works\n- [ ] on_false path works\n- [ ] Nested conditions work\n\n### Output Binding (output_passing_test.go)\n- [ ] Code bead captures stdout to output\n- [ ] Start bead uses output reference for workdir\n- [ ] Output values flow correctly between beads\n\n### Task Output Validation (task_outputs_test.go)\n- [ ] Missing required outputs are rejected\n- [ ] Invalid bead_id outputs are rejected with helpful error\n- [ ] Valid outputs are stored and accessible\n- [ ] Subsequent beads can read outputs via {{bead.outputs.field}}\n\n### Parent/Child Orchestration (parent_child_test.go)\n- [ ] call template spawns child correctly\n- [ ] Parent session is saved\n- [ ] Child completes work\n- [ ] Parent resumes with context\n\n### Crash Recovery (crash_recovery_test.go)\n- [ ] Kill orchestrator mid-workflow\n- [ ] State is persisted to disk\n- [ ] Restart resumes from last state\n- [ ] In-progress beads from dead agents reset\n- [ ] No duplicate work done\n\n### Human Gate (human_gate_test.go)\n- [ ] Blocking condition waits for approval\n- [ ] meow approve unblocks correctly\n- [ ] meow reject triggers on_false path\n\n### Ephemeral Cleanup (ephemeral_cleanup_test.go)\n- [ ] Ephemeral beads get correct label\n- [ ] meow clean --ephemeral removes closed ephemeral beads\n- [ ] Non-ephemeral beads are preserved\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Templates and testing will be recreated for workflow-centric model.","labels":["critical","e2e","testing"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.8","title":"Stress tests and performance benchmarks","description":"Performance tests and benchmarks for critical paths.","notes":"## Benchmark Tests\n```\ninternal/benchmark/\n├── template_parse_bench_test.go\n├── bead_dispatch_bench_test.go\n├── output_resolution_bench_test.go\n└── state_persistence_bench_test.go\n```\n\n## Performance Requirements\n| Operation | Target | Max |\n|-----------|--------|-----|\n| Template parse | \u003c1ms | 5ms |\n| Variable substitution | \u003c100µs | 500µs |\n| Bead dispatch | \u003c10ms | 50ms |\n| State save | \u003c50ms | 200ms |\n| Output resolution | \u003c1ms | 5ms |\n\n## Stress Tests\n- [ ] 1000 beads in single workflow\n- [ ] 100 concurrent output references\n- [ ] 50 nested template expansions\n- [ ] Rapid bead state transitions\n\n## Memory Profiling\n- [ ] No memory leaks in long-running workflows\n- [ ] Memory usage stable over 1000 iterations\n\n## Acceptance Criteria\n- [ ] All benchmarks meet targets\n- [ ] No degradation over time\n- [ ] Results logged for CI tracking\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["performance","testing"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e11.9","title":"Write user documentation","description":"Comprehensive user documentation for MEOW Stack.","notes":"## Documentation Structure\n```\ndocs/\n├── getting-started.md      # Quick start guide\n├── concepts.md             # Core concepts (primitives, templates, outputs)\n├── template-authoring.md   # How to write templates\n├── cli-reference.md        # All CLI commands\n├── output-binding.md       # Output capture and references\n├── troubleshooting.md      # Common issues and solutions\n└── examples/\n    ├── simple-workflow.md\n    ├── parent-child.md\n    └── human-gate.md\n```\n\n## Content Requirements\n- All 6 primitives documented with examples\n- Output binding explained with diagrams\n- Task outputs and validation explained\n- Ephemeral beads explained\n- Error codes and recovery\n\n## Acceptance Criteria\n- [ ] Getting started takes \u003c10 min\n- [ ] All CLI commands documented\n- [ ] Examples are copy-paste runnable\n- [ ] Troubleshooting covers common errors\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:22:59.824117322-05:00","closed_at":"2026-01-08T22:22:59.824117322-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["docs"]}
{"id":"meow-e1400b22","title":"Verify setup succeeded","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T02:57:55.881471097-05:00","updated_at":"2026-01-08T03:03:02.969764215-05:00","closed_at":"2026-01-08T03:03:02.969764215-05:00","close_reason":"Test bead - cleanup","labels":["meow:ephemeral"]}
{"id":"meow-e2","title":"Template System: Parser, variables, and baking","description":"Parse TOML templates, substitute variables, validate structure, and \"bake\"\ntemplates into beads.\n","notes":"## Why This Epic Matters\n\nTemplates are the \"programs\" in MEOW. They define workflows using the 6\nprimitives. This epic makes templates usable.\n\n## Key Components\n1. TOML parser with template-specific handling\n2. Variable substitution engine (including output references)\n3. Template validation\n4. Baking (template → beads)\n5. Output reference resolution ({{bead.outputs.field}})\n6. Ephemeral flag handling\n\n## Success Criteria\n- Can parse any valid MEOW template\n- Variable substitution works with nesting\n- Output references ({{bead.outputs.field}}) resolve correctly\n- Ephemeral templates get proper labeling\n- Validation catches common errors\n- Baking creates correct beads with dependencies\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Template system complete: TOML parser (ParseFile, ParseString), variable substitution with nesting/output refs, template validation (cycles, deps, types), baker (template to beads), loader (multi-source with priority). All tests pass.","labels":["epic","phase-1","templates"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e2.1","title":"Implement TOML template parser","description":"Parse MEOW template files from TOML format.","notes":"## Template Structure\n- [meta] section: name, version, description, etc.\n- [variables] section: variable definitions with types/defaults\n- [[steps]] array: workflow steps\n\n## Go Types\n- Template struct\n- TemplateMeta struct\n- VariableDef struct\n- TemplateStep struct\n- ExpansionTarget struct (for on_true/on_false)\n\n## Acceptance Criteria\n- [ ] Parse valid template without error\n- [ ] Return helpful error for invalid TOML\n- [ ] Handle all step types correctly\n- [ ] Support inline and template expansion targets\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Closed","labels":["parser","templates"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e2.2","title":"Implement variable substitution engine","description":"Implement {{variable}} substitution throughout templates.","notes":"## Substitution Types\n- Basic: {{task_id}} → value\n- Nested: {{output.step.field}} → nested value\n- **Output references: {{bead_id.outputs.field}} → captured output**\n- Builtins: {{agent}}, {{bead_id}}, {{timestamp}}, etc.\n\n## Output Reference Resolution\nWhen a template references {{some_bead.outputs.field}}:\n1. Find bead with matching ID in same workflow\n2. Look up outputs.field from bead's stored outputs\n3. Substitute the value\n\nThis enables dynamic data flow:\n- code bead captures stdout → subsequent bead uses it\n- task bead validates output → expand bead uses it\n\n## Edge Cases\n- Unset required variable → error\n- Unset optional with default → use default\n- Recursive substitution → detect and error\n- Missing output reference → error with helpful message\n\n## Acceptance Criteria\n- [ ] Basic {{var}} substitution works\n- [ ] Nested {{a.b.c}} access works\n- [ ] **Output references {{bead.outputs.field}} resolve correctly**\n- [ ] Built-in variables populated\n- [ ] Missing required variable errors clearly\n- [ ] Missing output reference errors with bead context\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Closed","labels":["templates","variables"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e2.3","title":"Implement template validation","description":"Validate templates for correctness before baking.","notes":"## Validations\n- Structure: meta.name required, unique step IDs, valid types\n- Dependencies: needs references exist, no cycles, all reachable\n- Variables: all {{var}} references defined\n- Type-specific: condition has on_true/on_false, expand has template, etc.\n\n## Error Messages\nShould include:\n- Template name and step ID\n- What's wrong\n- Suggestions (\"did you mean X?\")\n\n## Acceptance Criteria\n- [ ] Catches missing required fields\n- [ ] Detects circular dependencies\n- [ ] Suggests corrections for typos\n- [ ] Returns all errors, not just first\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Closed","labels":["templates","validation"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e2.4","title":"Implement template baking (template → beads)","description":"Transform a parsed, validated template into executable beads.","notes":"## Baking Process\n1. Load template\n2. Validate\n3. Substitute variables\n4. Generate bead IDs for each step\n5. Translate needs from step IDs to bead IDs\n6. Create beads\n\n## ID Generation\nFormat: {workflow_id}.{step_id}-{hash}\nExample: meow-run-001.load-context-a3f8\n\n## Handling Nested Structures\n- expand steps create placeholder beads (runtime expansion)\n- inline steps in conditions get baked immediately\n\n## Acceptance Criteria\n- [ ] Simple template bakes to correct beads\n- [ ] Dependencies translate correctly\n- [ ] Inline steps become child beads\n- [ ] Bead IDs are unique and traceable\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Closed","labels":["baking","templates"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e2.5","title":"Implement template loading from filesystem and embedded","description":"Load templates from multiple sources with precedence.","notes":"## Load Order\n1. Project: .meow/templates/{name}.toml\n2. User: ~/.config/meow/templates/{name}.toml\n3. Embedded: Built into binary\n\n## Embedded Templates\nUse Go embed directive:\n```go\n//go:embed templates/*.toml\nvar embeddedTemplates embed.FS\n```\n\n## Acceptance Criteria\n- [ ] Embedded templates load correctly\n- [ ] Project templates override embedded\n- [ ] Helpful error when template not found\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Template loading implemented: Loader with priority (project \u003e user \u003e embedded), Load() search with TemplateNotFoundError, List() for all available templates, support for embed.FS, comprehensive test coverage","labels":["loading","templates"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e3","title":"Orchestrator Core: Main loop and state management","description":"The heart of MEOW. Main loop, bead readiness detection, state management,\nand recovery.\n","notes":"## Design Philosophy\n\u003e \"The orchestrator is dumb; the templates are smart.\"\n\nThe orchestrator knows ONLY the 6 primitives. Everything else—loops,\ngates, refresh, checkpoint/resume—is template composition.\n\n## Success Criteria\n- Main loop runs continuously\n- Correctly identifies ready beads\n- Dispatches to appropriate handlers (6 types)\n- Captures and stores outputs from code beads\n- Validates and stores outputs from task beads\n- Persists state for recovery\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Orchestrator core complete: main loop, bead readiness (BeadStore.GetNextReady), dispatch to all 6 handlers (task/condition/stop/start/code/expand), state persistence (StatePersister), crash recovery (StartOrResume), execution tracing. Tests pass.","labels":["epic","orchestrator","phase-1"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e3.1","title":"Implement orchestrator main loop","description":"Implement the core orchestrator loop.","notes":"## Loop Structure\n```go\nfor {\n    bead := getNextReadyBead()\n    if bead == nil {\n        if allDone() { return nil }\n        sleep and continue\n    }\n    dispatch(bead)\n    updateHeartbeat()\n}\n```\n\n## Dispatch by Type (6 primitives)\n```go\nswitch bead.Type {\ncase \"task\":      waitForClaudeToClose(bead)\ncase \"condition\": evalAndExpand(bead)  // may block!\ncase \"stop\":      killAgent(bead)\ncase \"start\":     spawnAgent(bead)  // handles resume_session\ncase \"code\":      execShell(bead)   // captures outputs\ncase \"expand\":    expandTemplate(bead)\n}\n```\n\n## Concurrency\nConditions run in goroutines to avoid blocking main loop.\n\n## Acceptance Criteria\n- [ ] Loop runs until no ready beads\n- [ ] Dispatches correctly to all 6 handlers\n- [ ] Conditions don't block main loop\n- [ ] Graceful shutdown on context cancel\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Orchestrator main loop with dispatch to all 6 primitives, condition concurrency, graceful shutdown","labels":["main-loop","orchestrator"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e3.2","title":"Implement bead readiness detection","description":"Determine which beads are ready for execution.","notes":"## Readiness Rules\nA bead is ready when:\n1. Status is `open`\n2. All beads in `needs` are `closed`\n3. Not already being processed\n\n## Priority Ordering\n1. Orchestrator beads first (condition, expand, code, stop, etc.)\n2. Then task beads\n3. Within type: earlier creation time\n\n## Change Detection\nWatch .beads/issues.jsonl for changes rather than polling.\n\n## Acceptance Criteria\n- [ ] Correctly identifies ready beads\n- [ ] Dependencies checked correctly\n- [ ] Priority ordering correct\n- [ ] File watching triggers re-check\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"FileBeadStore with readiness detection, dependency checking, priority ordering","labels":["orchestrator","readiness"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e3.3","title":"Implement orchestrator state persistence","description":"Persist orchestrator state for crash recovery.","notes":"## State Files\n- .meow/state/orchestrator.json - workflow state\n- .meow/agents.json - agent states\n- .meow/state/heartbeat.json - health check\n- .meow/state/orchestrator.lock - prevent concurrent\n\n## Atomic Writes\nWrite to temp file, then rename.\n\n## Lock File\nPrevent concurrent orchestrators via exclusive lock.\n\n## Acceptance Criteria\n- [ ] State persists across iterations\n- [ ] Atomic writes prevent corruption\n- [ ] Lock prevents concurrent instances\n- [ ] Stale lock detection works\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"StatePersister with atomic writes, lock file, heartbeat, and crash detection","labels":["orchestrator","state"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e3.4","title":"Implement orchestrator startup and crash recovery","description":"Handle orchestrator startup, including recovery from crashes.","notes":"## Startup Flow\n1. Acquire lock\n2. Check for existing state\n3. If exists: resume flow\n4. If not: fresh start flow\n\n## Recovery Flow\n1. Load orchestrator state\n2. Load agent states\n3. Reconcile with reality (check tmux sessions)\n4. Reset in-progress beads from dead agents\n5. Resume main loop\n\n## Acceptance Criteria\n- [ ] Fresh start creates beads and spawns agent\n- [ ] Resume loads existing state\n- [ ] Dead agents detected via tmux\n- [ ] In-progress beads from dead agents reset\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented orchestrator startup and crash recovery with StartOrResume method, lock acquisition, fresh start flow, resume flow, and crash recovery (detects dead agents, resets orphaned beads). Added 7 comprehensive tests.","labels":["orchestrator","recovery"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e3.5","title":"Implement execution trace logging","description":"Log all orchestrator actions for debugging and audit.","notes":"## Trace Format\nJSONL in .meow/state/trace.jsonl\nEach entry: timestamp, action, details\n\n## Actions to Log\n- start, bake, spawn, dispatch, condition_eval, expand, close\n\n## CLI Access\n`meow trace [--follow] [--json] [--since 1h]`\n\n## Acceptance Criteria\n- [ ] All dispatch actions logged\n- [ ] Trace survives crash\n- [ ] meow trace command works\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Execution trace logging implemented: Tracer with JSONL output, all action types (start/resume/bake/spawn/dispatch/condition_eval/expand/close/stop/shutdown/error), NullTracer for testing, comprehensive test coverage","labels":["logging","orchestrator"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e3.6","title":"Implement graceful orchestrator shutdown","description":"Handle SIGTERM/SIGINT gracefully to prevent state corruption.","notes":"## Why This Task\nOrchestrator can be killed (Ctrl+C, systemd stop, etc.). Without graceful\nshutdown, we risk:\n- Corrupted state files (mid-write)\n- Orphaned tmux sessions\n- In-progress beads stuck forever\n\n## Shutdown Flow\n1. Receive SIGTERM or SIGINT\n2. Cancel main loop context\n3. Save orchestrator state immediately\n4. For each active agent:\n   - Send graceful stop (Ctrl+C to tmux)\n   - Wait up to grace_period (configurable, default 10s)\n   - Force kill if still running\n5. Update agent states to \"stopped\"\n6. Release lock file\n7. Exit cleanly\n\n## Implementation\n```go\nfunc (o *Orchestrator) setupSignalHandling(ctx context.Context) context.Context {\n    ctx, cancel := context.WithCancel(ctx)\n\n    sigChan := make(chan os.Signal, 1)\n    signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)\n\n    go func() {\n        sig := \u003c-sigChan\n        o.logger.Info(\"Received signal, shutting down gracefully\",\n            \"signal\", sig)\n\n        // Save state first\n        if err := o.saveState(); err != nil {\n            o.logger.Error(\"Failed to save state during shutdown\", \"error\", err)\n        }\n\n        // Stop all agents\n        for _, agent := range o.agentStore.ListByStatus(AgentActive) {\n            o.stopAgentGracefully(agent, o.cfg.StopGracePeriod)\n        }\n\n        // Release lock\n        o.lock.Release()\n\n        cancel()\n    }()\n\n    return ctx\n}\n```\n\n## Config\n```toml\n[orchestrator]\nstop_grace_period = 10  # seconds to wait for agent cleanup\n```\n\n## Acceptance Criteria\n- [ ] SIGTERM triggers graceful shutdown\n- [ ] SIGINT (Ctrl+C) triggers graceful shutdown\n- [ ] State is saved before agent cleanup\n- [ ] Active agents receive stop signal\n- [ ] Lock file is released\n- [ ] Exit code is 0 for clean shutdown\n- [ ] Integration test: kill -TERM during execution\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["orchestrator","reliability","shutdown"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4","title":"Primitive Handlers: All 6 primitive implementations","description":"Implement the handlers for all 6 primitive bead types.\n","notes":"## The 6 Primitives\n1. task - Wait for Claude to close (with output validation)\n2. condition - Evaluate shell, expand on_true/on_false\n3. stop - Kill tmux session\n4. start - Spawn tmux session (with optional resume_session)\n5. code - Execute shell script (with output capture)\n6. expand - Load and bake template (with ephemeral support)\n\n## Why 6 Instead of 8?\ncheckpoint and resume are now composed from code + start:\n- checkpoint → code bead with `meow session-id`\n- resume → start bead with `resume_session` parameter\n\n## Success Criteria\n- All 6 primitives have working handlers\n- Code beads capture and store outputs\n- Task beads validate required outputs\n- Start beads handle resume_session\n- Handlers are isolated and testable\n- Error handling is consistent\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"All 6 primitive handlers completed with retry logic, timeout handling, ephemeral cleanup, and tmux agent manager","labels":["epic","phase-2","primitives"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4.1","title":"Implement task primitive handler","description":"Handle task beads by waiting for Claude to close them with validated outputs.","notes":"## Behavior\n1. Verify assigned agent is running\n2. Mark bead in_progress\n3. Wait for bead status to become closed\n4. **Validate outputs if task has required outputs**\n5. Store validated outputs on bead\n6. Return (main loop finds next bead)\n\n## Task Outputs\nTasks can declare required/optional outputs:\n```yaml\noutputs:\n  required:\n    - name: \"work_bead\"\n      type: \"bead_id\"\n  optional:\n    - name: \"notes\"\n      type: \"string\"\n```\n\nClaude closes with: `meow close \u003cbead\u003e --output work_bead=bd-123`\n\n## Output Types\n- string, string[], number, boolean, json\n- bead_id (validated against .beads/)\n- file_path (validated file exists)\n\n## Agent runs `meow close` when done\n\n## Acceptance Criteria\n- [ ] Waits for agent to close bead\n- [ ] Marks bead in_progress\n- [ ] **Validates required outputs before accepting close**\n- [ ] **Stores outputs on bead for subsequent references**\n- [ ] Returns validation errors if outputs missing/invalid\n- [ ] Returns when bead is closed with valid outputs\n- [ ] Handles agent death gracefully\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["primitives","task"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4.2","title":"Implement condition primitive handler","description":"Handle condition beads by evaluating shell and expanding results.","notes":"## Behavior\n1. Mark in_progress\n2. Execute shell command (in goroutine - may block!)\n3. Based on exit code, expand on_true or on_false\n4. Close bead\n\n## Key Insight\nConditions can block indefinitely - human gates, CI waits, etc.\n\n## Acceptance Criteria\n- [ ] Shell command executes\n- [ ] Exit 0 → on_true\n- [ ] Exit ≠0 → on_false\n- [ ] Timeout → on_timeout\n- [ ] Bead auto-closes\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["condition","primitives"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4.3","title":"Implement code primitive handler","description":"Handle code beads by executing shell scripts with output capture.","notes":"## Behavior\n1. Execute code in shell\n2. Capture stdout/stderr\n3. **If outputs defined: capture specified outputs**\n4. **Store outputs on bead for subsequent references**\n5. Handle errors based on on_error policy\n6. Close bead\n\n## Output Capture\n```yaml\noutputs:\n  path: stdout           # Capture stdout\n  error_log: stderr      # Capture stderr\n  sha: file:/tmp/sha.txt # Read from file\n  result: exit_code      # Exit code as string\n```\n\nOutputs become available as {{bead_id.outputs.field}}\n\n## Example: Worktree creation\n```yaml\ntype: code\ncode: |\n  git worktree add -b meow/worker ~/worktrees/worker HEAD\n  echo \"~/worktrees/worker\"\noutputs:\n  path: stdout\n```\n\nNext bead uses: `workdir = \"{{create-worktree.outputs.path}}\"`\n\n## on_error Options\n- continue: log and continue\n- abort: stop workflow\n- retry: retry up to max_retries\n\n## Acceptance Criteria\n- [ ] Shell script executes\n- [ ] Working directory set correctly\n- [ ] Environment variables passed\n- [ ] **stdout captured when outputs.X = stdout**\n- [ ] **File contents captured when outputs.X = file:/path**\n- [ ] **Outputs stored on bead for reference**\n- [ ] on_error policies work\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["code","primitives"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4.4","title":"Implement expand primitive handler","description":"Handle expand beads by loading and baking templates with ephemeral support.","notes":"## Behavior\n1. Load referenced template\n2. Merge variables (including output references)\n3. Bake template into child beads\n4. **If ephemeral: true, label beads with meow:ephemeral**\n5. Wire dependencies\n6. Set assignee on children\n7. Close expand bead\n\n## Ephemeral Beads\nWhen `ephemeral: true` on expand or in template meta:\n- Child beads get `labels: [\"meow:ephemeral\"]`\n- They execute normally\n- After completion, can be auto-cleaned\n- Hidden in `bd list` by default\n\n## Example\n```yaml\ntype: expand\ntemplate: \"call-implement\"\nephemeral: true  # Machinery beads, not work beads\nvariables:\n  work_bead: \"{{select-task.outputs.work_bead}}\"\n```\n\n## Recursive Expansion\nChild expand beads get processed in later iterations.\n\n## Acceptance Criteria\n- [ ] Template loads correctly\n- [ ] Variables merge correctly (including output refs)\n- [ ] Child beads created\n- [ ] **Ephemeral flag propagates to labels**\n- [ ] Recursive expansion works\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["expand","primitives"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4.5","title":"Implement stop primitive handler","description":"Handle stop beads by killing agent tmux sessions.","notes":"## Behavior\n1. If graceful: send interrupt, wait, then force kill\n2. Kill tmux session\n3. Update agent state to stopped\n4. Close bead\n\n## Acceptance Criteria\n- [ ] Graceful stop sends interrupt first\n- [ ] Force kill after timeout\n- [ ] Agent state updated\n- [ ] Works if agent not running\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["primitives","stop"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4.6","title":"Implement start primitive handler","description":"Handle start beads by spawning agents in tmux with optional resume.","notes":"## Behavior\n1. Create tmux session\n2. Set working directory (can be from prior bead output)\n3. Set environment\n4. **If resume_session: start Claude with --resume**\n5. Otherwise: start Claude fresh\n6. Wait for ready\n7. Inject meow prime\n8. Update agent state\n9. Close bead\n\n## Resume Support (replaces old resume primitive)\n```yaml\ntype: start\nagent: \"claude-1\"\nresume_session: \"{{save-session.outputs.session_id}}\"\nworkdir: \".\"\n```\n\nThis composes checkpoint/resume:\n- code bead saves session ID\n- start bead uses it to resume\n\n## Fresh Start\n```yaml\ntype: start\nagent: \"claude-2\"\nworkdir: \"{{setup-worktree.outputs.path}}\"\n```\n\n## Acceptance Criteria\n- [ ] Creates tmux session\n- [ ] Sets workdir (including from output references)\n- [ ] **Starts Claude with --resume when resume_session set**\n- [ ] Starts Claude fresh when no resume_session\n- [ ] Detects when ready\n- [ ] Injects meow prime\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["primitives","start"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e4.7","title":"Implement ephemeral bead cleanup","description":"Clean up ephemeral beads after template completion.","notes":"## Behavior\nWhen a template with ephemeral beads completes:\n1. Detect all beads with `meow:ephemeral` label\n2. Based on cleanup config, either:\n   - on_complete: auto-delete closed ephemeral beads\n   - manual: wait for `meow clean --ephemeral`\n   - never: keep for debugging\n\n## Why Ephemeral Beads?\nTemplate steps like \"load-context\", \"write-tests\" are operational\nmachinery, not work items. Cleaning them keeps bead history focused\non actual deliverables.\n\n## Config\n```toml\n[cleanup]\nephemeral = \"on_complete\"  # or \"manual\" or \"never\"\n```\n\n## Acceptance Criteria\n- [ ] Detects ephemeral beads by label\n- [ ] Respects cleanup config\n- [ ] Cleans only closed ephemeral beads\n- [ ] `meow clean --ephemeral` works for manual mode\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["ephemeral","primitives"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e5","title":"Agent Management: tmux and lifecycle","description":"Manage agent lifecycle via tmux.","notes":"## Success Criteria\n- Can create/kill tmux sessions\n- Can send commands to sessions\n- Can detect if sessions are alive\n- Agent state reflects reality\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented all primitive handlers with retry, timeout, ephemeral cleanup, and tmux agent manager","labels":["agents","epic","phase-2"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e5.0","title":"Validate tmux availability and version","description":"Check tmux is installed and meets version requirements at startup.","notes":"## Why This Task\nMEOW relies heavily on tmux for agent session management. If tmux is missing\nor too old, users will get confusing errors deep in execution.\n\n## Validation Rules\n- tmux must be in PATH\n- Version \u003e= 3.0 (required for -c workdir flag)\n- Provide clear, actionable error if validation fails\n\n## Implementation\n```go\nfunc ValidateTmux() error {\n    // Check existence\n    path, err := exec.LookPath(\"tmux\")\n    if err != nil {\n        return \u0026MeowError{\n            Code:    \"AGENT_003\",\n            Message: \"tmux not found in PATH\",\n            Details: map[string]any{\n                \"hint\": \"Install tmux: apt install tmux / brew install tmux\",\n            },\n        }\n    }\n\n    // Check version\n    out, _ := exec.Command(\"tmux\", \"-V\").Output()\n    version := parseTmuxVersion(string(out)) // e.g., \"tmux 3.3a\" -\u003e 3.3\n    if version \u003c 3.0 {\n        return \u0026MeowError{\n            Code:    \"AGENT_004\",\n            Message: fmt.Sprintf(\"tmux version %v too old (need \u003e= 3.0)\", version),\n            Details: map[string]any{\n                \"current\": version,\n                \"required\": 3.0,\n                \"hint\": \"Upgrade tmux to 3.0 or later\",\n            },\n        }\n    }\n\n    return nil\n}\n```\n\n## Call Site\nCalled at orchestrator startup, before any agent operations.\n\n## Acceptance Criteria\n- [ ] Detects missing tmux with helpful message\n- [ ] Detects old tmux version with upgrade instructions\n- [ ] Returns nil for valid tmux installation\n- [ ] Unit test with mock exec\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented ValidateTmux() with AGENT_005/AGENT_006 error codes, version parsing, and comprehensive unit tests with mock exec","labels":["agents","prerequisite","validation"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e5.1","title":"Implement tmux wrapper library","description":"Create a Go wrapper around tmux commands.","notes":"## Interface\n- NewSession, KillSession, SessionExists, ListSessions\n- SendKeys, SendKeysLiteral\n- CapturePane, SetEnv\n\n## Acceptance Criteria\n- [ ] Create session in directory\n- [ ] Kill session cleanly\n- [ ] Check if session exists\n- [ ] Send text to session\n- [ ] Capture pane output\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Completed: Implemented TmuxWrapper library with NewSession, KillSession, SessionExists, ListSessions, SendKeys, SendKeysLiteral, CapturePane, SetEnv. Refactored TmuxManager to use wrapper.","labels":["agents","tmux"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e5.2","title":"Implement agent state storage","description":"Manage persistent agent state.","notes":"## Storage\n.meow/agents.json with agent records\n\n## Interface\nGet, Set, Update, Delete, List, ListByStatus\nLoad, Save\n\n## Acceptance Criteria\n- [ ] Persist agent state to disk\n- [ ] Atomic writes for safety\n- [ ] Thread-safe access\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented AgentStore with Get/Set/Update/Delete/List/ListByStatus operations, atomic file writes to .meow/agents.json, and comprehensive unit tests","labels":["agents","state"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e5.3","title":"Implement agent spawning logic","description":"Higher-level agent spawning that coordinates tmux and state.","notes":"## Spawn Flow\n1. Check if agent already exists\n2. Create tmux session\n3. Configure environment\n4. Start Claude\n5. Wait for ready\n6. Inject initial prompt\n7. Update agent state\n\n## Acceptance Criteria\n- [ ] Creates complete agent setup\n- [ ] Handles existing agent\n- [ ] Cleans up on failure\n- [ ] Updates state correctly\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented Spawner struct that coordinates TmuxWrapper and Store for agent lifecycle management. Includes spawn, despawn, sync, and cleanup on error.","labels":["agents","spawn"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e5.4","title":"Implement agent health monitoring","description":"Monitor agent health and detect crashes/stuck agents.","notes":"## Health Checks\n- Session exists (tmux has-session)\n- Activity check (recent progress)\n- Stuck detection (same bead too long)\n\n## Acceptance Criteria\n- [ ] Detects crashed sessions\n- [ ] Detects stuck agents\n- [ ] Updates state on crash\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["agents","monitoring"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e6","title":"Condition System: Blocking, timeouts, and gates","description":"Deep implementation of blocking conditions.","notes":"## Key Feature\nConditions can block indefinitely - this enables human gates, CI waits, etc.\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Gates are now a composition pattern, not a primitive. Beads integration removed (task-tracker agnostic).","labels":["conditions","epic","phase-3"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e6.1","title":"Implement blocking shell execution with cancellation","description":"Shell commands that block indefinitely with cancellation support.","notes":"Must support cancellation via context.\nRun in goroutines to not block main loop.\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented ShellExecutor in internal/executor/shell.go with:\n- Context cancellation support (SIGTERM then SIGKILL)\n- Process group handling for killing child processes\n- Output capture: stdout, stderr, exit_code, file\n- Working directory and environment variable support\n- 16 passing unit tests","labels":["blocking","conditions"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e6.2","title":"Implement condition timeout handling","description":"Timeouts specified on conditions.","notes":"On timeout, expand on_timeout template (or on_false if not specified).\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["conditions","timeout"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e6.3","title":"Implement helper commands (wait-approve, wait-file, etc.)","description":"Convenience commands for common blocking patterns.","notes":"Commands:\n- meow wait-approve --bead \u003cid\u003e\n- meow wait-file \u003cpath\u003e\n- meow wait-bead \u003cid\u003e --status closed\n- meow context-usage --threshold N --format exit-code\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["conditions","helpers"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e6.4","title":"Implement gate approval flow","description":"Human approval unblocking via meow approve.","notes":"`meow approve \u003cbead\u003e` creates marker that `meow wait-approve` detects.\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Gates are now a composition pattern, not a primitive. Beads integration removed (task-tracker agnostic).","labels":["conditions","gates"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e6.5","title":"Implement meow test-runner helper command","description":"Project-type-aware test runner for TDD workflow conditions.","notes":"## Why This Task\nThe implement-tdd template needs to run tests but different projects use\ndifferent test frameworks (npm test, go test, pytest, cargo test, etc.).\nHard-coding framework detection in templates is fragile.\n\n## Solution\n`meow test-runner` abstracts the test command based on project detection.\n\n## Usage\n```bash\nmeow test-runner                    # Run tests, exit 0 if pass\nmeow test-runner --expect-fail      # Exit 0 if tests FAIL (for TDD)\nmeow test-runner --framework npm    # Force specific framework\n```\n\n## Project Detection\n1. If `package.json` exists and has `scripts.test`: npm test\n2. If `go.mod` exists: go test ./...\n3. If `Cargo.toml` exists: cargo test\n4. If `pytest.ini` or `setup.py` exists: pytest\n5. If `Makefile` with `test` target: make test\n6. Fallback: error with helpful message\n\n## Implementation\n```go\nfunc (c *TestRunnerCmd) Run() error {\n    framework := c.detectFramework()\n    if framework == \"\" {\n        return \u0026MeowError{\n            Code:    \"TEST_001\",\n            Message: \"Could not detect test framework\",\n            Details: map[string]any{\n                \"hint\": \"Use --framework to specify manually\",\n                \"supported\": []string{\"npm\", \"go\", \"cargo\", \"pytest\", \"make\"},\n            },\n        }\n    }\n\n    cmd := c.buildCommand(framework)\n    exitCode := runCommand(cmd)\n\n    if c.expectFail {\n        // For TDD: success means tests failed as expected\n        if exitCode != 0 {\n            return nil  // Tests failed = success\n        }\n        return fmt.Errorf(\"tests passed unexpectedly\")\n    }\n\n    if exitCode != 0 {\n        return fmt.Errorf(\"tests failed with exit code %d\", exitCode)\n    }\n    return nil\n}\n```\n\n## Use in Templates\n```toml\n# In implement-tdd.toml\n[[steps]]\nid = \"verify-fail\"\ntype = \"condition\"\ncondition = \"meow test-runner --expect-fail\"  # Clean, project-agnostic\n```\n\n## Acceptance Criteria\n- [ ] Detects npm projects\n- [ ] Detects Go projects\n- [ ] Detects Cargo projects\n- [ ] --expect-fail inverts exit code\n- [ ] --framework overrides detection\n- [ ] Helpful error when detection fails\n- [ ] Unit tests for each detection path\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["conditions","helpers","testing"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e7","title":"Output Binding \u0026 Session Management","description":"Implement output binding between beads and session management for\ncheckpoint/resume composition.\n","notes":"## Why This Epic\nOutput binding is the key capability that enables:\n- Dynamic worktree paths from code → start\n- Task selection outputs from Claude → orchestrator\n- Session IDs from code → start (for resume)\n\n## Key Components\n1. Output storage on beads\n2. Output reference resolution in variable substitution\n3. meow session-id command for checkpoint composition\n4. meow close --output for task outputs\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Gates are now a composition pattern, not a primitive. Beads integration removed (task-tracker agnostic).","labels":["epic","outputs","phase-3","session"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e7.1","title":"Implement meow session-id command","description":"Command to discover and output Claude's session ID.","notes":"## Purpose\nThis command enables checkpoint composition:\n```yaml\ntype: code\ncode: meow session-id --agent {{agent}}\noutputs:\n  session_id: stdout\n```\n\nThe output can then be used by a start bead:\n```yaml\ntype: start\nresume_session: \"{{save-session.outputs.session_id}}\"\n```\n\n## Session ID Discovery\n- Read $MEOW_SESSION_ID if set (via meow prime --hook)\n- Or find latest in ~/.claude/sessions/ for agent\n- Or query tmux session for environment\n\n## Usage\n```bash\nmeow session-id              # Current agent\nmeow session-id --agent X    # Specific agent\nmeow session-id --save       # Also save to .meow/sessions/\n```\n\n## Acceptance Criteria\n- [ ] Discovers session ID from environment\n- [ ] Falls back to session file discovery\n- [ ] Outputs clean session ID to stdout\n- [ ] Works in code bead context\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Gates are now a composition pattern, not a primitive. Beads integration removed (task-tracker agnostic).","labels":["cli","session"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e7.2","title":"Implement output storage on beads","description":"Store captured outputs on bead records.","notes":"## Storage Format\n```json\n{\n  \"id\": \"create-worktree\",\n  \"type\": \"code\",\n  \"status\": \"closed\",\n  \"outputs\": {\n    \"path\": \"~/worktrees/worker\",\n    \"sha\": \"abc123\"\n  }\n}\n```\n\n## Requirements\n- Outputs persist in bead file\n- Outputs queryable via bd show\n- Outputs survive orchestrator restart\n\n## Acceptance Criteria\n- [ ] Code beads store captured outputs\n- [ ] Task beads store validated outputs\n- [ ] Outputs visible in bd show\n- [ ] Outputs persist across restarts\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T01:35:10.378220265-05:00","closed_at":"2026-01-08T01:35:10.378220265-05:00","close_reason":"Output storage fully implemented: Outputs field on Bead, meow show command displays outputs, FileBeadStore persists to JSONL. Added comprehensive tests for meow show.","labels":["outputs","storage"]}
{"id":"meow-e7.3","title":"Implement output reference resolution","description":"Resolve {{bead.outputs.field}} references during template processing.","notes":"## Resolution Process\nWhen processing a template with {{bead_id.outputs.field}}:\n1. Find bead with matching ID\n2. Check bead is closed (outputs available)\n3. Look up outputs.field\n4. Substitute value\n\n## Error Cases\n- Bead not found → error with available beads\n- Bead not closed → error (dependency issue)\n- Output field not found → error with available fields\n\n## Acceptance Criteria\n- [ ] Resolves valid output references\n- [ ] Clear error for missing bead\n- [ ] Clear error for unclosed bead\n- [ ] Clear error for missing field\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented BeadLookupFunc for dynamic output resolution. VarContext now supports fetching outputs from BeadStore when not cached. Added comprehensive tests for all error cases.","labels":["outputs","resolution"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e7.4","title":"Implement output type validators","description":"Implement validators for all output types including bead_id.","notes":"## Why This Task is Critical\nOutput validation is what makes Claude's outputs reliable. Without proper\nvalidation, typos and hallucinated bead IDs would break workflows.\n\n## Output Types to Validate\n```go\ntype OutputType string\n\nconst (\n    TypeString    OutputType = \"string\"\n    TypeStringArr OutputType = \"string[]\"\n    TypeNumber    OutputType = \"number\"\n    TypeBoolean   OutputType = \"boolean\"\n    TypeJSON      OutputType = \"json\"\n    TypeBeadID    OutputType = \"bead_id\"\n    TypeBeadIDArr OutputType = \"bead_id[]\"\n    TypeFilePath  OutputType = \"file_path\"\n)\n```\n\n## Validator Interface\n```go\ntype OutputValidator interface {\n    Validate(value string, ctx ValidationContext) error\n    TypeName() string\n}\n\ntype ValidationContext struct {\n    BeadsDir    string\n    WorkDir     string\n    BeadLookup  func(id string) (*types.Bead, bool)\n}\n```\n\n## bead_id Validator (Most Important)\n```go\ntype BeadIDValidator struct{}\n\nfunc (v *BeadIDValidator) Validate(value string, ctx ValidationContext) error {\n    // Check format\n    if !strings.HasPrefix(value, \"bd-\") {\n        return fmt.Errorf(\"bead_id must start with 'bd-', got '%s'\", value)\n    }\n\n    // Check existence\n    bead, found := ctx.BeadLookup(value)\n    if !found {\n        // Suggest similar beads\n        suggestions := findSimilarBeads(value, ctx)\n        return \u0026BeadNotFoundError{\n            ID:          value,\n            Suggestions: suggestions,\n        }\n    }\n\n    return nil\n}\n```\n\n## file_path Validator\n```go\ntype FilePathValidator struct{}\n\nfunc (v *FilePathValidator) Validate(value string, ctx ValidationContext) error {\n    path := value\n    if !filepath.IsAbs(path) {\n        path = filepath.Join(ctx.WorkDir, path)\n    }\n\n    if _, err := os.Stat(path); os.IsNotExist(err) {\n        return fmt.Errorf(\"file does not exist: %s\", value)\n    }\n\n    return nil\n}\n```\n\n## Error Messages\nMust be helpful and actionable:\n```\nError: Output validation failed for 'work_bead'\n\n  Value: \"bd-task-999\"\n  Type: bead_id\n  Error: Bead 'bd-task-999' does not exist\n\n  Did you mean one of these?\n    • bd-task-001 \"Implement auth\"\n    • bd-task-002 \"Add validation\"\n    • bd-task-003 \"Write tests\"\n\nHint: Run 'bd list --status=open' to see available beads\n```\n\n## Acceptance Criteria\n- [ ] All 8 types have working validators\n- [ ] bead_id checks actual bead existence\n- [ ] file_path checks file existence\n- [ ] Suggestions provided for typos\n- [ ] Error messages are actionable\n- [ ] Unit tests for each validator\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T02:17:11.613384974-05:00","closed_at":"2026-01-08T02:17:11.613384974-05:00","close_reason":"Output validators fully implemented: format validation for bead IDs, BeadNotFoundError with Levenshtein-based suggestions, actionable error messages with hints. All 8 types validated with comprehensive tests.","labels":["critical","outputs","validation"],"dependencies":[{"issue_id":"meow-e7.4","depends_on_id":"meow-e7.2","type":"blocks","created_at":"2026-01-07T03:14:34.382248765-05:00","created_by":"ubuntu"}]}
{"id":"meow-e8","title":"Integration: Beads, hooks, recovery","description":"Integration with external systems.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Gates are now a composition pattern, not a primitive. Beads integration removed (task-tracker agnostic).","labels":["epic","integration","phase-3"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e8.1","title":"Implement beads integration","description":"Implement MEOW's integration with the beads data layer.\n\n## Architecture Decision: Overlay Approach (No Fork)\n\nPer SPEC-ADDENDUM, MEOW **layers on top** of upstream beads rather than forking:\n- MEOW defines its own internal `Bead` type (`internal/types/bead.go`)\n- Both MEOW and upstream `bd` read/write the same `issues.jsonl` file\n- JSON schema flexibility means MEOW-specific fields are preserved but ignored by `bd`\n- ID prefix separation: `meow-*` for workflow beads, `bd-*` for work beads\n\n## Integration Approach: Direct File I/O\n\nMEOW reads/writes `.beads/issues.jsonl` directly using its internal types. We do NOT shell out to `bd` CLI for MEOW operations.\n\n```go\n// internal/orchestrator/beadstore.go already implements this!\ntype FileBeadStore struct {\n    path string  // .beads/issues.jsonl\n}\n\nfunc (s *FileBeadStore) Create(ctx context.Context, bead *types.Bead) error {\n    // Append bead as JSON line to issues.jsonl\n}\n\nfunc (s *FileBeadStore) Update(ctx context.Context, bead *types.Bead) error {\n    // Read all, update matching ID, write back\n}\n\nfunc (s *FileBeadStore) Get(ctx context.Context, id string) (*types.Bead, error) {\n    // Read file, find by ID\n}\n\nfunc (s *FileBeadStore) List(ctx context.Context, filter BeadFilter) ([]*types.Bead, error) {\n    // Read file, apply filter\n}\n```\n\n## ID Prefix Convention\n\n| Prefix | Source | Purpose |\n|--------|--------|---------|\n| `bd-*` | Created via `bd create` | Work beads (traditional issues) |\n| `meow-{workflow}.{step}` | Created by MEOW baker | Workflow beads (wisps, orchestrator) |\n\n## What This Task Actually Covers\n\nSince `FileBeadStore` is already implemented, this task is about:\n\n1. **Verifying compatibility** - Ensure MEOW-written beads are valid for upstream `bd`\n2. **ID generation** - Implement `meow-{workflow}.{step}` ID pattern\n3. **MEOW field serialization** - Verify `tier`, `hook_bead`, etc. serialize correctly\n4. **Concurrent access** - Handle case where both `meow` and `bd` modify the file\n\n## Test Cases\n\n```go\nfunc TestBeadsInterop(t *testing.T) {\n    // 1. Create bead with bd CLI\n    exec.Command(\"bd\", \"create\", \"--title\", \"Test work\").Run()\n    \n    // 2. Read it with MEOW's FileBeadStore\n    bead, _ := store.Get(ctx, \"bd-xxx\")\n    assert.Equal(t, \"Test work\", bead.Title)\n    \n    // 3. Create MEOW workflow bead\n    store.Create(ctx, \u0026types.Bead{\n        ID:   \"meow-abc.step-1\",\n        Tier: types.TierWisp,\n        // MEOW-specific fields\n    })\n    \n    // 4. Verify bd list shows it (but ignores MEOW fields)\n    out, _ := exec.Command(\"bd\", \"list\", \"--format\", \"json\").Output()\n    assert.Contains(t, string(out), \"meow-abc.step-1\")\n}\n```\n\n## Acceptance Criteria\n- [ ] FileBeadStore reads beads created by `bd` CLI\n- [ ] Beads created by MEOW are readable by `bd` CLI  \n- [ ] MEOW-specific fields are preserved through read/write cycles\n- [ ] ID prefix convention implemented in baker\n- [ ] Concurrent access doesn't corrupt data (file locking)","notes":"## Integration Points\nMEOW uses the `bd` CLI for all bead operations. This task integrates:\n\n### Bead Creation (template baking)\n```go\nfunc createBead(bead *types.Bead) error {\n    args := []string{\"create\",\n        \"--id\", bead.ID,\n        \"--type\", bead.Type,\n        \"--title\", bead.Title,\n    }\n    if bead.Parent != \"\" {\n        args = append(args, \"--parent\", bead.Parent)\n    }\n    for _, dep := range bead.Needs {\n        args = append(args, \"--dep\", dep)\n    }\n    return exec.Command(\"bd\", args...).Run()\n}\n```\n\n### Status Updates\n```go\nfunc updateBeadStatus(id string, status string) error {\n    return exec.Command(\"bd\", \"update\", id, \"--status\", status).Run()\n}\n```\n\n### Reading Beads\n```go\nfunc getBead(id string) (*types.Bead, error) {\n    out, err := exec.Command(\"bd\", \"show\", id, \"--format\", \"json\").Output()\n    if err != nil {\n        return nil, err\n    }\n    var bead types.Bead\n    json.Unmarshal(out, \u0026bead)\n    return \u0026bead, nil\n}\n```\n\n### Querying\n```go\nfunc listBeads(status string) ([]types.Bead, error) {\n    args := []string{\"list\", \"--format\", \"json\"}\n    if status != \"\" {\n        args = append(args, \"--status\", status)\n    }\n    // ...\n}\n```\n\n## Output Storage\nWhen storing outputs on beads:\n```go\nfunc storeOutputs(beadID string, outputs map[string]string) error {\n    outputJSON, _ := json.Marshal(outputs)\n    return exec.Command(\"bd\", \"update\", beadID,\n        \"--set\", fmt.Sprintf(\"outputs=%s\", outputJSON)).Run()\n}\n```\n\n## Acceptance Criteria\n- [ ] bd create integrates correctly\n- [ ] bd update for status changes\n- [ ] bd show for reading with JSON\n- [ ] bd list for queries\n- [ ] Output storage works\n- [ ] Error handling for bd failures\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Gates are now a composition pattern, not a primitive. Beads integration removed (task-tracker agnostic).","labels":["beads","integration"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e8.2","title":"Implement Claude Code hooks setup","description":"Configure .claude/settings.json with MEOW hooks.","notes":"- SessionStart: meow prime --hook\n- Stop: meow prime --format prompt\n\nmeow init should set this up.\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:23:56.05624985-05:00","closed_at":"2026-01-08T22:23:56.05624985-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["hooks","integration"]}
{"id":"meow-e8.3","title":"Test and validate crash recovery","description":"Integration test for crash recovery.","notes":"1. Start workflow\n2. Kill orchestrator mid-execution\n3. Restart\n4. Verify continues correctly\n","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["integration","recovery"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e8.4","title":"Implement git worktree support","description":"Helper functions for git worktree operations in code beads.","notes":"## Why Worktrees Matter\nWorktrees allow child agents to work in isolated branches without\naffecting the parent's working directory. This enables:\n- Parallel work on different features\n- Clean separation of concerns\n- Easy cleanup after completion\n\n## Worktree Path Convention\n```\n.meow/worktrees/{agent-id}/\n```\n\n## Helper Functions\n```go\n// Create worktree for agent\nfunc CreateWorktree(agentID string, branch string) (string, error) {\n    path := filepath.Join(\".meow/worktrees\", agentID)\n    branchName := fmt.Sprintf(\"meow/%s\", agentID)\n\n    cmd := exec.Command(\"git\", \"worktree\", \"add\",\n        \"-b\", branchName,\n        path,\n        \"HEAD\")\n\n    if err := cmd.Run(); err != nil {\n        return \"\", fmt.Errorf(\"failed to create worktree: %w\", err)\n    }\n\n    return path, nil\n}\n\n// Remove worktree and branch\nfunc RemoveWorktree(agentID string) error {\n    path := filepath.Join(\".meow/worktrees\", agentID)\n    branchName := fmt.Sprintf(\"meow/%s\", agentID)\n\n    // Remove worktree\n    exec.Command(\"git\", \"worktree\", \"remove\", path).Run()\n\n    // Delete branch (force if needed)\n    exec.Command(\"git\", \"branch\", \"-D\", branchName).Run()\n\n    return nil\n}\n\n// Check if worktree exists\nfunc WorktreeExists(agentID string) bool {\n    path := filepath.Join(\".meow/worktrees\", agentID)\n    _, err := os.Stat(path)\n    return err == nil\n}\n```\n\n## Usage in call Template\nThe call template uses worktrees when `use_worktree = true`:\n```toml\n[[steps]]\nid = \"setup-worktree\"\ntype = \"code\"\ncode = '''\nmeow worktree create {{child}}\n'''\noutputs = { workdir = \"stdout\" }\n```\n\n## CLI Commands (optional)\n```bash\nmeow worktree create \u003cagent\u003e   # Create and output path\nmeow worktree remove \u003cagent\u003e   # Remove worktree and branch\nmeow worktree list             # List active worktrees\n```\n\n## Acceptance Criteria\n- [ ] Create worktree at .meow/worktrees/{agent}/\n- [ ] Remove worktree and cleanup branch\n- [ ] Handle existing worktree gracefully\n- [ ] Output path to stdout for capture\n- [ ] Unit tests with mock git\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:23:56.060012626-05:00","closed_at":"2026-01-08T22:23:56.060012626-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["git","integration"]}
{"id":"meow-e9","title":"Default Templates: MVP template library","description":"Ship useful default templates.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.457391798-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These belong to old architecture.","labels":["epic","phase-4","templates"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e9.1","title":"Create work-loop template","description":"Main orchestration loop template.","notes":"Check for work → select → implement → check context → loop.\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:14:29.724365518-05:00","closed_at":"2026-01-08T22:14:29.724365518-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Templates and testing will be recreated for workflow-centric model.","labels":["templates","work-loop"]}
{"id":"meow-e9.3","title":"Create human-gate template","description":"Blocking approval template.","notes":"prepare-summary → notify → await-approval → record-decision\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:14:29.732953254-05:00","closed_at":"2026-01-08T22:14:29.732953254-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Templates and testing will be recreated for workflow-centric model.","labels":["gate","templates"]}
{"id":"meow-e9.4","title":"Create refresh and handoff templates","description":"Context refresh templates.","notes":"refresh: stop → start\nhandoff: write-notes → stop → start\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:23:56.061887761-05:00","closed_at":"2026-01-08T22:23:56.061887761-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["refresh","templates"]}
{"id":"meow-e9.5","title":"Create context-check template","description":"Check context and maybe refresh.","notes":"## Template: context-check.toml\n```toml\n[meta]\nname = \"context-check\"\ndescription = \"Check context usage and trigger refresh if needed\"\n\n[variables]\nagent = { required = true }\nthreshold = { default = 70, description = \"Context % threshold\" }\n\n[[steps]]\nid = \"check\"\ntype = \"condition\"\ncondition = \"meow context-usage --agent {{agent}} --threshold {{threshold}} --format exit-code\"\non_true:\n  template = \"handoff\"\n  variables = { agent = \"{{agent}}\" }\non_false:\n  inline = []  # Continue without refresh\n```\n\n## Acceptance Criteria\n- [ ] Template parses and validates\n- [ ] Threshold is configurable\n- [ ] Triggers handoff when context high\n- [ ] Unit test for template validation\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:23:56.063734334-05:00","closed_at":"2026-01-08T22:23:56.063734334-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","labels":["context","templates"]}
{"id":"meow-e9.6","title":"Create call template (parent/child orchestration)","description":"Template for spawning child agent, running workflow, resuming parent.","notes":"## Why This Template is Critical\nThe `call` template is the foundation for parent/child agent orchestration.\nIt demonstrates the composed checkpoint/resume pattern using the 6 primitives.\n\n## Template: call.toml\n```toml\n[meta]\nname = \"call\"\ndescription = \"Spawn child agent for sub-workflow, then resume parent\"\nephemeral = true  # All steps are operational machinery\n\n[variables]\nparent = { required = true, description = \"Parent agent ID\" }\nchild = { required = true, description = \"Child agent ID\" }\ntemplate = { required = true, description = \"Template for child to execute\" }\ntemplate_vars = { default = {}, description = \"Variables for child template\" }\nuse_worktree = { default = false, description = \"Create git worktree for child\" }\n\n# --- Save parent session ---\n[[steps]]\nid = \"save-parent-session\"\ntype = \"code\"\ncode = \"meow session-id --agent {{parent}}\"\noutputs = { session_id = \"stdout\" }\n\n[[steps]]\nid = \"stop-parent\"\ntype = \"stop\"\nagent = \"{{parent}}\"\nneeds = [\"save-parent-session\"]\n\n# --- Setup child workspace ---\n[[steps]]\nid = \"setup-worktree\"\ntype = \"code\"\nneeds = [\"stop-parent\"]\ncode = '''\nif [ \"{{use_worktree}}\" = \"true\" ]; then\n    git worktree add -b meow/{{child}} .meow/worktrees/{{child}} HEAD\n    echo \".meow/worktrees/{{child}}\"\nelse\n    pwd\nfi\n'''\noutputs = { workdir = \"stdout\" }\n\n# --- Start child ---\n[[steps]]\nid = \"start-child\"\ntype = \"start\"\nagent = \"{{child}}\"\nworkdir = \"{{setup-worktree.outputs.workdir}}\"\nneeds = [\"setup-worktree\"]\n\n# --- Child executes the work ---\n[[steps]]\nid = \"child-work\"\ntype = \"expand\"\ntemplate = \"{{template}}\"\nvariables = \"{{template_vars}}\"\nassignee = \"{{child}}\"\nneeds = [\"start-child\"]\n\n# --- Stop child ---\n[[steps]]\nid = \"stop-child\"\ntype = \"stop\"\nagent = \"{{child}}\"\nneeds = [\"child-work\"]\n\n# --- Cleanup worktree ---\n[[steps]]\nid = \"cleanup-worktree\"\ntype = \"code\"\nneeds = [\"stop-child\"]\ncode = '''\nif [ \"{{use_worktree}}\" = \"true\" ]; then\n    git worktree remove .meow/worktrees/{{child}} || true\n    git branch -d meow/{{child}} || true\nfi\n'''\n\n# --- Resume parent ---\n[[steps]]\nid = \"resume-parent\"\ntype = \"start\"\nagent = \"{{parent}}\"\nworkdir = \".\"\nresume_session = \"{{save-parent-session.outputs.session_id}}\"\nneeds = [\"cleanup-worktree\"]\n```\n\n## Key Features Demonstrated\n1. Output binding: session_id and workdir captured and used\n2. Composed checkpoint/resume: code → start with resume_session\n3. Ephemeral: all steps are machinery, not work\n4. Worktree isolation: optional per-agent workspace\n\n## Acceptance Criteria\n- [ ] Template parses and validates\n- [ ] Variables substitute correctly\n- [ ] Output references resolve\n- [ ] E2E test with mock agents\n- [ ] Unit test for template validation\n","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Templates and testing will be recreated for workflow-centric model.","labels":["call","critical","templates"],"deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-e9.7","title":"Create implement-tdd template","description":"TDD workflow template that works with a work bead.","notes":"## Template: implement-tdd.toml\n```toml\n[meta]\nname = \"implement-tdd\"\ndescription = \"TDD implementation workflow\"\nephemeral = true  # Steps are operational\n\n[variables]\nwork_bead = { required = true, type = \"bead_id\", description = \"The work bead to implement\" }\n\n[[steps]]\nid = \"load-context\"\ntype = \"task\"\ntitle = \"Load context for {{work_bead}}\"\ndescription = |\n  1. Run: bd show {{work_bead}}\n  2. Understand the requirements\n  3. Identify relevant files\n  4. Update notes with your understanding\n\n[[steps]]\nid = \"write-tests\"\ntype = \"task\"\ntitle = \"Write failing tests\"\ndescription = \"Write tests that will fail until implementation is complete\"\nneeds = [\"load-context\"]\n\n[[steps]]\nid = \"verify-fail\"\ntype = \"condition\"\ncondition = \"meow test-runner --expect-fail\"  # Project-type agnostic\nneeds = [\"write-tests\"]\non_true:\n  inline = []  # Tests fail as expected, continue\non_false:\n  inline = [\n    { id = \"fix-tests\", type = \"task\", title = \"Tests passed unexpectedly - revise tests\" }\n  ]\n\n[[steps]]\nid = \"implement\"\ntype = \"task\"\ntitle = \"Write implementation\"\ndescription = \"Write the minimum code to make tests pass\"\nneeds = [\"verify-fail\"]\n\n[[steps]]\nid = \"verify-pass\"\ntype = \"condition\"\ncondition = \"meow test-runner\"  # Project-type agnostic\nneeds = [\"implement\"]\non_true:\n  inline = []  # Tests pass, continue\non_false:\n  inline = [\n    { id = \"fix-impl\", type = \"task\", title = \"Tests still failing - fix implementation\" }\n  ]\n\n[[steps]]\nid = \"commit\"\ntype = \"task\"\ntitle = \"Commit changes\"\ndescription = \"Create a descriptive commit for the changes\"\nneeds = [\"verify-pass\"]\n\n[[steps]]\nid = \"close-work-bead\"\ntype = \"code\"\ncode = \"bd close {{work_bead}} --notes 'Implemented via implement-tdd template'\"\nneeds = [\"commit\"]\n```\n\n## Acceptance Criteria\n- [ ] Template parses and validates\n- [ ] work_bead variable is type-checked as bead_id\n- [ ] Verify-fail/verify-pass conditions work\n- [ ] Work bead is closed at end\n- [ ] Unit test for template validation\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T03:12:48.465692926-05:00","updated_at":"2026-01-08T22:14:29.736731998-05:00","closed_at":"2026-01-08T22:14:29.736731998-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. Templates and testing will be recreated for workflow-centric model.","labels":["implement","tdd","templates"]}
{"id":"meow-eej","title":"Bug: Inline steps lose title/code fields in condition branches","description":"## Problem\n\nThe `InlineStep` struct in `internal/template/parser.go:97-104` is missing critical fields:\n\n```go\ntype InlineStep struct {\n    ID           string   \\`toml:\"id\"\\`\n    Type         string   \\`toml:\"type\"\\`\n    Description  string   \\`toml:\"description,omitempty\"\\`\n    Instructions string   \\`toml:\"instructions,omitempty\"\\`\n    Assignee     string   \\`toml:\"assignee,omitempty\"\\`\n    Needs        []string \\`toml:\"needs,omitempty\"\\`\n    // MISSING: Title, Code, Condition, OnTrue, OnFalse, etc.\n}\n```\n\nCompare to full `Step` struct (lines 54-74) which has: Title, Code, Condition, Validation, Template, Variables, Ephemeral, OnTrue, OnFalse, OnTimeout, Timeout, Outputs...\n\n## Impact\n\nWhen parsing inline steps in condition branches:\n```toml\n[main.steps.on_false]\ninline = [\n    { id = \"create-marker\", type = \"code\", title = \"Create marker\", code = \"touch /tmp/marker\" }\n]\n```\n\nThe `title` and `code` fields are silently discarded because the struct doesn't have them!\n\n## Root Cause\n\nThis is NOT a serialization bug in `expansionTargetToTypes()` - that code correctly marshals what it receives. The problem is the parser never captures these fields.\n\n## Fix Options\n\nOption A: Make `InlineStep` have all the same fields as `Step`\nOption B: Reuse `Step` struct for inline steps instead of a separate `InlineStep`\n\n## Files\n- `internal/template/parser.go:97-104` - `InlineStep` struct definition (root cause)\n- `internal/template/parser.go:54-74` - `Step` struct (has all fields)\n- `internal/template/baker.go:510-520` - `expansionTargetToTypes()` (works correctly with what it receives)\n\n## Acceptance Criteria\n- [ ] Inline steps in condition branches preserve title field\n- [ ] Inline steps preserve code field for code beads\n- [ ] Inline steps preserve condition field for nested conditions\n- [ ] Test: bake template with inline code step, verify code is present in bead","status":"closed","priority":1,"issue_type":"bug","assignee":"agent2","created_at":"2026-01-08T03:03:32.603903752-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:32.92831957-05:00","closed_at":"2026-01-08T03:27:32.92831957-05:00","close_reason":"Closed","labels":["baker","bug","parser"]}
{"id":"meow-f153","title":"Create simulator adapter configuration","description":"# Task: Create Simulator Adapter Configuration\n\n## Parent Feature\nmeow-4af: Simulator Adapter\n\n## Objective\n\nCreate the adapter configuration file that allows MEOW workflows to spawn the simulator instead of Claude Code.\n\n## File Location\n\n```\ntest/adapters/simulator/adapter.toml\n```\n\nThis is installed to `~/.meow/adapters/simulator/` during test setup.\n\n## Configuration Content\n\n```toml\n[adapter]\nname = \"simulator\"\ndescription = \"Claude Code simulator for E2E testing\"\n\n[spawn]\ncommand = \"meow-agent-sim --config {{sim_config}}\"\nresume_command = \"meow-agent-sim --config {{sim_config}} --resume {{session_id}}\"\nstartup_delay = \"100ms\"\n\n[environment]\nTMUX = \"\"\n\n[prompt_injection]\npre_keys = []\npre_delay = \"0ms\"\nmethod = \"literal\"\npost_keys = [\"Enter\"]\npost_delay = \"50ms\"\n\n[graceful_stop]\nkeys = [\"C-c\"]\nwait = \"200ms\"\n\n[events]\ntranslator = \"./event-translator.sh\"\n\n[events.agent_config]\nStop = \"true\"  # Simulator handles internally\nPreToolUse = \"true\"\nPostToolUse = \"true\"\n```\n\n## Key Differences from Claude Adapter\n\n| Setting | Claude | Simulator | Reason |\n|---------|--------|-----------|--------|\n| startup_delay | 3s | 100ms | Faster startup |\n| pre_keys | [Escape] | [] | Always ready |\n| post_delay | 500ms | 50ms | Faster injection |\n| graceful_stop.wait | 2s | 200ms | Faster shutdown |\n\n## sim_config Variable\n\nThe `{{sim_config}}` variable must be provided by the workflow:\n\n```toml\n[main.variables]\nsim_config = { required = true, description = \"Path to simulator behavior config\" }\n\n[[main.steps]]\nid = \"spawn\"\nexecutor = \"spawn\"\nagent = \"test-agent\"\nadapter = \"simulator\"\n```\n\n## Acceptance Criteria\n\n1. [ ] adapter.toml created in test/adapters/simulator/\n2. [ ] Adapter loads without errors\n3. [ ] spawn.command references meow-agent-sim\n4. [ ] Timings are significantly faster than claude\n\n## Dependencies\n\nNone - this is configuration\n\n## Estimated Size\n\nTiny (~30 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:02:24.208757307-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:02:24.208757307-05:00"}
{"id":"meow-f8d","title":"Implement meow agents command","description":"## Current State\n\nThe `meow agents` command is a stub that prints \"not yet implemented\".\n\n## Required Functionality\n\nList all agents and their status:\n\n```bash\nmeow agents\n# Output:\n# AGENT       STATUS        TMUX SESSION      CURRENT BEAD\n# claude-1    active        meow-claude-1     bd-task-001\n# claude-2    stopped       -                 -\n\nmeow agents --json  # JSON format for scripting\n```\n\n## Implementation\n\nUse `internal/agent/store.go` to list agents:\n- `Store.List()` - returns all agents\n- Check tmux session status for each\n\n## File\n`cmd/meow/cmd/agents.go`\n\n## Acceptance Criteria\n- [ ] Lists all agents from store\n- [ ] Shows status, tmux session, current bead\n- [ ] JSON output format option","status":"closed","priority":2,"issue_type":"task","assignee":"agent3","created_at":"2026-01-08T03:04:31.397956463-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:31.015100085-05:00","closed_at":"2026-01-08T03:27:31.015100085-05:00","close_reason":"Closed","labels":["cli"]}
{"id":"meow-fus","title":"Implement implicit join semantics","description":"Implement the implicit join behavior (join=true default).\n\nWhen join=true:\n- foreach step status stays 'running' until all child steps are 'done'\n- Downstream steps that need the foreach step wait for all iterations\n- If any child fails, foreach fails (unless child has on_error handling)\n- Track completion status of all expanded iterations","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:37.722838313-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:37.722838313-05:00","dependencies":[{"issue_id":"meow-fus","depends_on_id":"meow-mfr","type":"blocks","created_at":"2026-01-09T15:04:18.873053568-05:00","created_by":"ubuntu"}]}
{"id":"meow-fxw","title":"Implement tier partitioning logic","description":"Classify steps into Work/Wisp/Orchestrator tiers. See IMPLEMENTATION-PLAN section meow-modules-baker-partition.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.796809646-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Consolidated into meow-cxt (tier assignment in baker). Partitioning logic is part of determineTier() which goes in cxt.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-g5s","title":"Research: MEOW-owned bead storage system","description":"## Summary\n\nReplace MEOW's dependency on external `bd` CLI with a self-contained bead storage system. The current approach of overlaying MEOW fields onto beads' `issues.jsonl` creates irreconcilable schema conflicts.\n\n## Problem Statement\n\nMEOW and `bd` write to the same `.beads/issues.jsonl` with incompatible schemas:\n- MEOW uses `type` (task, code, start, etc.), `tier` (work, wisp, orchestrator), `needs`, `workflow_id`, `*_spec` fields\n- `bd` uses `issue_type`, `priority`, `dependencies` table, no tier concept\n- When `bd sync` runs, it exports from SQLite and strips all MEOW-specific fields\n- This breaks `meow prime` which filters by Tier to find agent work\n\n## Proposed Solution\n\nBuild MEOW's own lightweight bead storage, inspired by the `ticket` CLI (github.com/wedow/ticket):\n\n### Storage Format\n```\n.meow/\n├── config.toml           # MEOW configuration\n├── templates/            # Workflow templates  \n└── beads/                # MEOW's own bead storage\n    └── {workflow-id}.{step-id}.md    # Markdown + YAML frontmatter\n```\n\n### Bead File Format\n```yaml\n---\nid: meow-xxx.step-yyy\ntype: task                    # 8 MEOW types\ntier: wisp                    # work | wisp | orchestrator\nstatus: open\nworkflow_id: meow-xxx\nassignee: agent-1\nneeds: [meow-xxx.step-aaa]\ncreated_at: 2026-01-08T21:00:00Z\ncode_spec:                    # Type-specific specs inline\n  code: \"echo hello\"\n---\n# Step Title\n\nInstructions/description in markdown body.\n```\n\n### Key Design Principles to Preserve\n\n1. **Durable execution** - Workflow state survives crashes, stored in files\n2. **Git tracking** - All beads are git-tracked for audit trail\n3. **Crash recovery** - Orchestrator can resume from file state\n4. **Agent handoffs** - Beads contain all context for session continuity\n5. **Dependency resolution** - `ready` detection via `needs` field\n\n### Advantages Over Current Approach\n\n1. **Full schema control** - Tier, Type, Specs are first-class\n2. **No sync conflicts** - No fighting with bd's SQLite/JSONL\n3. **Workflow-scoped** - Beads belong to workflows, not global tracker\n4. **Ephemeral is native** - Wisps/orchestrator beads clean up naturally\n5. **Agent-friendly** - Markdown files easy for Claude to read/search\n6. **Simpler** - No mapping layers or compatibility shims\n\n### Compatibility with Existing Beads Projects\n\nFor projects already using `bd` as issue tracker:\n- Users create workflows describing how to query beads (`bd ready`, etc.)\n- MEOW agents learn to work with beads through workflow instructions\n- No data migration required - coexistence via workflow configuration\n\n## Research References\n\n- `ticket` CLI: github.com/wedow/ticket - ~900 line bash script, markdown+YAML storage\n- Current MEOW types: `internal/types/bead.go`\n- Current beadstore: `internal/orchestrator/beadstore.go`\n- beads Issue struct: see beads source in acfs-setup\n\n## Implementation Considerations\n\n- Rewrite `FileBeadStore` to use markdown+YAML format\n- Update baker to write new format\n- Update orchestrator to read new format  \n- Add migration command for existing MEOW beads\n- Consider: separate files per bead vs single file per workflow\n\n## Acceptance Criteria\n\n- [ ] Design document with full architecture\n- [ ] New bead file format specification\n- [ ] FileBeadStore replacement implementation\n- [ ] Orchestrator integration\n- [ ] Migration path from current format\n- [ ] Tests for crash recovery scenarios","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T16:27:22.901459487-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:19:46.549240014-05:00","closed_at":"2026-01-08T22:19:46.549240014-05:00","close_reason":"Not relevant to v2 pivot - MEOW is now task-tracker agnostic"}
{"id":"meow-gnf","title":"Feature: E2E Test Framework","description":"# Feature: E2E Test Framework\n\n## Parent Epic\nmeow-qai: E2E Testing Infrastructure with Claude Simulator\n\n## Overview\n\nCreate Go testing utilities for E2E tests. This includes a test harness for isolated environments, workflow run helpers, simulator config builders, and assertion utilities.\n\n## Why a Framework?\n\nE2E tests have unique requirements:\n\n1. **Isolation**: Each test needs its own tmux socket, temp dirs, IPC socket\n2. **Async orchestration**: Workflows run in background, tests wait for states\n3. **Simulator configuration**: Each test needs custom behavior configs\n4. **Debugging**: Rich logging for test failures\n\nWithout a framework, each test would duplicate this boilerplate.\n\n## Components\n\n### 1. Test Harness\n\nCreates an isolated test environment:\n\n```go\n// internal/testutil/e2e/harness.go\n\ntype Harness struct {\n    t           *testing.T\n    tempDir     string          // Isolated test directory\n    tmuxSocket  string          // Dedicated tmux socket (avoid conflicts)\n    meowDir     string          // .meow directory for this test\n    simConfigs  map[string]string // Agent ID -\u003e config path\n    workflows   []*WorkflowRun  // Running workflows\n}\n\nfunc NewHarness(t *testing.T) *Harness {\n    t.Helper()\n    \n    tempDir := t.TempDir()\n    tmuxSocket := filepath.Join(tempDir, \"tmux.sock\")\n    meowDir := filepath.Join(tempDir, \".meow\")\n    \n    // Create directory structure\n    os.MkdirAll(filepath.Join(meowDir, \"workflows\"), 0755)\n    os.MkdirAll(filepath.Join(meowDir, \"adapters\"), 0755)\n    \n    // Install simulator adapter\n    installSimulatorAdapter(meowDir)\n    \n    return \u0026Harness{\n        t:          t,\n        tempDir:    tempDir,\n        tmuxSocket: tmuxSocket,\n        meowDir:    meowDir,\n        simConfigs: make(map[string]string),\n    }\n}\n\nfunc (h *Harness) Cleanup() {\n    // Kill any remaining tmux sessions\n    exec.Command(\"tmux\", \"-S\", h.tmuxSocket, \"kill-server\").Run()\n    // t.TempDir() handles file cleanup automatically\n}\n```\n\n### 2. Workflow Run\n\nRepresents a running workflow with wait/assertion helpers:\n\n```go\n// internal/testutil/e2e/workflow_run.go\n\ntype WorkflowRun struct {\n    harness    *Harness\n    workflowID string\n    ctx        context.Context\n    cancel     context.CancelFunc\n    \n    mu         sync.RWMutex\n    status     string              // pending, running, done, failed\n    steps      map[string]*StepState\n    events     []EventRecord\n    logs       []LogEntry\n}\n\n// WaitForStep blocks until step reaches expected status\nfunc (r *WorkflowRun) WaitForStep(stepID, status string, timeout time.Duration) error\n\n// WaitForEvent blocks until matching event received\nfunc (r *WorkflowRun) WaitForEvent(eventType string, filter map[string]string, timeout time.Duration) (*EventRecord, error)\n\n// WaitForDone blocks until workflow completes\nfunc (r *WorkflowRun) WaitForDone(timeout time.Duration) error\n\n// Status returns current workflow status\nfunc (r *WorkflowRun) Status() string\n\n// StepOutput retrieves output value from completed step\nfunc (r *WorkflowRun) StepOutput(stepID, key string) (any, bool)\n\n// StepOutputs retrieves all outputs from step\nfunc (r *WorkflowRun) StepOutputs(stepID string) map[string]any\n```\n\n### 3. Simulator Config Builder\n\nFluent builder for simulator configurations:\n\n```go\n// internal/testutil/e2e/sim_config.go\n\ntype SimConfigBuilder struct {\n    config SimConfig\n}\n\nfunc NewSimConfig() *SimConfigBuilder {\n    return \u0026SimConfigBuilder{\n        config: defaultSimConfig(),\n    }\n}\n\nfunc (b *SimConfigBuilder) OnPrompt(pattern string) *BehaviorBuilder {\n    return \u0026BehaviorBuilder{\n        parent:  b,\n        pattern: pattern,\n    }\n}\n\nfunc (b *SimConfigBuilder) DefaultComplete(outputs map[string]any) *SimConfigBuilder {\n    b.config.Default.Action = ActionComplete{Outputs: outputs}\n    return b\n}\n\nfunc (b *SimConfigBuilder) DisableHooks() *SimConfigBuilder {\n    b.config.Hooks.FireStopHook = false\n    b.config.Hooks.FireToolEvents = false\n    return b\n}\n\nfunc (b *SimConfigBuilder) Build() SimConfig {\n    return b.config\n}\n\n// Behavior builder\ntype BehaviorBuilder struct {\n    parent  *SimConfigBuilder\n    pattern string\n    regex   bool\n}\n\nfunc (bb *BehaviorBuilder) AsRegex() *BehaviorBuilder {\n    bb.regex = true\n    return bb\n}\n\nfunc (bb *BehaviorBuilder) Complete(outputs map[string]any) *SimConfigBuilder {\n    // Add behavior to parent\n    return bb.parent\n}\n\nfunc (bb *BehaviorBuilder) Ask(question string) *SimConfigBuilder {\n    // Add ask behavior\n    return bb.parent\n}\n\nfunc (bb *BehaviorBuilder) Fail(message string) *SimConfigBuilder {\n    // Add fail behavior\n    return bb.parent\n}\n\nfunc (bb *BehaviorBuilder) FailThenSucceed(failCount int, msg string, successOutputs map[string]any) *SimConfigBuilder {\n    // Add fail-then-succeed behavior\n    return bb.parent\n}\n\n// Usage:\nconfig := NewSimConfig().\n    OnPrompt(\"Write tests\").Complete(map[string]any{\"file\": \"test.ts\"}).\n    OnPrompt(\"implement.*\").AsRegex().Complete(map[string]any{\"result\": \"done\"}).\n    OnPrompt(\"review\").Ask(\"Found issues. Continue?\").\n    DefaultComplete(map[string]any{}).\n    Build()\n```\n\n### 4. Assertion Helpers\n\nTest-specific assertions:\n\n```go\n// internal/testutil/e2e/assert.go\n\n// AssertStepCompleted verifies step reached done status with expected outputs\nfunc AssertStepCompleted(t *testing.T, run *WorkflowRun, stepID string, expectedOutputs map[string]any)\n\n// AssertStepFailed verifies step failed with error containing message\nfunc AssertStepFailed(t *testing.T, run *WorkflowRun, stepID string, errorContains string)\n\n// AssertEventEmitted verifies event was emitted\nfunc AssertEventEmitted(t *testing.T, run *WorkflowRun, eventType string, dataContains map[string]any)\n\n// AssertParallelExecution verifies steps ran in parallel (overlapping times)\nfunc AssertParallelExecution(t *testing.T, run *WorkflowRun, stepIDs ...string)\n\n// AssertSequentialExecution verifies steps ran in order\nfunc AssertSequentialExecution(t *testing.T, run *WorkflowRun, stepIDs ...string)\n```\n\n## File Structure\n\n```\ninternal/testutil/e2e/\n├── harness.go        # Test environment setup\n├── workflow_run.go   # Workflow execution helpers\n├── sim_config.go     # Simulator config types and builder\n├── assert.go         # Test assertions\n├── install.go        # Adapter installation helpers\n└── e2e_test.go       # Unit tests for framework itself\n```\n\n## Environment Isolation\n\nEach test is fully isolated:\n\n```\n/tmp/TestXxx123456/           # t.TempDir()\n├── tmux.sock                 # Dedicated tmux socket\n├── .meow/\n│   ├── config.toml           # Test-specific config\n│   ├── workflows/\n│   │   └── wf-xxx.yaml       # Workflow state\n│   └── adapters/\n│       └── simulator/        # Copied adapter\n├── workdir/                  # Agent working directory\n└── sim-config.yaml           # Simulator behavior config\n```\n\nThis prevents tests from interfering with each other or with real MEOW installations.\n\n## Acceptance Criteria\n\n1. [ ] Harness creates isolated environment\n2. [ ] WorkflowRun tracks step states correctly\n3. [ ] WaitForStep/WaitForDone work reliably\n4. [ ] SimConfig builder is fluent and type-safe\n5. [ ] Assertions provide helpful error messages\n6. [ ] Framework has its own unit tests\n\n## Dependencies\n\n- meow-4af: Simulator Adapter (need adapter to install)\n\n## Reference\n\n- `docs/E2E-TESTING-DESIGN.md` - Section: Test Framework Design\n- `internal/testutil/testutil.go` - Existing test utilities\n- Go testing patterns: table-driven, t.Helper(), t.TempDir()","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T19:55:09.189333667-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:55:09.189333667-05:00","dependencies":[{"issue_id":"meow-gnf","depends_on_id":"meow-4af","type":"blocks","created_at":"2026-01-09T19:55:13.920820694-05:00","created_by":"ubuntu"}]}
{"id":"meow-gy2","title":"Baker: Wisp Detection and Tier Labeling","description":"Extend baker for automatic tier classification and wisp detection. Phase 2.","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.839652883-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:17.075441007-05:00","closed_at":"2026-01-08T22:14:17.075441007-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot (pivot-000). The three-tier bead model is replaced by workflow-centric architecture."}
{"id":"meow-hb7t","title":"Write event routing E2E tests","description":"Implement E2E tests for event emission and await-event matching. Test cases: tool events emitted, await-event matches correctly, filters work, timeout fires on_false branch, multiple waiters work.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T20:04:17.637453462-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:04:17.637453462-05:00","dependencies":[{"issue_id":"meow-hb7t","depends_on_id":"meow-j6rw","type":"blocks","created_at":"2026-01-09T20:04:22.785466157-05:00","created_by":"ubuntu"}]}
{"id":"meow-hy8z","title":"Implement workflow run helpers","description":"# Task: Implement Workflow Run Helpers\n\n## Parent Feature\nmeow-gnf: E2E Test Framework\n\n## Objective\n\nCreate the WorkflowRun type that tracks running workflows and provides wait/assertion methods.\n\n## Implementation\n\n### File: internal/testutil/e2e/workflow_run.go\n\n```go\npackage e2e\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os/exec\"\n    \"sync\"\n    \"time\"\n)\n\ntype WorkflowRun struct {\n    harness    *Harness\n    workflowID string\n    templatePath string\n    vars       map[string]string\n\n    ctx    context.Context\n    cancel context.CancelFunc\n    cmd    *exec.Cmd\n\n    mu        sync.RWMutex\n    status    string // pending, running, done, failed, stopped\n    steps     map[string]*StepState\n    events    []EventRecord\n    startTime time.Time\n    endTime   time.Time\n}\n\ntype StepState struct {\n    ID        string\n    Status    string\n    Outputs   map[string]any\n    StartTime time.Time\n    EndTime   time.Time\n}\n\ntype EventRecord struct {\n    Type      string\n    Data      map[string]any\n    Timestamp time.Time\n}\n\nfunc newWorkflowRun(h *Harness, templatePath string, vars map[string]string) *WorkflowRun {\n    ctx, cancel := context.WithCancel(context.Background())\n\n    run := \u0026WorkflowRun{\n        harness:      h,\n        templatePath: templatePath,\n        vars:         vars,\n        ctx:          ctx,\n        cancel:       cancel,\n        status:       \"pending\",\n        steps:        make(map[string]*StepState),\n    }\n\n    go run.execute()\n\n    return run\n}\n\nfunc (r *WorkflowRun) execute() {\n    r.mu.Lock()\n    r.status = \"running\"\n    r.startTime = time.Now()\n    r.mu.Unlock()\n\n    // Build meow run command\n    args := []string{\"run\", r.templatePath}\n    for k, v := range r.vars {\n        args = append(args, \"--var\", k+\"=\"+v)\n    }\n\n    r.cmd = exec.CommandContext(r.ctx, \"meow\", args...)\n    r.cmd.Env = r.harness.Environment()\n    r.cmd.Dir = r.harness.TempDir()\n\n    // Run and capture output\n    output, err := r.cmd.CombinedOutput()\n\n    r.mu.Lock()\n    r.endTime = time.Now()\n    if err != nil {\n        r.status = \"failed\"\n    } else {\n        r.status = \"done\"\n    }\n    r.mu.Unlock()\n\n    // Parse workflow state for step info\n    r.loadFinalState()\n}\n\nfunc (r *WorkflowRun) WaitForStep(stepID, status string, timeout time.Duration) error {\n    deadline := time.Now().Add(timeout)\n    for time.Now().Before(deadline) {\n        r.mu.RLock()\n        step, ok := r.steps[stepID]\n        r.mu.RUnlock()\n\n        if ok \u0026\u0026 step.Status == status {\n            return nil\n        }\n\n        select {\n        case \u003c-r.ctx.Done():\n            return r.ctx.Err()\n        case \u003c-time.After(50 * time.Millisecond):\n        }\n    }\n    return fmt.Errorf(\"step %s did not reach status %s within %v\", stepID, status, timeout)\n}\n\nfunc (r *WorkflowRun) WaitForDone(timeout time.Duration) error {\n    deadline := time.Now().Add(timeout)\n    for time.Now().Before(deadline) {\n        r.mu.RLock()\n        status := r.status\n        r.mu.RUnlock()\n\n        if status == \"done\" || status == \"failed\" || status == \"stopped\" {\n            return nil\n        }\n\n        select {\n        case \u003c-r.ctx.Done():\n            return r.ctx.Err()\n        case \u003c-time.After(100 * time.Millisecond):\n        }\n    }\n    return fmt.Errorf(\"workflow did not complete within %v (status: %s)\", timeout, r.status)\n}\n\nfunc (r *WorkflowRun) Status() string {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n    return r.status\n}\n\nfunc (r *WorkflowRun) StepOutput(stepID, key string) (any, bool) {\n    r.mu.RLock()\n    defer r.mu.RUnlock()\n\n    step, ok := r.steps[stepID]\n    if !ok {\n        return nil, false\n    }\n\n    val, ok := step.Outputs[key]\n    return val, ok\n}\n\nfunc (r *WorkflowRun) Stop() {\n    r.cancel()\n    if r.cmd != nil \u0026\u0026 r.cmd.Process != nil {\n        r.cmd.Process.Kill()\n    }\n}\n```\n\n## Polling Approach\n\nThe run polls workflow state files to track step progress:\n\n```go\nfunc (r *WorkflowRun) pollState() {\n    ticker := time.NewTicker(100 * time.Millisecond)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case \u003c-r.ctx.Done():\n            return\n        case \u003c-ticker.C:\n            r.loadState()\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n\n1. [ ] Starts meow run in background\n2. [ ] WaitForStep blocks until status reached\n3. [ ] WaitForDone blocks until workflow complete\n4. [ ] Status() returns current status\n5. [ ] StepOutput retrieves step outputs\n6. [ ] Stop() terminates workflow\n\n## Dependencies\n\n- meow-harness: Test harness (need environment)\n\n## Estimated Size\n\nMedium (~250 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:02:32.216039809-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:02:32.216039809-05:00","dependencies":[{"issue_id":"meow-hy8z","depends_on_id":"meow-two3","type":"blocks","created_at":"2026-01-09T20:02:37.077038774-05:00","created_by":"ubuntu"}]}
{"id":"meow-i46","title":"beadstore.go: Get() returns internal pointer instead of copy","description":"## Location\n`internal/orchestrator/beadstore.go:178-192`\n\n## Problem\n`FileBeadStore.Get()` returns the internal bead pointer directly, unlike `agent/store.go` which returns copies via `copyAgent()`:\n\n```go\n// beadstore.go - returns internal pointer\nfunc (s *FileBeadStore) Get(ctx context.Context, id string) (*types.Bead, error) {\n    ...\n    return bead, nil  // Direct pointer to internal state\n}\n\n// agent/store.go - returns copy\nfunc (s *Store) Get(ctx context.Context, id string) (*types.Agent, error) {\n    ...\n    return copyAgent(agent), nil  // Safe copy\n}\n```\n\n## Impact\n- Callers can mutate internal state without going through Update()\n- Potential data corruption if concurrent modifications occur\n- Race conditions possible between goroutines\n\n## Current Mitigation\nThe orchestrator pattern is: Get() → modify → Update(), which works because:\n1. The lock is released between Get() and Update()\n2. No concurrent reads of the same bead are expected\n3. Store.Update() overwrites with the modified bead\n\n## Risk\nIf condition goroutines and the main tick() both read/modify the same bead concurrently, race conditions occur.\n\n## Fix\nAdd a `copyBead()` function similar to `copyAgent()` and use it in Get():\n```go\nreturn copyBead(bead), nil\n```\n\n## Severity\nLOW-MEDIUM - Defensive improvement, potential race condition","status":"closed","priority":3,"issue_type":"bug","created_at":"2026-01-08T02:23:30.639242643-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:32:55.392877006-05:00","closed_at":"2026-01-08T02:32:55.392877006-05:00","close_reason":"Fixed: Get() now returns a copy via copyBead() to prevent internal state mutation"}
{"id":"meow-i8j","title":"Implement runtime pattern evaluation","description":"Integrate wildcard pattern evaluation into dependency resolution.\n\nIn isStepReady() or equivalent:\n- Check if any need contains wildcard\n- If so, expand pattern to matching step IDs at runtime\n- All matched steps must be 'done' for dependency to be satisfied\n- If pattern matches no steps, dependency is satisfied (empty set)\n- Cache pattern expansion results per orchestrator loop iteration","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:21.214022309-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:21.214022309-05:00","dependencies":[{"issue_id":"meow-i8j","depends_on_id":"meow-vhy","type":"blocks","created_at":"2026-01-09T15:03:42.892841266-05:00","created_by":"ubuntu"}]}
{"id":"meow-ilr","title":"CRITICAL: Unify IPC handling with orchestrator coordination","description":"# CRITICAL: Unify IPC Handling with Orchestrator Coordination\n\n## Summary\n\nThe IPC server routes messages to \\`IPCHandler\\` which operates **without mutex protection**, creating race conditions with the orchestrator's main loop. Both paths read-modify-write the workflow file concurrently.\n\n## The Bug\n\n**Current flow (broken):**\n\\`\\`\\`\nAgent → meow done → IPC Server → IPCHandler.HandleStepDone() → store.Save()\n                                      ↓\n                                 NO MUTEX!\n                                      \nMeanwhile...\n\nOrchestrator.tick() → processWorkflow() → store.Save()\n        ↓\n    HAS MUTEX (wfMu)\n    \nResult: Both paths can Save() concurrently, causing lost updates\n\\`\\`\\`\n\n**Evidence in code:**\n\n1. \\`IPCHandler.HandleStepDone\\` (ipc_handler.go:40-145) - No mutex acquisition\n2. \\`Orchestrator.handleStepDone\\` (orchestrator.go:448-490) - Has mutex, but NEVER CALLED\n3. \\`run.go:200-203\\` - IPC server uses IPCHandler, not orchestrator's channel\n\n## Race Condition Scenarios\n\n**Scenario 1: Agent completes during orchestrator tick**\n\\`\\`\\`\nT0: Orchestrator.tick() starts, acquires wfMu\nT1: Orchestrator reads workflow (step X is \"running\")\nT2: Agent calls \"meow done\" → IPCHandler (no lock wait!)\nT3: IPCHandler reads workflow, sees step X \"running\"\nT4: IPCHandler marks step X \"done\", saves workflow\nT5: Orchestrator marks step Y \"running\", saves (OVERWRITES T4!)\nT6: Step X completion is LOST\n\\`\\`\\`\n\n**Scenario 2: Multiple agents completing simultaneously**\n\\`\\`\\`\nT0: Agent A \"meow done\" → IPCHandler (goroutine 1)\nT1: Agent B \"meow done\" → IPCHandler (goroutine 2)\nT2: Both read same workflow state\nT3: A marks step-A done, saves\nT4: B marks step-B done, saves (overwrites A's change!)\nT5: step-A completion is LOST\n\\`\\`\\`\n\n## Proposed Solution: Option C (Delegate to Orchestrator)\n\nThe cleanest fix is to have IPCHandler delegate to Orchestrator methods:\n\n\\`\\`\\`go\n// internal/orchestrator/ipc_handler.go\n\ntype IPCHandler struct {\n    orch        *Orchestrator  // ADD: reference to orchestrator\n    eventRouter *EventRouter\n    logger      *slog.Logger\n}\n\nfunc NewIPCHandler(orch *Orchestrator, logger *slog.Logger) *IPCHandler {\n    return \u0026IPCHandler{\n        orch:        orch,\n        eventRouter: NewEventRouter(logger),\n        logger:      logger,\n    }\n}\n\nfunc (h *IPCHandler) HandleStepDone(ctx context.Context, msg *ipc.StepDoneMessage) any {\n    // Delegate to orchestrator (which has the mutex)\n    err := h.orch.HandleStepDone(ctx, msg)\n    if err != nil {\n        return \u0026ipc.ErrorMessage{Type: ipc.MsgError, Message: err.Error()}\n    }\n    return \u0026ipc.AckMessage{Type: ipc.MsgAck, Success: true}\n}\n\\`\\`\\`\n\n**Orchestrator changes:**\n\n\\`\\`\\`go\n// internal/orchestrator/orchestrator.go\n\n// HandleStepDone processes a meow done message from an agent.\n// Thread-safe: acquires wfMu before any state changes.\n// Called by IPCHandler (delegated) - this is the ONLY code path for step completion.\nfunc (o *Orchestrator) HandleStepDone(ctx context.Context, msg *ipc.StepDoneMessage) error {\n    o.wfMu.Lock()\n    defer o.wfMu.Unlock()\n    \n    // ... existing logic from handleStepDone ...\n}\n\\`\\`\\`\n\n**run.go changes:**\n\n\\`\\`\\`go\n// cmd/meow/cmd/run.go\n\n// Create orchestrator first\norch := orchestrator.New(cfg, store, agentManager, shellRunner, expander, logger)\n\n// IPC handler now takes orchestrator reference\nipcHandler := orchestrator.NewIPCHandler(orch, logger)\n\n// Rest unchanged\nipcServer := ipc.NewServer(workflowID, ipcHandler, logger)\n\\`\\`\\`\n\n## Why This Solution\n\n| Option | Pros | Cons |\n|--------|------|------|\n| A: Channel-based | Clean event loop | Adds latency, complex error handling |\n| B: Shared mutex | Simple | IPCHandler still has duplicate logic |\n| **C: Delegate (chosen)** | Single code path, clear ownership | Minor refactor |\n\nOption C eliminates duplicate logic entirely. The Orchestrator owns all workflow state mutations.\n\n## Implementation Plan\n\n1. Add \\`*Orchestrator\\` field to IPCHandler\n2. Change NewIPCHandler signature to take \\`*Orchestrator\\`\n3. Export Orchestrator's handleStepDone as HandleStepDone (capital H)\n4. Have IPCHandler.HandleStepDone delegate to Orchestrator.HandleStepDone\n5. Do same for HandleGetPrompt, HandleApproval\n6. Update run.go to pass orchestrator to IPCHandler\n7. Remove now-unused ipcChan from Orchestrator (cleanup)\n8. Add tests for concurrent step completion\n\n## Files to Modify\n\n- \\`internal/orchestrator/ipc_handler.go\\` - Major changes\n- \\`internal/orchestrator/orchestrator.go\\` - Export methods, remove ipcChan\n- \\`cmd/meow/cmd/run.go\\` - Update wiring\n- \\`internal/orchestrator/orchestrator_test.go\\` - Add concurrency tests\n\n## Acceptance Criteria\n\n- [ ] IPCHandler delegates all state-mutating operations to Orchestrator\n- [ ] All store.Save() calls happen under wfMu mutex\n- [ ] No race conditions under concurrent \\`meow done\\` calls (test with -race)\n- [ ] ipcChan removed from Orchestrator (dead code cleanup)\n- [ ] Existing tests pass\n- [ ] New test: TestConcurrentStepCompletion with race detector\n\n## Testing Strategy\n\n\\`\\`\\`go\nfunc TestConcurrentStepCompletion(t *testing.T) {\n    // Setup workflow with 3 agent steps all running\n    // Launch 3 goroutines calling HandleStepDone simultaneously\n    // Verify all 3 completions are recorded (no lost updates)\n}\n\\`\\`\\`\n\nRun with: \\`go test -race ./internal/orchestrator/...\\`\n\n## Related\n\n- Parent epic: meow-aga\n- Follow-up: concurrency-002 (merge logic removal)\n- Spec reference: MVP-SPEC-v2.md §8 \"Orchestrator is the single writer\"","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-09T19:49:37.485254047-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:49:37.485254047-05:00"}
{"id":"meow-j5e","title":"Loader: Reference Resolution","description":"Extend template loader for module references (.local, file#workflow). Phase 2.","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.747251448-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:17.073541677-05:00","closed_at":"2026-01-08T22:14:17.073541677-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot (pivot-000). The three-tier bead model is replaced by workflow-centric architecture."}
{"id":"meow-j6rw","title":"Write parallel agent E2E tests","description":"# Task: Write Parallel Agent E2E Tests\n\n## Parent Feature\nmeow-1lh: Advanced E2E Test Suite\n\n## Objective\n\nImplement E2E tests verifying parallel agent execution and synchronization.\n\n## Test Cases\n\n1. **TestE2E_ParallelAgents_TwoAgents**: Two agents work in parallel\n2. **TestE2E_ParallelAgents_ThreeAgentsJoin**: Three agents with join step\n3. **TestE2E_ParallelAgents_DifferentDelays**: Agents complete at different times\n4. **TestE2E_ParallelAgents_OneFailsOthersContinue**: Failure isolation\n\n## Key Verifications\n\n- Agents start simultaneously (within tolerance)\n- All starts occur before any ends (true parallelism)\n- Join step waits for all agents\n- Failure in one doesn't affect others (with on_error=continue)\n\n## Acceptance Criteria\n\n1. [ ] All 4 test cases pass\n2. [ ] Tests verify parallel timing\n3. [ ] Tests verify synchronization\n4. [ ] Tests complete in \u003c20 seconds\n\n## Dependencies\n\n- meow-ag6: Core E2E Test Suite (all core tests)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T20:04:03.064016942-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:04:03.064016942-05:00","dependencies":[{"issue_id":"meow-j6rw","depends_on_id":"meow-03iq","type":"blocks","created_at":"2026-01-09T20:04:08.574786874-05:00","created_by":"ubuntu"},{"issue_id":"meow-j6rw","depends_on_id":"meow-r2bw","type":"blocks","created_at":"2026-01-09T20:04:08.717716856-05:00","created_by":"ubuntu"},{"issue_id":"meow-j6rw","depends_on_id":"meow-5y2m","type":"blocks","created_at":"2026-01-09T20:04:08.862829286-05:00","created_by":"ubuntu"}]}
{"id":"meow-j8q9","title":"Write crash recovery E2E tests","description":"Implement E2E tests for crash recovery. Test cases: orchestrator restart resumes workflow, running steps reset to pending, live agents reused, partial expansion cleaned up.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T20:04:17.745720919-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:04:17.745720919-05:00","dependencies":[{"issue_id":"meow-j8q9","depends_on_id":"meow-j6rw","type":"blocks","created_at":"2026-01-09T20:04:22.898362188-05:00","created_by":"ubuntu"}]}
{"id":"meow-jd7d","title":"Write happy path E2E tests","description":"# Task: Write Happy Path E2E Tests\n\n## Parent Feature\nmeow-ag6: Core E2E Test Suite\n\n## Objective\n\nImplement basic E2E tests that verify workflows complete successfully.\n\n## Test Cases\n\n### test/e2e/happy_path_test.go\n\n1. **TestE2E_SimpleWorkflow**: Single agent, single task, completes\n2. **TestE2E_MultiStepWorkflow**: Single agent, multiple sequential tasks\n3. **TestE2E_OutputChaining**: Output from step 1 used by step 2\n4. **TestE2E_ShellSteps**: Pure shell workflow (no agents)\n5. **TestE2E_SpawnKillLifecycle**: Agent spawned, works, killed correctly\n\n## Test Template\n\n```go\nfunc TestE2E_SimpleWorkflow(t *testing.T) {\n    h := e2e.NewHarness(t)\n    defer h.Cleanup()\n\n    h.ConfigureAgent(\"worker\", e2e.NewSimConfig().\n        OnPrompt(\".*\").Complete(map[string]any{\"result\": \"success\"}).\n        Build())\n\n    run := h.RunWorkflow(\"testdata/templates/simple.meow.toml\", nil)\n\n    require.NoError(t, run.WaitForDone(10*time.Second))\n    assert.Equal(t, \"done\", run.Status())\n    \n    val, ok := run.StepOutput(\"task\", \"result\")\n    assert.True(t, ok)\n    assert.Equal(t, \"success\", val)\n}\n```\n\n## Test Workflows\n\nCreate in test/e2e/testdata/templates/:\n- simple.meow.toml\n- multi-step.meow.toml\n- output-chain.meow.toml\n- shell-only.meow.toml\n\n## Acceptance Criteria\n\n1. [ ] All 5 test cases implemented\n2. [ ] Test workflows created\n3. [ ] Tests pass consistently (10 runs)\n4. [ ] Tests complete in \u003c10 seconds total\n\n## Dependencies\n\n- meow-hy8z: Workflow run helpers\n- meow-tr1q: Config builder\n\n## Estimated Size\n\nMedium (~300 lines including templates)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:03:23.050356397-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:03:23.050356397-05:00","dependencies":[{"issue_id":"meow-jd7d","depends_on_id":"meow-hy8z","type":"blocks","created_at":"2026-01-09T20:03:27.819338188-05:00","created_by":"ubuntu"},{"issue_id":"meow-jd7d","depends_on_id":"meow-tr1q","type":"blocks","created_at":"2026-01-09T20:03:27.928771368-05:00","created_by":"ubuntu"}]}
{"id":"meow-je8","title":"Implement sequential iteration","description":"Implement sequential execution when parallel=false.\n\nWhen parallel=false:\n- Chain iterations so each depends on the previous\n- Iteration N's first step should need iteration N-1's last step\n- This ensures ordered execution\n- Still respects the implicit join if join=true","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:36.56102572-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:36.56102572-05:00","dependencies":[{"issue_id":"meow-je8","depends_on_id":"meow-mfr","type":"blocks","created_at":"2026-01-09T15:04:18.723035802-05:00","created_by":"ubuntu"}]}
{"id":"meow-ji8","title":"Remove/simplify merge logic after IPC unification","description":"# Remove/Simplify Merge Logic After IPC Unification\n\n## Summary\n\nThe complex merge logic in \\`processWorkflow()\\` exists as a band-aid for the dual-path IPC problem. Once concurrency-001 is complete, this merge logic should be removed or dramatically simplified.\n\n## Context: Why The Merge Logic Exists\n\nCurrently, \\`processWorkflow()\\` re-reads the workflow before saving to avoid overwriting concurrent IPC handler updates:\n\n\\`\\`\\`go\n// orchestrator.go:269-303\nif len(dispatchedSteps) \u003e 0 {\n    freshWf, err := o.store.Get(ctx, wf.ID)  // Re-read\n    \n    // Merge states between our copy and fresh copy\n    for stepID, ourStep := range wf.Steps {\n        freshStep, ok := freshWf.GetStep(stepID)\n        // ... complex merge logic ...\n        ourRank := stepStatusRank(ourStep.Status)\n        freshRank := stepStatusRank(freshStep.Status)\n        if ourRank \u003e freshRank {\n            // Copy our changes to fresh\n        }\n    }\n    \n    return o.store.Save(ctx, freshWf)\n}\n\\`\\`\\`\n\nThis is a **defensive hack** because IPCHandler can modify state without coordination.\n\n## Problems with Current Merge Logic\n\n1. **Status rank treats done and failed as equal:**\n   \\`\\`\\`go\n   case types.StepStatusDone:\n       return 3\n   case types.StepStatusFailed:\n       return 3 // Same rank - which wins is arbitrary!\n   \\`\\`\\`\n\n2. **Only copies selected fields:** Missing fields like agent state updates.\n\n3. **Doesn't preserve outputs correctly:** If both paths set outputs, one is lost.\n\n4. **No timestamp-based resolution:** Can't determine which change is \"newer\".\n\n5. **Doesn't merge Agents map:** Agent state updates could be lost.\n\n## After IPC Unification\n\nOnce concurrency-001 is complete:\n- All state mutations go through Orchestrator (with mutex)\n- There are no concurrent writes to worry about\n- The merge logic becomes unnecessary complexity\n\n## Proposed Changes\n\n**Option A: Remove entirely**\n\\`\\`\\`go\nfunc (o *Orchestrator) processWorkflow(ctx context.Context, wf *types.Workflow) error {\n    o.wfMu.Lock()\n    defer o.wfMu.Unlock()\n    \n    // With unified IPC, no concurrent modifications possible\n    // Just save directly - no merge needed\n    if len(dispatchedSteps) \u003e 0 {\n        return o.store.Save(ctx, wf)\n    }\n    return nil\n}\n\\`\\`\\`\n\n**Option B: Simplify to validation-only**\nKeep a read-before-write pattern as a sanity check, but remove merge logic:\n\\`\\`\\`go\nif len(dispatchedSteps) \u003e 0 {\n    // Sanity check: verify no unexpected changes\n    freshWf, _ := o.store.Get(ctx, wf.ID)\n    if freshWf.Version != wf.Version {\n        // Log warning - shouldn't happen with unified IPC\n        o.logger.Warn(\"unexpected concurrent modification detected\")\n    }\n    return o.store.Save(ctx, wf)\n}\n\\`\\`\\`\n\n**Recommendation:** Option A (remove entirely). The mutex guarantees no concurrent modifications. Extra reads add latency without benefit.\n\n## Files to Modify\n\n- \\`internal/orchestrator/orchestrator.go\\`\n  - Remove \\`stepStatusRank()\\` function\n  - Remove merge loop in \\`processWorkflow()\\`\n  - Simplify save logic\n\n## Acceptance Criteria\n\n- [ ] Merge logic removed from processWorkflow\n- [ ] stepStatusRank() function removed\n- [ ] Direct save without re-read\n- [ ] All existing tests pass\n- [ ] No performance regression\n\n## Dependencies\n\n**Blocked by:** meow-ilr (IPC unification must be complete first)\n\n## Related\n\n- Parent epic: meow-aga\n- Blocks: concurrency-001 must complete first\n- Analysis: docs/CONCURRENCY-ANALYSIS.md \"Medium Issue: Flawed Merge Logic\"","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T19:50:21.709808741-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:50:21.709808741-05:00","dependencies":[{"issue_id":"meow-ji8","depends_on_id":"meow-ilr","type":"blocks","created_at":"2026-01-09T19:50:26.506352301-05:00","created_by":"ubuntu"}]}
{"id":"meow-ks2","title":"Track agents from start beads","description":"Identify agents from start beads for wisp detection. See IMPLEMENTATION-PLAN section meow-modules-baker-agents.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:05.698904749-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"YAGNI - With simplified tier detection, we don't scan for start beads. Tier is determined by workflow.Ephemeral property. Task types in ephemeral workflows are wisps, non-task types are orchestrator. Simple.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-kvj","title":"Implement fire_forget mode for agent executor","description":"## Background\n\nThe agent executor needs a `fire_forget` mode that injects a prompt and immediately marks the step done without waiting for `meow done`.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 3 (agent executor):\n\n```yaml\nmode: \"fire_forget\"  # Inject and immediately mark done\n```\n\n**Use Cases:**\n- Send `/compact` command to trigger context compaction\n- Send `Escape` key to pause agent mid-work\n- Inject nudge prompts from monitoring loops\n- Any command that doesn't need a response\n\n**Behavior:**\n1. Use full prompt injection mechanism (cancel copy mode, wait for readiness, retry)\n2. After successful injection, immediately mark step `done`\n3. Do NOT wait for `meow done` from agent\n4. Cannot have outputs (nothing to capture)\n\n## Implementation Notes\n\n- Add `fire_forget` to valid modes in AgentConfig\n- Modify handleAgent to check mode after injection\n- If fire_forget: mark done immediately, don't wait for IPC\n- Validate that outputs is empty when fire_forget mode\n\n## Success Criteria\n\n- [ ] fire_forget mode defined in AgentConfig\n- [ ] Agent executor handles fire_forget (inject + immediate done)\n- [ ] Validation: fire_forget steps cannot have outputs\n- [ ] Tests for fire_forget mode","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T15:45:29.378045351-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:50:33.804232696-05:00","closed_at":"2026-01-09T15:50:33.804232696-05:00","close_reason":"Duplicate of meow-7e1 which is already closed"}
{"id":"meow-l0l","title":"Implement meow trace command","description":"## Current State\n\nThe `meow trace` command is a stub that prints \"not yet implemented\".\n\n## Required Functionality\n\nShow execution trace for debugging:\n\n```bash\nmeow trace\n# Output: Recent orchestrator activity\n\nmeow trace --follow  # Stream live trace\nmeow trace --bead \u003cid\u003e  # Trace specific bead\n```\n\n## Implementation\n\nThe trace infrastructure exists in `internal/orchestrator/trace.go`:\n- `Tracer` - records events to JSONL\n- Trace file at `.meow/state/trace.jsonl`\n\n## File\n`cmd/meow/cmd/trace.go`\n\n## Acceptance Criteria\n- [ ] Reads trace.jsonl file\n- [ ] Formats events nicely\n- [ ] Filter by bead ID option\n- [ ] Follow mode for live streaming","status":"closed","priority":2,"issue_type":"task","assignee":"agent3","created_at":"2026-01-08T03:04:40.930748503-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:31.016708684-05:00","closed_at":"2026-01-08T03:27:31.016708684-05:00","close_reason":"Closed","labels":["cli","debugging"]}
{"id":"meow-ljo","title":"EPIC: Advanced Error Handling","description":"Implement template-based error recovery with _failed_step context. See MVP-SPEC-v2.md 'Error Handling' section.\n\nKey capabilities:\n- on_error accepts: 'fail', 'continue', or template reference\n- _failed_step context variables for recovery templates\n- Error type classification per executor\n- Recovery depth limiting\n- Retry count tracking across recovery attempts","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-09T15:03:13.139892713-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:13.139892713-05:00"}
{"id":"meow-lxc","title":"Handle attach_wisp in handleStart","description":"Bake wisp template when start bead has attach_wisp. See IMPLEMENTATION-PLAN section meow-modules-orch-start.","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.479863641-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"YAGNI - attach_wisp is over-engineered. Auto-detection via ephemeral=true workflow property plus hooks_to for HookBead linking handles all real use cases. No concrete example where explicit attachment is needed. Can resurrect if a real use case emerges.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-m3k","title":"Implement local reference resolution","description":"Resolve .workflow local references within module. See IMPLEMENTATION-PLAN section meow-modules-loader-local.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:05.416312985-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-mfr","title":"Implement foreach expansion logic","description":"Implement the core foreach expansion in the orchestrator.\n\nIn executeForeach():\n1. Evaluate items expression\n2. For each item in array:\n   a. Create variable context with item_var, index_var\n   b. Resolve template reference\n   c. Generate child step IDs with prefix: {foreach_id}.{index}.{step_id}\n   d. Expand template steps into workflow\n3. Track expanded_into list on foreach step\n4. Handle empty array case (no expansion, mark done immediately)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:34.204997756-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:34.204997756-05:00","dependencies":[{"issue_id":"meow-mfr","depends_on_id":"meow-qvy","type":"blocks","created_at":"2026-01-09T15:04:17.485635977-05:00","created_by":"ubuntu"},{"issue_id":"meow-mfr","depends_on_id":"meow-1mc","type":"blocks","created_at":"2026-01-09T15:04:17.618756788-05:00","created_by":"ubuntu"}]}
{"id":"meow-mjh7","title":"Create GitHub Actions E2E workflow","description":"Create .github/workflows/e2e.yml that runs E2E tests on PR and push to main. Includes: tmux installation, binary building, adapter installation, test execution with retry, artifact upload on failure.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T20:04:30.627637418-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:04:30.627637418-05:00","dependencies":[{"issue_id":"meow-mjh7","depends_on_id":"meow-hb7t","type":"blocks","created_at":"2026-01-09T20:04:36.356193489-05:00","created_by":"ubuntu"},{"issue_id":"meow-mjh7","depends_on_id":"meow-j8q9","type":"blocks","created_at":"2026-01-09T20:04:36.46369523-05:00","created_by":"ubuntu"},{"issue_id":"meow-mjh7","depends_on_id":"meow-xcab","type":"blocks","created_at":"2026-01-09T20:04:36.610167635-05:00","created_by":"ubuntu"}]}
{"id":"meow-mwc","title":"Implement meow steps command","description":"List all wisp steps for current agent. See IMPLEMENTATION-PLAN section meow-modules-cli-steps.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:24.968274416-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-n58","title":"Define resource limits configuration","description":"# Define Resource Limits Configuration\n\n## File: internal/config/limits.go\n\n## Purpose\n\nParse resource limits from .meow/config.toml to prevent runaway workflows from exhausting system resources.\n\n## Configuration Format\n\n\\`\\`\\`toml\n# .meow/config.toml\n\n[limits]\nmax_expansion_depth = 50       # Maximum nested expand/branch calls\nmax_total_steps = 1000         # Maximum steps in a single workflow\nmax_workflow_file_size = \"10MB\"  # Maximum workflow YAML file size\n\\`\\`\\`\n\n## Implementation\n\n\\`\\`\\`go\npackage config\n\n// Limits defines resource constraints for workflows.\ntype Limits struct {\n    MaxExpansionDepth    int    \\`toml:\"max_expansion_depth\"\\`\n    MaxTotalSteps        int    \\`toml:\"max_total_steps\"\\`\n    MaxWorkflowFileSize  string \\`toml:\"max_workflow_file_size\"\\`  // Parsed to bytes\n    maxFileSizeBytes     int64  // Computed from MaxWorkflowFileSize\n}\n\n// DefaultLimits returns generous defaults that should never trigger normally.\nfunc DefaultLimits() Limits {\n    return Limits{\n        MaxExpansionDepth:   100,\n        MaxTotalSteps:       10000,\n        MaxWorkflowFileSize: \"50MB\",\n        maxFileSizeBytes:    50 * 1024 * 1024,\n    }\n}\n\n// ParseFileSize converts human-readable sizes like \"10MB\" to bytes.\nfunc ParseFileSize(s string) (int64, error) {\n    // Handle KB, MB, GB suffixes\n    s = strings.ToUpper(strings.TrimSpace(s))\n    var multiplier int64 = 1\n    \n    if strings.HasSuffix(s, \"KB\") {\n        multiplier = 1024\n        s = strings.TrimSuffix(s, \"KB\")\n    } else if strings.HasSuffix(s, \"MB\") {\n        multiplier = 1024 * 1024\n        s = strings.TrimSuffix(s, \"MB\")\n    } else if strings.HasSuffix(s, \"GB\") {\n        multiplier = 1024 * 1024 * 1024\n        s = strings.TrimSuffix(s, \"GB\")\n    }\n    \n    n, err := strconv.ParseInt(strings.TrimSpace(s), 10, 64)\n    if err != nil {\n        return 0, fmt.Errorf(\"invalid size: %s\", s)\n    }\n    \n    return n * multiplier, nil\n}\n\n// Validate checks limits are reasonable and computes derived values.\nfunc (l *Limits) Validate() error {\n    if l.MaxExpansionDepth \u003c= 0 {\n        return fmt.Errorf(\"max_expansion_depth must be positive\")\n    }\n    if l.MaxTotalSteps \u003c= 0 {\n        return fmt.Errorf(\"max_total_steps must be positive\")\n    }\n    \n    bytes, err := ParseFileSize(l.MaxWorkflowFileSize)\n    if err != nil {\n        return fmt.Errorf(\"invalid max_workflow_file_size: %w\", err)\n    }\n    l.maxFileSizeBytes = bytes\n    \n    return nil\n}\n\n// MaxFileSizeBytes returns the file size limit in bytes.\nfunc (l *Limits) MaxFileSizeBytes() int64 {\n    return l.maxFileSizeBytes\n}\n\\`\\`\\`\n\n## Config Loading\n\n\\`\\`\\`go\n// Config is the full .meow/config.toml structure.\ntype Config struct {\n    Limits Limits \\`toml:\"limits\"\\`\n    // Other config sections...\n}\n\n// LoadConfig reads config from .meow/config.toml.\nfunc LoadConfig(dir string) (*Config, error) {\n    path := filepath.Join(dir, \"config.toml\")\n    \n    cfg := \u0026Config{\n        Limits: DefaultLimits(),\n    }\n    \n    data, err := os.ReadFile(path)\n    if os.IsNotExist(err) {\n        // No config file, use defaults\n        return cfg, nil\n    }\n    if err != nil {\n        return nil, fmt.Errorf(\"reading config: %w\", err)\n    }\n    \n    if err := toml.Unmarshal(data, cfg); err != nil {\n        return nil, fmt.Errorf(\"parsing config: %w\", err)\n    }\n    \n    if err := cfg.Limits.Validate(); err != nil {\n        return nil, fmt.Errorf(\"invalid limits: %w\", err)\n    }\n    \n    return cfg, nil\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Limits struct with all fields\n- [ ] DefaultLimits() returns generous defaults\n- [ ] ParseFileSize() handles KB, MB, GB\n- [ ] Validate() computes derived values\n- [ ] LoadConfig() reads from .meow/config.toml\n- [ ] Missing config file uses defaults\n- [ ] Unit tests for ParseFileSize\n- [ ] Unit tests for config loading","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T20:27:23.79889102-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:35.289307982-05:00","closed_at":"2026-01-08T22:14:35.289307982-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These features will be implemented as part of the new orchestrator architecture.","dependencies":[{"issue_id":"meow-n58","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T20:29:48.158644015-05:00","created_by":"ubuntu"}]}
{"id":"meow-nr7","title":"Create call pattern template","description":"Parent/child orchestration with attach_wisp. See IMPLEMENTATION-PLAN.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.576149517-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by v2 pivot - templates will be recreated","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-nsv","title":"Module System and Three-Tier Architecture","description":"Root epic for the module system and three-tier bead architecture. See docs/IMPLEMENTATION-PLAN-MODULES-AND-WISPS.md for full details.","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:16.142778125-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:17.060625551-05:00","closed_at":"2026-01-08T22:14:17.060625551-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot (pivot-000). The three-tier bead model is replaced by workflow-centric architecture."}
{"id":"meow-o3n","title":"Implement CLI entry point and flag parsing","description":"# Task: CLI Entry Point and Flag Parsing\n\n## Parent Feature\nmeow-a0z: Core Simulator Binary\n\n## Objective\n\nCreate the main entry point for meow-agent-sim with CLI flag parsing.\n\n## Implementation\n\n### File: cmd/meow-agent-sim/main.go\n\n```go\npackage main\n\nimport (\n    \"flag\"\n    \"fmt\"\n    \"os\"\n    \"log/slog\"\n)\n\nvar (\n    configPath          string\n    resumeSession       string\n    skipPermissions     bool  // Ignored, for Claude compatibility\n    logLevel            string\n)\n\nfunc init() {\n    flag.StringVar(\u0026configPath, \"config\", \"\", \"Path to behavior config YAML\")\n    flag.StringVar(\u0026resumeSession, \"resume\", \"\", \"Session ID to resume (ignored)\")\n    flag.BoolVar(\u0026skipPermissions, \"dangerously-skip-permissions\", false, \"Claude compatibility flag (ignored)\")\n    flag.StringVar(\u0026logLevel, \"log-level\", \"info\", \"Log level (debug/info/warn/error)\")\n}\n\nfunc main() {\n    flag.Parse()\n\n    // Allow env var override\n    if envConfig := os.Getenv(\"MEOW_SIM_CONFIG\"); envConfig != \"\" \u0026\u0026 configPath == \"\" {\n        configPath = envConfig\n    }\n    if envLevel := os.Getenv(\"MEOW_SIM_LOG_LEVEL\"); envLevel != \"\" {\n        logLevel = envLevel\n    }\n\n    // Setup logging\n    logger := setupLogger(logLevel)\n\n    // Load config\n    var config SimConfig\n    if configPath != \"\" {\n        var err error\n        config, err = LoadConfig(configPath)\n        if err != nil {\n            logger.Error(\"failed to load config\", \"path\", configPath, \"error\", err)\n            os.Exit(1)\n        }\n    } else {\n        config = DefaultConfig()\n    }\n\n    // Create and run simulator\n    sim := NewSimulator(config, logger)\n    if err := sim.Run(); err != nil {\n        logger.Error(\"simulator error\", \"error\", err)\n        os.Exit(1)\n    }\n}\n\nfunc setupLogger(level string) *slog.Logger {\n    var lvl slog.Level\n    switch level {\n    case \"debug\":\n        lvl = slog.LevelDebug\n    case \"info\":\n        lvl = slog.LevelInfo\n    case \"warn\":\n        lvl = slog.LevelWarn\n    case \"error\":\n        lvl = slog.LevelError\n    default:\n        lvl = slog.LevelInfo\n    }\n\n    return slog.New(slog.NewJSONHandler(os.Stderr, \u0026slog.HandlerOptions{Level: lvl}))\n}\n```\n\n## Environment Variables\n\nRead from environment:\n- MEOW_AGENT - Agent ID (set by orchestrator)\n- MEOW_WORKFLOW - Workflow ID (set by orchestrator)\n- MEOW_ORCH_SOCK - IPC socket path (set by orchestrator)\n- MEOW_SIM_CONFIG - Config path override\n- MEOW_SIM_LOG_LEVEL - Log level override\n\n## Acceptance Criteria\n\n1. [ ] Binary builds: go build ./cmd/meow-agent-sim\n2. [ ] --config flag works\n3. [ ] --dangerously-skip-permissions accepted (ignored)\n4. [ ] --resume accepted (stored for reference)\n5. [ ] Environment variable overrides work\n6. [ ] Logging to stderr in JSON format\n\n## Dependencies\n\nNone - this is the first task\n\n## Estimated Size\n\nSmall (~100 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T19:58:13.23616337-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:58:13.23616337-05:00"}
{"id":"meow-o7a","title":"orchestrator.go: Race condition in evalCondition() bead mutation","description":"## Location\n`internal/orchestrator/orchestrator.go:471-579`\n\n## Problem\n`evalCondition()` runs in a goroutine and mutates the bead object, then calls `store.Update()`. If the main loop's `tick()` reads the same bead concurrently, there's a race condition.\n\nFlow:\n1. `handleCondition()` marks bead as in_progress and spawns goroutine\n2. Goroutine runs `evalCondition()` which:\n   - Executes shell command (can take arbitrary time)\n   - Calls `bead.Close(nil)` - **mutates the bead**\n   - Calls `store.Update(ctx, bead)` - persists\n3. Meanwhile, main loop continues with `tick()`\n4. If tick() calls `GetNextReady()` which iterates beads, race on bead fields\n\nThe store uses locks for its internal map, but the **bead object itself is shared**.\n\n## Evidence\n```go\n// handleCondition spawns goroutine\ngo func() {\n    o.evalCondition(condCtx, bead)  // bead is a pointer\n}()\n\n// evalCondition mutates the bead\nif err := bead.Close(nil); err != nil {  // Mutation!\n    ...\n}\nif err := o.store.Update(ctx, bead); err != nil {\n    ...\n}\n```\n\n## Fix Options\n1. **Copy bead for goroutine**: Pass a copy, Update() stores the copy\n2. **Get fresh bead before mutation**: Re-fetch from store before Close()\n3. **Add bead-level locking**: More complex, probably overkill\n\n## Severity\nMEDIUM - Race condition under concurrent condition evaluation","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:31.808052643-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:33:02.083295535-05:00","closed_at":"2026-01-08T02:33:02.083295535-05:00","close_reason":"Fixed in commit 5ea5226. Changed evalCondition() signature to take beadID and spec instead of bead pointer."}
{"id":"meow-oore","title":"Implement tool event emission","description":"# Task: Implement Tool Event Emission\n\n## Parent Feature\nmeow-ur9: Hook Emulation System\n\n## Objective\n\nImplement tool event emission (tool-starting, tool-completed) during behavior execution.\n\n## Background\n\nClaude Code's hooks fire PreToolUse and PostToolUse events, which MEOW's event translator converts to:\n- `meow event tool-starting --data tool=ToolName`\n- `meow event tool-completed --data tool=ToolName`\n\nThese events enable:\n1. Workflow branches based on tool usage\n2. Context monitoring (detecting file writes)\n3. Progress tracking\n\n## Configuration\n\nBehaviors can define events to emit:\n\n```yaml\nbehaviors:\n  - match: \"process files\"\n    action:\n      type: complete\n      events:\n        - type: tool-starting\n          data: {tool: \"Read\"}\n          when: 0ms        # Emit immediately\n        - type: tool-completed\n          data: {tool: \"Read\"}\n          when: 100ms      # Emit after 100ms\n        - type: tool-starting\n          data: {tool: \"Write\"}\n          when: 200ms\n        - type: tool-completed\n          data: {tool: \"Write\"}\n          when: 500ms\n```\n\n## Implementation\n\n### File: cmd/meow-agent-sim/events.go\n\n```go\npackage main\n\nimport (\n    \"sort\"\n    \"time\"\n)\n\ntype EventDef struct {\n    Type string         `yaml:\"type\"`\n    Data map[string]any `yaml:\"data\"`\n    When time.Duration  `yaml:\"when\"`\n}\n\nfunc (s *Simulator) emitToolEvents(events []EventDef) {\n    if !s.config.Hooks.FireToolEvents || len(events) == 0 {\n        return\n    }\n\n    // Sort events by time\n    sorted := make([]EventDef, len(events))\n    copy(sorted, events)\n    sort.Slice(sorted, func(i, j int) bool {\n        return sorted[i].When \u003c sorted[j].When\n    })\n\n    // Emit events at specified times\n    start := time.Now()\n    for _, event := range sorted {\n        // Wait until event time\n        elapsed := time.Since(start)\n        if event.When \u003e elapsed {\n            time.Sleep(event.When - elapsed)\n        }\n\n        // Emit event\n        s.logger.Debug(\"emitting tool event\",\n            \"type\", event.Type,\n            \"data\", event.Data,\n        )\n\n        if err := s.ipc.Event(event.Type, event.Data); err != nil {\n            s.logger.Warn(\"failed to emit event\",\n                \"type\", event.Type,\n                \"error\", err,\n            )\n            // Continue - events are best-effort\n        }\n    }\n}\n```\n\n## Usage in Behavior Execution\n\n```go\nfunc (s *Simulator) actionComplete(a Action) error {\n    // Emit tool events during \"work\"\n    s.emitToolEvents(a.Events)\n\n    // Then complete\n    if err := s.ipc.StepDone(a.Outputs); err != nil {\n        return err\n    }\n\n    s.transitionTo(StateIdle)\n    return nil\n}\n```\n\n## Test Scenarios\n\n1. **Single event**: One tool-completed at 100ms\n2. **Multiple events**: Read start/end, Write start/end\n3. **Overlapping times**: Multiple events at same time\n4. **No events**: Config with empty events list\n\n## Acceptance Criteria\n\n1. [ ] Events emitted at configured times\n2. [ ] Events sorted by time before emission\n3. [ ] Event data passed correctly\n4. [ ] Disabled when fire_tool_events=false\n5. [ ] Failures don't stop execution\n6. [ ] All events logged\n\n## Dependencies\n\n- meow-ipc: IPC client (need Event method)\n- meow-behavior: Behavior engine (called from actionComplete)\n\n## Estimated Size\n\nSmall (~50 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:01:01.038663523-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:01:01.038663523-05:00","dependencies":[{"issue_id":"meow-oore","depends_on_id":"meow-vvr9","type":"blocks","created_at":"2026-01-09T20:01:06.820452131-05:00","created_by":"ubuntu"},{"issue_id":"meow-oore","depends_on_id":"meow-za1y","type":"blocks","created_at":"2026-01-09T20:01:06.939079153-05:00","created_by":"ubuntu"}]}
{"id":"meow-p3h","title":"Implement recovery depth limiting","description":"Implement depth limit to prevent infinite recovery loops.\n\nAdd tracking for recovery depth:\n- Track current recovery depth in workflow state\n- Increment when expanding a recovery template\n- Decrement when recovery completes successfully\n- Fail workflow if depth exceeds limit (default: 3)\n- Make limit configurable in workflow config\n\nAdd recovery_depth to resource limits configuration.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:29.111798979-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:29.111798979-05:00","dependencies":[{"issue_id":"meow-p3h","depends_on_id":"meow-ljo","type":"blocks","created_at":"2026-01-09T15:04:10.88321129-05:00","created_by":"ubuntu"},{"issue_id":"meow-p3h","depends_on_id":"meow-cql","type":"blocks","created_at":"2026-01-09T15:04:10.990893997-05:00","created_by":"ubuntu"}]}
{"id":"meow-p84","title":"Set HookBead links from variables","description":"Set HookBead links using workflow.HooksTo property per SPEC-ADDENDUM.\n\n## The hooks_to Property\n\nWorkflows declare which variable contains the work bead ID:\n\n```toml\n[implement]\nhooks_to = \"work_bead\"  # All wisps from this workflow link to {{work_bead}}\n\n[implement.variables]\nwork_bead = { required = true, type = \"bead_id\" }\n```\n\n## Baker Implementation\n\n```go\nfunc (b *Baker) setHookBead(bead *types.Bead, workflow *Workflow, vars map[string]string) {\n    // Only wisps get HookBead links\n    if bead.Tier != TierWisp {\n        return\n    }\n    \n    // Use workflow.HooksTo to find the variable name\n    if workflow.HooksTo == \"\" {\n        return  // No explicit linking\n    }\n    \n    // Get the bead ID from the variable\n    if hookID, ok := vars[workflow.HooksTo]; ok {\n        bead.HookBead = hookID\n    }\n}\n```\n\n## Key Change from Original Plan\n\n- **Before**: Magic detection via \"work_bead\" variable name\n- **After**: Explicit declaration via `workflow.HooksTo` property\n\n## File Location\nModify: `internal/template/baker.go`\n\n## Acceptance Criteria\n- [ ] Read HooksTo from workflow struct\n- [ ] Set HookBead only for wisp tier beads\n- [ ] Validate that HooksTo variable exists\n- [ ] Unit tests for HookBead linking","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:06.077463505-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Covered by meow-cac (vertical slice) which includes HookBead setting from hooks_to. Validation of HooksTo variable existence is part of module parsing in meow-ao5.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-p8v","title":"Implement join false fire-and-forget mode","description":"Implement fire-and-forget mode when join=false.\n\nWhen join=false:\n- foreach step marked 'done' immediately after expansion\n- Child iterations run independently\n- Downstream steps don't wait for iterations to complete\n- Child failures don't affect foreach step status\n- Useful for notifications, logging, cleanup tasks","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:39.408829277-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:39.408829277-05:00","dependencies":[{"issue_id":"meow-p8v","depends_on_id":"meow-mfr","type":"blocks","created_at":"2026-01-09T15:04:19.00741556-05:00","created_by":"ubuntu"}]}
{"id":"meow-p90","title":"module.go: Condition branch targets (on_true/on_false/on_timeout) not parsed","description":"## Location\n`internal/template/module.go:200-261`\n\n## Problem\nThe `parseModuleStep()` function does NOT parse `on_true`, `on_false`, or `on_timeout` fields from the step data map. These fields exist in the Step struct (parser.go:69-72) but are never extracted during module format parsing.\n\n## Impact\n- Condition beads in module-format templates will have nil branch targets\n- All conditional logic in module-format workflows is broken\n- Loops, gates, and branching patterns won't work\n\n## Expected Behavior\nThe parser should extract these fields:\n- `data[\"on_true\"]` → step.OnTrue\n- `data[\"on_false\"]` → step.OnFalse  \n- `data[\"on_timeout\"]` → step.OnTimeout\n\n## Severity\nHIGH - Core workflow functionality broken","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T02:22:25.442556921-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:35:17.508768962-05:00","closed_at":"2026-01-08T02:35:17.508768962-05:00","close_reason":"Fixed: Added parsing of on_true, on_false, and on_timeout fields in parseModuleStep()"}
{"id":"meow-qai","title":"E2E Testing Infrastructure with Claude Simulator","description":"# Epic: E2E Testing Infrastructure with Claude Simulator\n\n## Executive Summary\n\nBuild a comprehensive E2E testing infrastructure centered around a **Claude Simulator** - a binary that behaves identically to Claude Code from MEOW's perspective. This enables deterministic, fast, token-free testing of complex multi-agent workflows.\n\n## Problem Statement\n\nMEOW orchestrates AI agents through tmux sessions, IPC sockets, and hook-based event systems. Our current unit tests mock these interactions but cannot verify the full integration works correctly:\n\n- **Stop hook timing**: Does `meow prime` return the right prompt when Claude reaches idle?\n- **IPC round-trips**: Does single-line JSON parse correctly over Unix sockets?\n- **Event routing**: Do events match waiters with correct filtering?\n- **Crash recovery**: Do interrupted workflows resume correctly?\n\nTesting with real Claude Code:\n- Burns $0.01-0.10 per test run\n- Takes 30s-5min per workflow\n- Introduces LLM non-determinism\n- Requires internet connectivity\n\n## Solution\n\nA simulator binary (`meow-agent-sim`) that:\n1. **Implements Claude Code's behavioral contract** - presents prompt indicator, receives text via stdin, calls `meow done`\n2. **Emulates hooks** - fires Stop hook on idle, emits tool events\n3. **Is fully configurable** - YAML config defines responses to prompt patterns\n4. **Enables deterministic testing** - fixed delays, no randomization, explicit state transitions\n\n## Scope\n\n### In Scope\n- Core simulator binary with state machine\n- Behavior configuration system (YAML)\n- Hook emulation (Stop, PreToolUse, PostToolUse)\n- Simulator adapter for use in workflows\n- E2E test framework (harness, helpers, assertions)\n- Core test suites (stop hook, events, parallel, crash recovery)\n- CI integration\n\n### Out of Scope\n- GPU/resource simulation\n- Network partition testing\n- Performance benchmarking\n\n## Success Criteria\n\n1. All template patterns in `.meow/templates/` have corresponding E2E tests\n2. E2E tests run in \u003c60 seconds total\n3. Zero token cost for E2E testing\n4. Flakiness rate \u003c1% in CI\n\n## Key Design Decisions\n\n1. **Go binary, not bash script** - More robust state machine, better logging, direct IPC\n2. **Adapter-based integration** - Simulator is a drop-in replacement via adapter config\n3. **YAML behavior config** - Human-readable, version-controllable test scenarios\n4. **Isolated test environments** - Each test gets unique tmux socket, temp dirs\n\n## Reference Documents\n\n- `docs/E2E-TESTING-DESIGN.md` - Full technical specification\n- `docs/MVP-SPEC-v2.md` - Agent interaction model (Section: Agent Interaction Model)\n- `internal/orchestrator/agent_manager.go` - Current tmux/injection implementation\n- `internal/testutil/mock_claude.go` - Existing mock (inspiration, to be superseded)\n\n## Dependencies\n\nNone - this is foundational infrastructure\n\n## Risks\n\n| Risk | Mitigation |\n|------|------------|\n| Simulator doesn't match real Claude behavior | Validate against real Claude in staging |\n| Tests still flaky due to timing | Explicit synchronization, no sleeps |\n| Maintenance burden | Self-documenting configs, generated from templates |\n\n## Timeline Estimate\n\nNot specified - this is priority work for MVP quality assurance.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-09T19:52:27.917658069-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:52:27.917658069-05:00"}
{"id":"meow-qvy","title":"Implement items expression evaluation","description":"Implement logic to evaluate the 'items' expression to a JSON array.\n\nIn internal/orchestrator/executor_foreach.go:\n- Parse items expression (may contain variable references)\n- Substitute variables using existing variable resolver\n- Parse result as JSON array\n- Return []interface{} for iteration\n- Error if result is not a valid JSON array (error_type: invalid_items)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T15:03:32.086758869-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:32.086758869-05:00"}
{"id":"meow-r2bw","title":"Write output validation E2E tests","description":"Implement E2E tests for output type validation. Test cases: correct types pass, wrong type rejected and retried, missing required rejected, file_path validates existence. Verify error messages returned to agent.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:03:47.536213619-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:03:47.536213619-05:00","dependencies":[{"issue_id":"meow-r2bw","depends_on_id":"meow-jd7d","type":"blocks","created_at":"2026-01-09T20:03:52.871820084-05:00","created_by":"ubuntu"}]}
{"id":"meow-si8","title":"Add fsync for durable atomic writes","description":"# Add fsync for Durable Atomic Writes\n\n## Summary\n\nThe current atomic write implementation doesn't call \\`fsync()\\` before rename, which means data could be lost in a power failure scenario.\n\n## Current Implementation\n\n\\`\\`\\`go\n// yamlstore.go:114-134\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow) error {\n    data, err := yaml.Marshal(wf)\n    // ...\n    \n    // Write to temp file\n    if err := os.WriteFile(tmpPath, data, 0644); err != nil {\n        return fmt.Errorf(\"writing temp file: %w\", err)\n    }\n    \n    // Atomic rename\n    if err := os.Rename(tmpPath, mainPath); err != nil {\n        // ...\n    }\n}\n\\`\\`\\`\n\n## The Problem\n\n\\`os.WriteFile\\` doesn't guarantee data reaches disk:\n\n1. Data may sit in kernel buffer cache\n2. \\`Rename()\\` updates directory metadata (may flush sooner)\n3. Power fails before data buffer is written\n4. On recovery: file exists but content is truncated/empty\n\nThis is a well-known filesystem durability issue. The fix is to explicitly flush to disk before rename.\n\n## The Fix\n\n\\`\\`\\`go\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow) error {\n    data, err := yaml.Marshal(wf)\n    if err != nil {\n        return fmt.Errorf(\"marshaling workflow: %w\", err)\n    }\n\n    mainPath := filepath.Join(s.dir, wf.ID+\".yaml\")\n    tmpPath := mainPath + \".tmp\"\n\n    // Open file for writing\n    f, err := os.Create(tmpPath)\n    if err != nil {\n        return fmt.Errorf(\"creating temp file: %w\", err)\n    }\n\n    // Write data\n    if _, err := f.Write(data); err != nil {\n        f.Close()\n        os.Remove(tmpPath)\n        return fmt.Errorf(\"writing temp file: %w\", err)\n    }\n\n    // Sync to disk (the key addition)\n    if err := f.Sync(); err != nil {\n        f.Close()\n        os.Remove(tmpPath)\n        return fmt.Errorf(\"syncing temp file: %w\", err)\n    }\n\n    // Close before rename\n    if err := f.Close(); err != nil {\n        os.Remove(tmpPath)\n        return fmt.Errorf(\"closing temp file: %w\", err)\n    }\n\n    // Now rename is safe\n    if err := os.Rename(tmpPath, mainPath); err != nil {\n        os.Remove(tmpPath)\n        return fmt.Errorf(\"renaming temp file: %w\", err)\n    }\n\n    return nil\n}\n\\`\\`\\`\n\n## Performance Considerations\n\n\\`fsync()\\` is slow (can be 10-100ms on spinning disks, 1-10ms on SSD). Options:\n\n1. **Always sync (recommended):** Durability is important for orchestrator state\n2. **Batch syncs:** Accumulate changes, sync periodically (adds complexity)\n3. **Configurable:** Let users trade durability for performance\n\nFor MEOW, correctness matters more than performance. A 10ms overhead per save is acceptable given workflows don't save frequently (only on step transitions).\n\n## Severity Assessment\n\n**Low severity** because:\n- Power failures during writes are rare\n- Most systems have battery-backed write caches\n- Impact is limited to one workflow's state\n\nBut it's easy to fix and aligns with MEOW's \"durable execution\" promise.\n\n## Files to Modify\n\n- \\`internal/orchestrator/yamlstore.go\\` - Add fsync to Save()\n\n## Acceptance Criteria\n\n- [ ] Save() calls f.Sync() before rename\n- [ ] Proper error handling for sync failure\n- [ ] All tests pass\n- [ ] Benchmark: confirm acceptable overhead\n\n## Testing\n\n\\`\\`\\`go\nfunc TestSaveWithSync(t *testing.T) {\n    // This is hard to test for actual durability\n    // but we can verify the code path executes\n}\n\nfunc BenchmarkSave(b *testing.B) {\n    // Measure overhead of fsync\n    // Should be \u003c 20ms per save\n}\n\\`\\`\\`\n\n## Dependencies\n\nNone - can be done independently.\n\n## Related\n\n- Parent epic: meow-aga\n- Analysis: docs/CONCURRENCY-ANALYSIS.md \"Low Issue: No fsync Before Rename\"\n- Reference: https://www.sqlite.org/atomiccommit.html (SQLite's approach)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-09T19:51:14.320554983-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:51:14.320554983-05:00"}
{"id":"meow-sqc","title":"Types: Three-Tier Bead Metadata","description":"Extend bead types for three-tier visibility model. Phase 1 foundation.","notes":"Updated for SPEC-ADDENDUM refinements (2026-01-07):\n- Closed meow-db2 (hooked status removed from spec)\n- Added meow-x9z (gate bead type)  \n- Added meow-1l1 (collaborative bead type for interactive steps)\n- meow-bba now includes explicit Tier field and all 8 bead types\n- Labels are optional, Tier field is primary\n\nThe 8 bead types are now:\n- Agent-executable: task, collaborative, gate\n- Orchestrator-executable: start, stop, condition, code, expand","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.65411519-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:17.069756151-05:00","closed_at":"2026-01-08T22:14:17.069756151-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot (pivot-000). The three-tier bead model is replaced by workflow-centric architecture."}
{"id":"meow-tr1q","title":"Implement simulator config builder","description":"# Task: Implement Simulator Config Builder\n\n## Parent Feature\nmeow-gnf: E2E Test Framework\n\n## Objective\n\nCreate a fluent builder for simulator configurations, making tests readable and maintainable.\n\n## Usage Example\n\n```go\nconfig := NewSimConfig().\n    OnPrompt(\"Write tests\").Complete(map[string]any{\"file\": \"test.ts\"}).\n    OnPrompt(\"implement.*\").AsRegex().Complete(map[string]any{\"result\": \"done\"}).\n    OnPrompt(\"review\").Ask(\"Found issues. Continue?\").\n    OnPrompt(\"fail-test\").Fail(\"Intentional failure\").\n    DefaultComplete(map[string]any{}).\n    Build()\n```\n\n## Implementation\n\n### File: internal/testutil/e2e/sim_config.go\n\nBuilder pattern with:\n- SimConfigBuilder for overall config\n- BehaviorBuilder for individual behaviors\n- Type-safe action methods (Complete, Ask, Fail, etc.)\n\n## Acceptance Criteria\n\n1. [ ] Builder creates valid YAML\n2. [ ] All action types supported\n3. [ ] Regex patterns work\n4. [ ] Defaults applied correctly\n5. [ ] Fluent API is chainable\n\n## Dependencies\n\n- meow-two3: Test harness (shares types)\n\n## Estimated Size\n\nMedium (~200 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:02:51.448220487-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:02:51.448220487-05:00","dependencies":[{"issue_id":"meow-tr1q","depends_on_id":"meow-two3","type":"blocks","created_at":"2026-01-09T20:02:56.726173343-05:00","created_by":"ubuntu"}]}
{"id":"meow-two3","title":"Implement E2E test harness","description":"# Task: Implement E2E Test Harness\n\n## Parent Feature\nmeow-gnf: E2E Test Framework\n\n## Objective\n\nCreate the test harness that provides isolated test environments for E2E tests.\n\n## Responsibilities\n\n1. Create isolated temp directory\n2. Set up dedicated tmux socket\n3. Install simulator adapter\n4. Configure agent simulators\n5. Start/stop workflows\n6. Clean up resources\n\n## Implementation\n\n### File: internal/testutil/e2e/harness.go\n\n```go\npackage e2e\n\nimport (\n    \"os\"\n    \"os/exec\"\n    \"path/filepath\"\n    \"testing\"\n)\n\ntype Harness struct {\n    t          *testing.T\n    tempDir    string\n    tmuxSocket string\n    meowDir    string\n    binDir     string\n    simConfigs map[string]string // agentID -\u003e config path\n    workflows  []*WorkflowRun\n}\n\nfunc NewHarness(t *testing.T) *Harness {\n    t.Helper()\n\n    tempDir := t.TempDir()\n    tmuxSocket := filepath.Join(tempDir, \"tmux.sock\")\n    meowDir := filepath.Join(tempDir, \".meow\")\n    binDir := filepath.Join(tempDir, \"bin\")\n\n    // Create directory structure\n    for _, dir := range []string{\n        meowDir,\n        filepath.Join(meowDir, \"workflows\"),\n        filepath.Join(meowDir, \"adapters\"),\n        binDir,\n    } {\n        if err := os.MkdirAll(dir, 0755); err != nil {\n            t.Fatalf(\"creating directory %s: %v\", dir, err)\n        }\n    }\n\n    h := \u0026Harness{\n        t:          t,\n        tempDir:    tempDir,\n        tmuxSocket: tmuxSocket,\n        meowDir:    meowDir,\n        binDir:     binDir,\n        simConfigs: make(map[string]string),\n    }\n\n    // Install simulator adapter\n    h.installSimulatorAdapter()\n\n    // Symlink binaries (assume they're built)\n    h.setupBinaries()\n\n    return h\n}\n\nfunc (h *Harness) installSimulatorAdapter() {\n    // Copy from test/adapters/simulator to temp .meow/adapters/simulator\n    src := findTestAdapterDir()\n    dst := filepath.Join(h.meowDir, \"adapters\", \"simulator\")\n\n    if err := copyDir(src, dst); err != nil {\n        h.t.Fatalf(\"installing simulator adapter: %v\", err)\n    }\n}\n\nfunc (h *Harness) setupBinaries() {\n    // Find built binaries\n    meowBin := findBinary(\"meow\")\n    simBin := findBinary(\"meow-agent-sim\")\n\n    // Symlink to temp bin dir\n    os.Symlink(meowBin, filepath.Join(h.binDir, \"meow\"))\n    os.Symlink(simBin, filepath.Join(h.binDir, \"meow-agent-sim\"))\n}\n\nfunc (h *Harness) ConfigureAgent(agentID string, config SimConfig) {\n    h.t.Helper()\n\n    configPath := filepath.Join(h.tempDir, agentID+\"-sim.yaml\")\n    if err := writeYAML(configPath, config); err != nil {\n        h.t.Fatalf(\"writing sim config: %v\", err)\n    }\n\n    h.simConfigs[agentID] = configPath\n}\n\nfunc (h *Harness) RunWorkflow(templatePath string, vars map[string]string) *WorkflowRun {\n    h.t.Helper()\n\n    // Inject sim_config for each agent\n    allVars := make(map[string]string)\n    for k, v := range vars {\n        allVars[k] = v\n    }\n    for agentID, configPath := range h.simConfigs {\n        allVars[\"sim_config_\"+agentID] = configPath\n    }\n\n    run := newWorkflowRun(h, templatePath, allVars)\n    h.workflows = append(h.workflows, run)\n\n    return run\n}\n\nfunc (h *Harness) Cleanup() {\n    // Kill any running workflows\n    for _, wf := range h.workflows {\n        wf.Stop()\n    }\n\n    // Kill tmux server\n    exec.Command(\"tmux\", \"-S\", h.tmuxSocket, \"kill-server\").Run()\n\n    // t.TempDir() handles directory cleanup\n}\n\nfunc (h *Harness) TempDir() string {\n    return h.tempDir\n}\n\nfunc (h *Harness) MeowDir() string {\n    return h.meowDir\n}\n\n// Environment returns env vars for running meow commands\nfunc (h *Harness) Environment() []string {\n    return []string{\n        \"PATH=\" + h.binDir + \":\" + os.Getenv(\"PATH\"),\n        \"MEOW_HOME=\" + h.meowDir,\n        \"TMUX_TMPDIR=\" + h.tempDir,\n    }\n}\n```\n\n## Isolation Guarantees\n\nEach test gets:\n- Unique temp directory (via t.TempDir())\n- Dedicated tmux socket (no shared sessions)\n- Separate .meow directory (no config pollution)\n- Own simulator configs (per-agent behavior)\n\n## Acceptance Criteria\n\n1. [ ] Creates isolated temp directory\n2. [ ] Installs simulator adapter\n3. [ ] Sets up binary symlinks\n4. [ ] ConfigureAgent writes YAML config\n5. [ ] RunWorkflow starts orchestrator\n6. [ ] Cleanup kills tmux and workflows\n\n## Dependencies\n\nNone - this is foundational\n\n## Estimated Size\n\nMedium (~200 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:02:32.09596077-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:02:32.09596077-05:00"}
{"id":"meow-ur9","title":"Feature: Hook Emulation System","description":"# Feature: Hook Emulation System\n\n## Parent Epic\nmeow-qai: E2E Testing Infrastructure with Claude Simulator\n\n## Overview\n\nImplement Claude Code's hook system within the simulator. This is what makes the simulator behave like a real agent - it fires events and queries the orchestrator when transitioning to idle state.\n\n## Background: How Claude Code Hooks Work\n\nWhen Claude Code reaches the prompt (waiting for user input), it triggers a \"Stop\" hook. MEOW configures this hook via `.claude/settings.json` to:\n\n1. Call `event-translator.sh Stop` → which runs `meow event agent-stopped`\n2. Call `meow prime --format prompt` → returns next prompt or empty string\n\nThis is the \"Ralph Wiggum loop\" - if Claude stops unexpectedly (asks a question, hits an error), the stop hook fires, and `meow prime` returns the current prompt, nudging Claude to continue.\n\n## What the Simulator Must Do\n\n### Stop Hook Emulation\n\nWhen transitioning to IDLE state (showing prompt):\n\n```\n1. Call: meow event agent-stopped\n   - Fire-and-forget, don't wait for response\n   - Uses IPC socket directly (MEOW_ORCH_SOCK)\n\n2. Call: meow prime --format prompt\n   - Wait for response\n   - If prompt returned AND not in ASKING state:\n     → Feed prompt to self as input (continue working)\n   - If empty OR in ASKING state:\n     → Stay at prompt, wait for external input\n```\n\nThis emulates the Claude behavior where:\n- In autonomous mode: stop hook returns current prompt, agent continues\n- In interactive mode: stop hook returns empty, agent waits for human\n\n### Tool Event Emulation\n\nDuring WORKING state, optionally emit tool events:\n\n```\nBefore action: meow event tool-starting --data tool=Read\nAfter action: meow event tool-completed --data tool=Read\n```\n\nThese enable testing of:\n- Event routing to await-event waiters\n- Context monitor pattern (detecting tool usage)\n- Workflow branches based on tool events\n\n## Configuration\n\n```yaml\nhooks:\n  fire_stop_hook: true      # Whether to call meow event + meow prime\n  fire_tool_events: true    # Whether to emit tool events\n  stop_hook_delay: 10ms     # Delay after transitioning to idle\n  tool_event_delay: 5ms     # Delay around tool events\n```\n\nBehaviors can specify tool events:\n```yaml\nbehaviors:\n  - match: \"process files\"\n    action:\n      type: complete\n      events:\n        - {type: tool-starting, data: {tool: Read}, when: 0ms}\n        - {type: tool-completed, data: {tool: Read}, when: 100ms}\n        - {type: tool-starting, data: {tool: Write}, when: 200ms}\n        - {type: tool-completed, data: {tool: Write}, when: 500ms}\n```\n\n## IPC Client\n\nThe simulator needs to communicate with the orchestrator. Options:\n\n1. **Shell out to meow CLI** - Simple but slow, extra process overhead\n2. **Direct IPC client** - Fast, same socket protocol, more code\n\nRecommendation: **Direct IPC client** for:\n- Lower latency (important for stop hook)\n- Better error handling\n- Structured logging\n\n```go\n// internal/sim/ipc.go\ntype IPCClient struct {\n    socketPath string\n}\n\nfunc (c *IPCClient) Event(eventType string, data map[string]any) error\nfunc (c *IPCClient) GetPrompt() (string, error)\nfunc (c *IPCClient) StepDone(outputs map[string]any) error\n```\n\n## State Machine Updates\n\nThe hook system integrates with state transitions:\n\n```\nWORKING → IDLE:\n  1. Complete action (meow done or equivalent)\n  2. Wait for ack\n  3. Transition to IDLE\n  4. If hooks.fire_stop_hook:\n     a. Call meow event agent-stopped\n     b. Call meow prime\n     c. If prompt returned and not ASKING:\n        - Feed prompt to self\n        - Transition back to WORKING\n\nWORKING → ASKING:\n  1. Print question\n  2. Transition to ASKING\n  3. If hooks.fire_stop_hook:\n     a. Call meow event agent-stopped\n     b. Call meow prime (returns empty in interactive mode)\n     c. Stay in ASKING, wait for user input\n```\n\n## Acceptance Criteria\n\n1. [ ] Stop hook fires on IDLE transition\n2. [ ] `meow event agent-stopped` sent to orchestrator\n3. [ ] `meow prime` returns prompt for autonomous steps\n4. [ ] `meow prime` returns empty for interactive steps\n5. [ ] Self-injection works (prompt fed back to simulator)\n6. [ ] Tool events emit at configured times\n7. [ ] All IPC calls logged for debugging\n\n## Dependencies\n\n- meow-a0z: Core Simulator Binary (need state machine first)\n\n## Testing\n\nTest scenarios:\n1. Stop hook fires exactly once per IDLE transition\n2. Self-injection creates the \"Ralph Wiggum loop\"\n3. Interactive mode stays at prompt (no self-injection)\n4. Tool events appear in orchestrator event router\n\n## Reference\n\n- `docs/MVP-SPEC-v2.md` - Section: The Stop Hook (Recovery Mechanism)\n- `internal/adapter/builtin/event_translator.sh` - Current hook implementation\n- `internal/orchestrator/ipc_handler.go` - HandleGetPrompt logic","status":"open","priority":1,"issue_type":"feature","created_at":"2026-01-09T19:53:42.342324027-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:53:42.342324027-05:00","dependencies":[{"issue_id":"meow-ur9","depends_on_id":"meow-a0z","type":"blocks","created_at":"2026-01-09T19:53:47.762707236-05:00","created_by":"ubuntu"}]}
{"id":"meow-v0bp","title":"Implement YAML config loading","description":"# Task: Implement YAML Config Loading\n\n## Parent Feature\nmeow-a0z: Core Simulator Binary\n\n## Objective\n\nImplement loading of simulator behavior configuration from YAML files.\n\n## Config Structure\n\n```yaml\ntiming:\n  startup_delay: 100ms\n  default_work_delay: 500ms\n  prompt_delay: 50ms\n\nhooks:\n  fire_stop_hook: true\n  fire_tool_events: true\n\nbehaviors:\n  - match: \"pattern\"\n    type: contains  # or regex\n    action:\n      type: complete\n      delay: 100ms\n      outputs:\n        key: value\n\ndefault:\n  action:\n    type: complete\n    delay: 100ms\n\nlogging:\n  level: info\n  format: json\n```\n\n## Implementation\n\n### File: cmd/meow-agent-sim/config.go\n\n```go\npackage main\n\nimport (\n    \"os\"\n    \"time\"\n\n    \"gopkg.in/yaml.v3\"\n)\n\ntype SimConfig struct {\n    Timing    TimingConfig   `yaml:\"timing\"`\n    Hooks     HooksConfig    `yaml:\"hooks\"`\n    Behaviors []Behavior     `yaml:\"behaviors\"`\n    Default   DefaultConfig  `yaml:\"default\"`\n    Logging   LoggingConfig  `yaml:\"logging\"`\n}\n\ntype TimingConfig struct {\n    StartupDelay     time.Duration `yaml:\"startup_delay\"`\n    DefaultWorkDelay time.Duration `yaml:\"default_work_delay\"`\n    PromptDelay      time.Duration `yaml:\"prompt_delay\"`\n}\n\ntype HooksConfig struct {\n    FireStopHook   bool `yaml:\"fire_stop_hook\"`\n    FireToolEvents bool `yaml:\"fire_tool_events\"`\n}\n\ntype DefaultConfig struct {\n    Behavior Behavior `yaml:\"behavior\"`\n}\n\ntype LoggingConfig struct {\n    Level  string `yaml:\"level\"`\n    Format string `yaml:\"format\"`\n}\n\nfunc LoadConfig(path string) (SimConfig, error) {\n    data, err := os.ReadFile(path)\n    if err != nil {\n        return SimConfig{}, fmt.Errorf(\"reading config: %w\", err)\n    }\n\n    var config SimConfig\n    if err := yaml.Unmarshal(data, \u0026config); err != nil {\n        return SimConfig{}, fmt.Errorf(\"parsing config: %w\", err)\n    }\n\n    // Apply defaults for missing fields\n    applyDefaults(\u0026config)\n\n    return config, nil\n}\n\nfunc DefaultConfig() SimConfig {\n    return SimConfig{\n        Timing: TimingConfig{\n            StartupDelay:     100 * time.Millisecond,\n            DefaultWorkDelay: 100 * time.Millisecond,\n            PromptDelay:      10 * time.Millisecond,\n        },\n        Hooks: HooksConfig{\n            FireStopHook:   true,\n            FireToolEvents: true,\n        },\n        Default: DefaultConfig{\n            Behavior: Behavior{\n                Action: Action{\n                    Type:    ActionComplete,\n                    Delay:   100 * time.Millisecond,\n                    Outputs: map[string]any{},\n                },\n            },\n        },\n        Logging: LoggingConfig{\n            Level:  \"info\",\n            Format: \"json\",\n        },\n    }\n}\n\nfunc applyDefaults(c *SimConfig) {\n    d := DefaultConfig()\n\n    if c.Timing.StartupDelay == 0 {\n        c.Timing.StartupDelay = d.Timing.StartupDelay\n    }\n    if c.Timing.DefaultWorkDelay == 0 {\n        c.Timing.DefaultWorkDelay = d.Timing.DefaultWorkDelay\n    }\n    // ... apply other defaults\n}\n```\n\n## Acceptance Criteria\n\n1. [ ] YAML parsing works\n2. [ ] Duration fields parse correctly (100ms, 1s, etc.)\n3. [ ] Missing fields get defaults\n4. [ ] DefaultConfig() returns valid config\n5. [ ] Error messages are helpful\n\n## Dependencies\n\n- meow-o3n: CLI entry point (need to call from main)\n\n## Estimated Size\n\nSmall (~150 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:00:53.578703128-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:00:53.578703128-05:00","dependencies":[{"issue_id":"meow-v0bp","depends_on_id":"meow-o3n","type":"blocks","created_at":"2026-01-09T20:01:00.700955927-05:00","created_by":"ubuntu"}]}
{"id":"meow-v5j","title":"Implement resource limits enforcement","description":"# Implement Resource Limits Enforcement\n\n## File: internal/orchestrator/limits.go\n\n## Purpose\n\nEnforce resource limits during workflow execution to prevent runaway expansions and resource exhaustion.\n\n## Enforcement Points\n\n### 1. Expansion Depth (in expand/branch executors)\n\n\\`\\`\\`go\n// ExpansionContext tracks depth during recursive expansion.\ntype ExpansionContext struct {\n    Depth    int\n    MaxDepth int\n}\n\nfunc (e *ExpandExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow, expCtx *ExpansionContext) error {\n    // Check depth limit\n    if expCtx.Depth \u003e= expCtx.MaxDepth {\n        return \u0026LimitExceededError{\n            Limit: \"max_expansion_depth\",\n            Value: expCtx.Depth,\n            Max:   expCtx.MaxDepth,\n        }\n    }\n    \n    // Increment depth for child expansions\n    childCtx := \u0026ExpansionContext{\n        Depth:    expCtx.Depth + 1,\n        MaxDepth: expCtx.MaxDepth,\n    }\n    \n    // ... expand template with childCtx ...\n}\n\\`\\`\\`\n\n### 2. Total Steps (after each expansion)\n\n\\`\\`\\`go\nfunc (e *ExpandExecutor) Execute(ctx context.Context, step *types.Step, wf *types.Workflow, expCtx *ExpansionContext) error {\n    // ... expand template ...\n    \n    // Check total steps\n    if len(wf.Steps) \u003e e.limits.MaxTotalSteps {\n        return \u0026LimitExceededError{\n            Limit: \"max_total_steps\",\n            Value: len(wf.Steps),\n            Max:   e.limits.MaxTotalSteps,\n        }\n    }\n}\n\\`\\`\\`\n\n### 3. Workflow File Size (before persist)\n\n\\`\\`\\`go\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow, limits *config.Limits) error {\n    data, err := yaml.Marshal(wf)\n    if err != nil {\n        return fmt.Errorf(\"marshaling workflow: %w\", err)\n    }\n    \n    // Check file size\n    if int64(len(data)) \u003e limits.MaxFileSizeBytes() {\n        return \u0026LimitExceededError{\n            Limit: \"max_workflow_file_size\",\n            Value: int(len(data)),\n            Max:   int(limits.MaxFileSizeBytes()),\n        }\n    }\n    \n    // ... atomic write ...\n}\n\\`\\`\\`\n\n## Error Type\n\n\\`\\`\\`go\n// LimitExceededError indicates a resource limit was hit.\ntype LimitExceededError struct {\n    Limit string // Which limit: max_expansion_depth, max_total_steps, max_workflow_file_size\n    Value int    // Current value\n    Max   int    // Configured maximum\n}\n\nfunc (e *LimitExceededError) Error() string {\n    return fmt.Sprintf(\"%s exceeded: %d (max: %d)\", e.Limit, e.Value, e.Max)\n}\n\n// IsLimitExceeded checks if an error is a limit exceeded error.\nfunc IsLimitExceeded(err error) bool {\n    var le *LimitExceededError\n    return errors.As(err, \u0026le)\n}\n\\`\\`\\`\n\n## Orchestrator Integration\n\n\\`\\`\\`go\nfunc (o *Orchestrator) executeStep(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    err := o.dispatchers[step.Executor].Execute(ctx, step, wf, o.expCtx)\n    \n    if IsLimitExceeded(err) {\n        // Limit hit - fail the step\n        step.Fail(\u0026types.StepError{\n            Message: err.Error(),\n        })\n        \n        // Check on_error behavior\n        if step.Shell != nil \u0026\u0026 step.Shell.OnError == \"continue\" {\n            return nil // Continue despite limit\n        }\n        \n        // Default: fail the workflow\n        wf.Fail()\n        return err\n    }\n    \n    return err\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] ExpansionContext tracks depth\n- [ ] Expand/branch executors check depth limit\n- [ ] Total steps checked after expansion\n- [ ] File size checked before persist\n- [ ] LimitExceededError type with clear messages\n- [ ] Integration with orchestrator error handling\n- [ ] on_error: continue respects limits (step fails but workflow continues)\n- [ ] Unit tests for each enforcement point\n- [ ] Integration test hitting each limit type","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T20:27:47.486522459-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:35.287534695-05:00","closed_at":"2026-01-08T22:14:35.287534695-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These features will be implemented as part of the new orchestrator architecture.","dependencies":[{"issue_id":"meow-v5j","depends_on_id":"meow-n58","type":"blocks","created_at":"2026-01-08T20:29:48.25269027-05:00","created_by":"ubuntu"},{"issue_id":"meow-v5j","depends_on_id":"pivot-405","type":"blocks","created_at":"2026-01-08T20:29:48.347185036-05:00","created_by":"ubuntu"},{"issue_id":"meow-v5j","depends_on_id":"meow-405","type":"blocks","created_at":"2026-01-08T20:29:48.347185036-05:00","created_by":"ubuntu"}]}
{"id":"meow-vhy","title":"EPIC: Wildcard Dependencies","description":"Implement wildcard pattern matching in the needs field for dynamic dependencies. See MVP-SPEC-v2.md 'Wildcard Dependencies' section.\n\nKey capabilities:\n- Pattern syntax: * matches any single path segment\n- Runtime evaluation against existing step IDs\n- Works with foreach expanded steps\n- Empty match set = dependency satisfied\n\nExamples:\n- needs: ['parallel-workers.*']\n- needs: ['parallel-workers.*.implement']\n- needs: ['feature-*.test']","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-09T15:03:13.22879177-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:13.22879177-05:00"}
{"id":"meow-vvr9","title":"Implement direct IPC client","description":"# Task: Implement Direct IPC Client\n\n## Parent Feature\nmeow-a0z: Core Simulator Binary\n\n## Objective\n\nImplement a direct IPC client for communicating with the orchestrator, avoiding the overhead of shelling out to the meow CLI.\n\n## Why Direct IPC?\n\n1. **Lower latency**: No process spawn overhead\n2. **Better error handling**: Structured errors, not string parsing\n3. **Easier testing**: Can mock the client\n4. **Consistent logging**: All IPC calls logged uniformly\n\n## Protocol\n\n- Transport: Unix domain socket (path from MEOW_ORCH_SOCK)\n- Format: Newline-delimited JSON\n- Request-response pattern\n\n## Implementation\n\n### File: cmd/meow-agent-sim/ipc.go\n\n```go\npackage main\n\nimport (\n    \"bufio\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net\"\n    \"os\"\n)\n\ntype IPCClient struct {\n    socketPath string\n    logger     *slog.Logger\n}\n\nfunc NewIPCClient(socketPath string) *IPCClient {\n    return \u0026IPCClient{\n        socketPath: socketPath,\n    }\n}\n\nfunc (c *IPCClient) SetLogger(logger *slog.Logger) {\n    c.logger = logger\n}\n\n// StepDone signals step completion with outputs\nfunc (c *IPCClient) StepDone(outputs map[string]any) error {\n    msg := map[string]any{\n        \"type\":     \"step_done\",\n        \"workflow\": os.Getenv(\"MEOW_WORKFLOW\"),\n        \"agent\":    os.Getenv(\"MEOW_AGENT\"),\n        \"step\":     os.Getenv(\"MEOW_STEP\"),\n        \"outputs\":  outputs,\n    }\n\n    resp, err := c.send(msg)\n    if err != nil {\n        return err\n    }\n\n    if resp[\"type\"] == \"error\" {\n        return fmt.Errorf(\"orchestrator error: %v\", resp[\"message\"])\n    }\n\n    return nil\n}\n\n// GetPrompt requests the current prompt for stop hook\nfunc (c *IPCClient) GetPrompt() (string, error) {\n    msg := map[string]any{\n        \"type\":  \"get_prompt\",\n        \"agent\": os.Getenv(\"MEOW_AGENT\"),\n    }\n\n    resp, err := c.send(msg)\n    if err != nil {\n        return \"\", err\n    }\n\n    if resp[\"type\"] == \"error\" {\n        return \"\", fmt.Errorf(\"orchestrator error: %v\", resp[\"message\"])\n    }\n\n    content, _ := resp[\"content\"].(string)\n    return content, nil\n}\n\n// Event emits an event (fire-and-forget)\nfunc (c *IPCClient) Event(eventType string, data map[string]any) error {\n    msg := map[string]any{\n        \"type\":       \"event\",\n        \"event_type\": eventType,\n        \"data\":       data,\n        \"workflow\":   os.Getenv(\"MEOW_WORKFLOW\"),\n        \"agent\":      os.Getenv(\"MEOW_AGENT\"),\n    }\n\n    // Fire and forget - ignore response\n    _, err := c.send(msg)\n    return err\n}\n\n// send sends a message and waits for response\nfunc (c *IPCClient) send(msg map[string]any) (map[string]any, error) {\n    if c.socketPath == \"\" {\n        return nil, fmt.Errorf(\"MEOW_ORCH_SOCK not set\")\n    }\n\n    conn, err := net.Dial(\"unix\", c.socketPath)\n    if err != nil {\n        return nil, fmt.Errorf(\"connecting to orchestrator: %w\", err)\n    }\n    defer conn.Close()\n\n    // Marshal and send\n    data, err := json.Marshal(msg)\n    if err != nil {\n        return nil, fmt.Errorf(\"marshaling message: %w\", err)\n    }\n\n    if c.logger != nil {\n        c.logger.Debug(\"ipc send\", \"message\", string(data))\n    }\n\n    if _, err := conn.Write(append(data, '\\n')); err != nil {\n        return nil, fmt.Errorf(\"sending message: %w\", err)\n    }\n\n    // Read response\n    reader := bufio.NewReader(conn)\n    respData, err := reader.ReadBytes('\\n')\n    if err != nil {\n        return nil, fmt.Errorf(\"reading response: %w\", err)\n    }\n\n    if c.logger != nil {\n        c.logger.Debug(\"ipc recv\", \"message\", string(respData))\n    }\n\n    var resp map[string]any\n    if err := json.Unmarshal(respData, \u0026resp); err != nil {\n        return nil, fmt.Errorf(\"parsing response: %w\", err)\n    }\n\n    return resp, nil\n}\n```\n\n## Acceptance Criteria\n\n1. [ ] Connects to Unix socket\n2. [ ] StepDone sends correct message format\n3. [ ] GetPrompt returns prompt or empty string\n4. [ ] Event sends fire-and-forget\n5. [ ] Errors are properly propagated\n6. [ ] All IPC calls logged\n\n## Dependencies\n\n- meow-o3n: CLI entry point (need logger setup)\n\n## Reference\n\n- internal/ipc/messages.go - Message type definitions\n- internal/ipc/client.go - Existing IPC client (for reference)\n\n## Estimated Size\n\nMedium (~150 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:00:53.6969705-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:00:53.6969705-05:00","dependencies":[{"issue_id":"meow-vvr9","depends_on_id":"meow-o3n","type":"blocks","created_at":"2026-01-09T20:01:00.809330122-05:00","created_by":"ubuntu"}]}
{"id":"meow-vvt","title":"Parser: Multi-Workflow Module Support","description":"Extend template parser for multi-workflow module files. Phase 1 foundation.","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:25.560890598-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:17.071698724-05:00","closed_at":"2026-01-08T22:14:17.071698724-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot (pivot-000). The three-tier bead model is replaced by workflow-centric architecture."}
{"id":"meow-vzo","title":"Create reusable context monitor template","description":"Create a reusable template library for monitoring Claude agent context usage and triggering /compact when it gets high.\n\n## Background\n\nWith fire_forget mode implemented (meow-7e1), we can now create template patterns that inject commands without waiting for completion. A common use case is monitoring context and compacting before hitting limits.\n\n## Implementation\n\n### 1. Create template file\n\nCreate `lib/claude-utils.meow.toml` with reusable internal templates:\n\n```toml\n# lib/claude-utils.meow.toml\n# Reusable utilities for Claude Code agents\n\n[context-monitor]\ndescription = \"Monitor agent context and trigger /compact when above threshold\"\ninternal = true\n\n[context-monitor.variables]\nagent = { required = true, description = \"Agent ID to monitor\" }\nthreshold = { default = \"85\", description = \"Context % to trigger compact\" }\ncheck_interval = { default = \"30\", description = \"Seconds between checks\" }\naggressive = { default = \"false\", description = \"Send Escape before compact\" }\n\n# ... loop implementation from spec ...\n```\n\n### 2. Templates to include\n\nBased on the Context Monitor Pattern in MVP-SPEC-v2.md:\n\n- `context-monitor` - Entry point, starts the monitoring loop\n- `context-monitor-loop` - Main loop: sleep → check session → check context → recurse\n- `check-and-maybe-compact` - Get context %, compare to threshold, branch\n- `compact-and-continue` - Inject /compact (with optional Escape), continue loop\n- `aggressive-compact` - Escape → delay → /compact variant\n\n### 3. Context detection script\n\nThe template uses screen-scraping to get context percentage:\n```bash\nSESSION=\"meow-${MEOW_WORKFLOW}-{{agent}}\"\nPERCENT=$(tmux capture-pane -p -t \"$SESSION\" -S -100 2\u003e/dev/null | \\\n    grep -oE '[0-9]+k/[0-9]+k \\([0-9]+%\\)' | tail -1 | \\\n    grep -oE '\\([0-9]+%\\)' | tr -d '()%')\necho \"${PERCENT:-0}\"\n```\n\n### 4. Usage example\n\nWorkflows can import and use:\n```toml\n[[main.steps]]\nid = \"start-monitor\"\nexecutor = \"expand\"\ntemplate = \"lib/claude-utils#context-monitor\"\nvariables = { agent = \"worker\", threshold = \"85\" }\nneeds = [\"spawn-worker\"]\n```\n\n## Files to create\n\n- `lib/claude-utils.meow.toml` - The template library\n\n## Acceptance Criteria\n\n- [ ] Template file created at lib/claude-utils.meow.toml\n- [ ] context-monitor template works with fire_forget mode\n- [ ] Loop terminates gracefully when agent session is killed\n- [ ] Threshold and interval are configurable\n- [ ] Aggressive mode (Escape first) is supported\n- [ ] Template can be referenced from other workflows\n\n## Dependencies\n\n- Requires meow-7e1 (fire_forget mode) to be implemented first\n\n## References\n\n- Context Monitor Pattern in docs/MVP-SPEC-v2.md\n- fire_forget mode documentation in spec","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-09T15:33:59.367452208-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:39:54.046992775-05:00","closed_at":"2026-01-09T15:39:54.046992775-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-vzo","depends_on_id":"meow-7e1","type":"blocks","created_at":"2026-01-09T15:34:04.744561629-05:00","created_by":"ubuntu"}]}
{"id":"meow-we4","title":"CLI: Wisp-Aware Commands","description":"Implement CLI commands that understand three-tier model. Phase 4.","status":"closed","priority":0,"issue_type":"epic","created_at":"2026-01-07T16:38:26.03538728-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:17.079127582-05:00","closed_at":"2026-01-08T22:14:17.079127582-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot (pivot-000). The three-tier bead model is replaced by workflow-centric architecture."}
{"id":"meow-wgjr","title":"Implement stop hook emulation","description":"# Task: Implement Stop Hook Emulation\n\n## Parent Feature\nmeow-ur9: Hook Emulation System\n\n## Objective\n\nImplement the stop hook behavior that fires when the simulator transitions to IDLE state.\n\n## Background\n\nWhen Claude Code reaches the prompt (waiting for input), it triggers a \"Stop\" hook. This hook:\n1. Calls `meow event agent-stopped` (fire-and-forget)\n2. Calls `meow prime --format prompt` to get the next prompt\n3. If a prompt is returned (autonomous mode), Claude continues with that prompt\n4. If empty (interactive mode or no work), Claude waits for user input\n\nThis creates the \"Ralph Wiggum loop\" - agents that stop unexpectedly get nudged to continue.\n\n## Implementation\n\n### File: cmd/meow-agent-sim/hooks.go\n\n```go\npackage main\n\nfunc (s *Simulator) fireStopHook() {\n    if !s.config.Hooks.FireStopHook {\n        return\n    }\n\n    s.logger.Debug(\"firing stop hook\")\n\n    // 1. Emit agent-stopped event (fire and forget)\n    if err := s.ipc.Event(\"agent-stopped\", nil); err != nil {\n        s.logger.Debug(\"agent-stopped event failed\", \"error\", err)\n        // Continue anyway - event delivery is best-effort\n    }\n\n    // 2. Get prompt from orchestrator\n    prompt, err := s.ipc.GetPrompt()\n    if err != nil {\n        s.logger.Debug(\"get_prompt failed\", \"error\", err)\n        return\n    }\n\n    // 3. If prompt returned and not in ASKING state, self-inject\n    if prompt != \"\" \u0026\u0026 s.state != StateAsking {\n        s.logger.Debug(\"self-injecting prompt\", \"promptLen\", len(prompt))\n        s.selfInject(prompt)\n    } else {\n        s.logger.Debug(\"no prompt to inject\",\n            \"promptEmpty\", prompt == \"\",\n            \"state\", s.state,\n        )\n    }\n}\n\nfunc (s *Simulator) selfInject(prompt string) {\n    // Transition to WORKING and process the prompt\n    s.transitionTo(StateWorking)\n\n    behavior := s.matchBehavior(prompt)\n    if err := s.executeBehavior(behavior, prompt); err != nil {\n        s.logger.Error(\"self-injection failed\", \"error\", err)\n        s.transitionTo(StateIdle) // Back to idle, will fire stop hook again\n    }\n}\n```\n\n## Stop Hook Timing\n\nThe stop hook fires AFTER showing the prompt but BEFORE reading input:\n\n```go\nfunc (s *Simulator) Run() error {\n    // ...\n    for {\n        if s.state == StateIdle || s.state == StateAsking {\n            s.showPrompt()\n\n            // Fire stop hook after showing prompt\n            if s.config.Hooks.FireStopHook {\n                s.fireStopHook()\n                // If self-injection happened, we're now in WORKING\n                // Skip the read, loop will come back\n                if s.state == StateWorking {\n                    continue\n                }\n            }\n        }\n\n        // Read input (only reached if no self-injection)\n        line, err := reader.ReadString('\\n')\n        // ...\n    }\n}\n```\n\n## Interactive Mode Handling\n\nWhen step mode is \"interactive\", orchestrator returns empty prompt:\n\n```go\n// In orchestrator's HandleGetPrompt:\nif step.Mode == \"interactive\" {\n    return PromptMessage{Content: \"\"} // Empty - let human interact\n}\n```\n\nSimulator receives empty, stays at prompt, waits for actual user input.\n\n## Acceptance Criteria\n\n1. [ ] Stop hook fires on IDLE transition\n2. [ ] agent-stopped event emitted\n3. [ ] meow prime called via IPC\n4. [ ] Prompt self-injected if returned\n5. [ ] Empty prompt = stay at prompt\n6. [ ] ASKING state prevents self-injection\n7. [ ] All hook calls logged\n\n## Dependencies\n\n- meow-086: State machine (need state transitions)\n- meow-ipc: IPC client (need GetPrompt, Event)\n\n## Estimated Size\n\nMedium (~100 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:01:00.923465867-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:01:00.923465867-05:00","dependencies":[{"issue_id":"meow-wgjr","depends_on_id":"meow-086","type":"blocks","created_at":"2026-01-09T20:01:06.604273666-05:00","created_by":"ubuntu"},{"issue_id":"meow-wgjr","depends_on_id":"meow-vvr9","type":"blocks","created_at":"2026-01-09T20:01:06.710395913-05:00","created_by":"ubuntu"}]}
{"id":"meow-wtb","title":"Implement meow validate command","description":"## Current State\n\nThe `meow validate` command is a stub that prints \"not yet implemented\":\n\n```go\n// cmd/meow/cmd/validate.go:36-37\nfmt.Printf(\"Validating template: %s\\n\", template)\nfmt.Println(\"(not yet implemented)\")\n```\n\n## Required Functionality\n\nThe command should validate templates without executing them:\n\n```bash\nmeow validate template.toml\n# Output:\n# ✓ TOML syntax valid\n# ✓ Required fields present  \n# ✓ Variable references valid\n# ✓ No dependency cycles\n# ✓ Output references valid\n# Template is valid!\n```\n\n## Implementation\n\nThe validation logic already exists in `internal/template/validate.go`:\n- `ValidateFull()` - comprehensive validation\n- `ValidateSteps()` - step validation\n- `ValidateOutput()` - output validation\n\nJust need to wire it up to the CLI command.\n\n## File\n`cmd/meow/cmd/validate.go`\n\n## Acceptance Criteria\n- [ ] Loads template (module or legacy format)\n- [ ] Runs full validation\n- [ ] Reports all errors found (not just first)\n- [ ] Returns non-zero exit code on failure","status":"closed","priority":2,"issue_type":"task","assignee":"agent1","created_at":"2026-01-08T03:04:06.215882961-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:28:44.807161953-05:00","closed_at":"2026-01-08T03:28:44.807161953-05:00","close_reason":"Closed","labels":["cli"]}
{"id":"meow-wwq","title":"Create Ralph Wiggum monitoring template pattern","description":"## Background\n\nThe \"Ralph Wiggum loop\" is a pattern where a monitoring step watches for agent-stopped events and nudges the agent back to work using fire_forget injection. This keeps agents persistent without hardcoding behavior in the orchestrator.\n\n**Note:** This is DIFFERENT from the context-monitor pattern (lib/claude-utils.meow.toml):\n- **context-monitor**: Timer-based polling (every N seconds)\n- **ralph-wiggum**: Event-based reaction (when agent stops unexpectedly)\n\n## Design Principle\n\nInstead of hardcoding \"when Stop hook fires, re-inject prompt\" in the orchestrator, the design pushes this to user-space:\n\n1. **Adapter**: Claude adapter's setup.sh configures hooks that call event-translator.sh\n2. **Event translator**: Converts Claude's Stop hook to `meow event agent-stopped`\n3. **Template**: Monitoring loop listens for agent-stopped and uses fire_forget to nudge\n\nThis keeps the core agent-agnostic and makes behavior customizable.\n\n## Template Pattern\n\n```toml\n# ralph-wiggum.meow.toml\n\n[monitor]\nname = \"ralph-wiggum-monitor\"\ninternal = true\n\n[monitor.variables]\nagent = { required = true }\nmain_step = { required = true }\n\n[[monitor.steps]]\nid = \"wait-for-stop\"\nexecutor = \"branch\"\ncondition = \"meow await-event agent-stopped --filter agent={{agent}} --timeout 30s\"\n\n[monitor.steps.on_true]\n# Agent stopped unexpectedly - nudge it!\ntemplate = \".nudge-and-loop\"\nvariables = { agent = \"{{agent}}\", main_step = \"{{main_step}}\" }\n\n[monitor.steps.on_false]\n# Timeout - check if main task done\ntemplate = \".check-and-loop\"\nvariables = { agent = \"{{agent}}\", main_step = \"{{main_step}}\" }\n\n[nudge-and-loop]\ninternal = true\n# ... nudge with fire_forget, then recurse\n\n[check-and-loop]\ninternal = true\n# ... check step-status, recurse if still running\n```\n\n## Usage\n\n```toml\n[[main.steps]]\nid = \"start-monitoring\"\nexecutor = \"expand\"\ntemplate = \"ralph-wiggum#monitor\"\nvariables = { agent = \"worker\", main_step = \"do-work\" }\nneeds = [\"spawn\"]\n```\n\n## Prerequisites (Already Done)\n\n- [x] fire_forget mode (meow-7e1) - Implemented\n- [ ] Events system (meow-xds) - Needed for await-event\n\n## Success Criteria\n\n- [ ] Template created in lib/ralph-wiggum.meow.toml\n- [ ] Documentation explaining the pattern vs context-monitor\n- [ ] Example workflow using the pattern\n- [ ] Works with Claude adapter event translator\n- [ ] Degrades gracefully (timeout path) for agents without events","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T15:45:45.964899594-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:51:05.469417039-05:00","dependencies":[{"issue_id":"meow-wwq","depends_on_id":"meow-xds","type":"blocks","created_at":"2026-01-09T15:45:51.333715021-05:00","created_by":"ubuntu"}]}
{"id":"meow-x4s","title":"EPIC: foreach Executor","description":"Implement the foreach executor for dynamic iteration over lists with parallel execution and implicit join semantics. See MVP-SPEC-v2.md 'foreach' section.\n\nKey capabilities:\n- Iterate over JSON arrays from step outputs or variables\n- Expand templates for each item with item_var and index_var\n- Parallel execution with max_concurrent limiting\n- Sequential execution option (parallel: false)\n- Implicit join semantics (join: true default)\n- Fire-and-forget mode (join: false)\n- Child step ID prefixing (foreach-id.index.step-id)","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-09T15:03:15.277934184-05:00","created_by":"ubuntu","updated_at":"2026-01-09T15:03:15.277934184-05:00","dependencies":[{"issue_id":"meow-x4s","depends_on_id":"meow-5ex","type":"blocks","created_at":"2026-01-09T15:04:02.508140796-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-qvy","type":"blocks","created_at":"2026-01-09T15:04:02.620403821-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-1mc","type":"blocks","created_at":"2026-01-09T15:04:02.736401716-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-mfr","type":"blocks","created_at":"2026-01-09T15:04:02.854589036-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-ako","type":"blocks","created_at":"2026-01-09T15:04:02.970431876-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-je8","type":"blocks","created_at":"2026-01-09T15:04:03.086411302-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-fus","type":"blocks","created_at":"2026-01-09T15:04:03.19763697-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-p8v","type":"blocks","created_at":"2026-01-09T15:04:03.310538986-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-3xa","type":"blocks","created_at":"2026-01-09T15:04:03.424755762-05:00","created_by":"ubuntu"},{"issue_id":"meow-x4s","depends_on_id":"meow-a02","type":"blocks","created_at":"2026-01-09T15:04:03.539966338-05:00","created_by":"ubuntu"}]}
{"id":"meow-x9z","title":"Add BeadTypeGate for human approval points","description":"Add new `gate` bead type per SPEC-ADDENDUM-WISPS-AND-MODULES.md (lines 214-231).\n\n## The Gate Type\n\n`gate` replaces the `orchestrator_task` boolean flag for human approval points:\n\n```go\nconst (\n    // Agent-executable\n    BeadTypeTask          BeadType = \"task\"          // Agent does work, auto-continues\n    BeadTypeCollaborative BeadType = \"collaborative\" // Agent + human conversation, pauses\n    BeadTypeGate          BeadType = \"gate\"          // Human approval point (no assignee)\n    \n    // Orchestrator-executable\n    BeadTypeStart     BeadType = \"start\"\n    BeadTypeStop      BeadType = \"stop\"\n    BeadTypeCondition BeadType = \"condition\"\n    BeadTypeCode      BeadType = \"code\"\n    BeadTypeExpand    BeadType = \"expand\"\n)\n```\n\n## Type Behavior Summary\n\n| Type | Assignee | Auto-continue | Who closes | Use case |\n|------|----------|---------------|------------|----------|\n| `task` | Required | Yes (Ralph Wiggum) | Agent | Normal autonomous work |\n| `collaborative` | Required | No (pauses) | Agent | Design review, clarification |\n| `gate` | None | No | Human | Approval checkpoints |\n\n## Gate Characteristics\n\n- **No assignee** - Human-facing, not agent-facing\n- **Tier: orchestrator** - Infrastructure machinery\n- **Orchestrator waits** - Like condition but requires human action\n- **No agent visibility** - Never shown in `meow prime`\n\n## Usage in Templates\n\n```toml\n[[workflow.steps]]\nid = \"human-review\"\ntype = \"gate\"\ntitle = \"Review implementation before merge\"\ninstructions = \"Check code quality, test coverage, and documentation\"\n# No assignee field - gates are human-facing\n```\n\n## File Location\nModify: `internal/types/bead.go`\n\n## Acceptance Criteria\n- [ ] BeadTypeGate constant added\n- [ ] Valid() updated to include gate\n- [ ] Gate validation: must NOT have assignee\n- [ ] Unit tests for gate type\n- [ ] Documentation updated","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T17:52:42.000899283-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Consolidated into meow-bba. The gate type is now part of the unified Bead struct changes task.","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-xcab","title":"Write template pattern E2E tests","description":"Implement E2E tests for complex template patterns. Test cases: nested expand, branch conditions, foreach iteration, recursive templates with termination.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T20:04:17.861689627-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:04:17.861689627-05:00","dependencies":[{"issue_id":"meow-xcab","depends_on_id":"meow-j6rw","type":"blocks","created_at":"2026-01-09T20:04:23.00871144-05:00","created_by":"ubuntu"}]}
{"id":"meow-xds","title":"Events System","description":"## Background\n\nMEOW needs an event system that allows agents to signal the orchestrator without completing a step. This enables monitoring, reactive workflows, and inter-agent coordination.\n\nEvents are distinct from step completion (meow done) - they're fire-and-forget notifications that workflows can optionally react to via await-event steps.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 7: Events\n\nKey components:\n- Event IPC message types (EventMessage, AwaitEventMessage)\n- Event routing in orchestrator (match events to waiters)\n- CLI: meow event \u003ctype\u003e [--data k=v]\n- CLI: meow await-event \u003ctype\u003e [--filter k=v] [--timeout duration]\n- Integration with adapter event translators\n- Optional: meow step-status command for monitoring\n\n## Success Criteria\n\n- [ ] Event IPC message types defined\n- [ ] Event routing in orchestrator\n- [ ] meow event CLI command\n- [ ] meow await-event CLI command\n- [ ] Integration with adapter event translators\n- [ ] meow step-status command (optional utility)\n\n## Dependencies\n\nThis epic partially depends on Agent Adapters (for event translator integration), but the core event system can be built independently.","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-09T02:45:54.326113631-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:45:54.326113631-05:00"}
{"id":"meow-xds.1","title":"Define Event IPC Message Types","description":"## Background\n\nThe event system needs IPC message types for agents to emit events and for workflows to wait on events. These are new message types in the existing IPC system.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 7: Events\n\nEvents are fire-and-forget notifications:\n```json\n{\"type\": \"event\", \"event_type\": \"agent-stopped\", \"data\": {\"agent\": \"worker-1\"}}\n```\n\nEvent waiting is blocking until match or timeout:\n```json\n{\"type\": \"await_event\", \"event_type\": \"tool-completed\", \"filter\": {\"tool\": \"Bash\"}, \"timeout\": \"5m\"}\n```\n\nResponse:\n```json\n{\"type\": \"event_match\", \"event_type\": \"tool-completed\", \"data\": {\"tool\": \"Bash\", \"exit_code\": 0}}\n```\nOr on timeout:\n```json\n{\"type\": \"error\", \"message\": \"timeout waiting for event\"}\n```\n\n## Implementation Details\n\nKey files to modify:\n- internal/ipc/messages.go - Add new message types\n\nNew message types:\n```go\nconst (\n    MsgEvent      = \"event\"\n    MsgAwaitEvent = \"await_event\"\n    MsgEventMatch = \"event_match\"\n)\n\ntype EventMessage struct {\n    Type      string         `json:\"type\"`       // \"event\"\n    EventType string         `json:\"event_type\"` // e.g., \"agent-stopped\"\n    Data      map[string]any `json:\"data\"`       // Event-specific data\n    Agent     string         `json:\"agent\"`      // Which agent emitted (set by orchestrator)\n    Workflow  string         `json:\"workflow\"`   // Which workflow (set by orchestrator)\n    Timestamp time.Time      `json:\"timestamp\"`  // When emitted\n}\n\ntype AwaitEventMessage struct {\n    Type      string            `json:\"type\"`       // \"await_event\"\n    EventType string            `json:\"event_type\"` // Event type to wait for\n    Filter    map[string]string `json:\"filter\"`     // Key-value filters (all must match)\n    Timeout   string            `json:\"timeout\"`    // Duration string, e.g., \"5m\"\n}\n\ntype EventMatchMessage struct {\n    Type      string         `json:\"type\"`       // \"event_match\"\n    EventType string         `json:\"event_type\"`\n    Data      map[string]any `json:\"data\"`\n    Timestamp time.Time      `json:\"timestamp\"`\n}\n```\n\n## Acceptance Criteria\n\n- [ ] EventMessage type defined with all fields\n- [ ] AwaitEventMessage type defined with filter and timeout\n- [ ] EventMatchMessage type for successful matches\n- [ ] Message type constants added\n- [ ] JSON marshaling/unmarshaling works correctly\n- [ ] Unit tests for message serialization\n\n## Considerations\n\n- Filter matching: should support glob patterns or just exact match?\n- Data field is any - allows flexibility but harder to validate\n- Timestamp should be set by orchestrator, not client\n- Consider adding workflow and step context to events automatically","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:49:07.903194254-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:04:50.135251362-05:00","closed_at":"2026-01-09T17:04:50.135251362-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-xds.1","depends_on_id":"meow-xds","type":"parent-child","created_at":"2026-01-09T02:49:07.904431452-05:00","created_by":"ubuntu"}]}
{"id":"meow-xds.2","title":"Implement Event Routing in Orchestrator","description":"## Background\n\nThe orchestrator needs to route events from agents to waiters. This is a pub/sub system where events are matched against registered waiters based on event type and filters.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 7: Events\n\nEvent flow:\n1. Agent emits event via meow event command\n2. Orchestrator receives event via IPC\n3. Orchestrator checks for matching waiters\n4. If waiter matches, send event to waiter and complete the wait\n5. Events without waiters are logged but not queued\n\nMatching rules:\n- event_type must match exactly\n- All filter key-value pairs must match event data\n- First-match wins (no broadcast to multiple waiters)\n\n## Implementation Details\n\nKey files to modify:\n- internal/orchestrator/event_router.go (new)\n- internal/orchestrator/ipc_handler.go - Add event handlers\n\nEvent router:\n```go\ntype EventRouter struct {\n    mu      sync.Mutex\n    waiters map[string][]*eventWaiter  // event_type -\u003e waiters\n    logger  *slog.Logger\n}\n\ntype eventWaiter struct {\n    eventType string\n    filter    map[string]string\n    response  chan *types.EventMessage\n    deadline  time.Time\n}\n\nfunc (r *EventRouter) RegisterWaiter(eventType string, filter map[string]string, timeout time.Duration) \u003c-chan *types.EventMessage\n\nfunc (r *EventRouter) Route(event *types.EventMessage) bool  // returns true if matched\n\nfunc (r *EventRouter) cleanup()  // Remove expired waiters\n```\n\nIPC handler additions:\n```go\nfunc (h *IPCHandler) HandleEvent(ctx context.Context, msg *ipc.EventMessage) any {\n    // Add metadata\n    msg.Timestamp = time.Now()\n    msg.Agent = getAgentFromContext(ctx)\n    msg.Workflow = getWorkflowFromContext(ctx)\n    \n    // Route to waiters\n    matched := h.router.Route(msg)\n    \n    // Log event\n    h.logger.Info(\"event received\", \"type\", msg.EventType, \"matched\", matched)\n    \n    return \u0026ipc.AckMessage{Type: ipc.MsgAck, Success: true}\n}\n\nfunc (h *IPCHandler) HandleAwaitEvent(ctx context.Context, msg *ipc.AwaitEventMessage) any {\n    timeout, _ := time.ParseDuration(msg.Timeout)\n    ch := h.router.RegisterWaiter(msg.EventType, msg.Filter, timeout)\n    \n    select {\n    case event := \u003c-ch:\n        return \u0026ipc.EventMatchMessage{...}\n    case \u003c-time.After(timeout):\n        return \u0026ipc.ErrorMessage{Message: \"timeout waiting for event\"}\n    case \u003c-ctx.Done():\n        return \u0026ipc.ErrorMessage{Message: \"cancelled\"}\n    }\n}\n```\n\n## Acceptance Criteria\n\n- [ ] EventRouter struct with waiter registration\n- [ ] Route() matches events to waiters by type and filter\n- [ ] First-match-wins semantics\n- [ ] Timeout handling for waiters\n- [ ] Cleanup of expired waiters\n- [ ] HandleEvent in IPC handler\n- [ ] HandleAwaitEvent in IPC handler\n- [ ] Events logged even without waiters\n- [ ] Unit tests for routing logic\n\n## Considerations\n\n- Memory: events without waiters are not queued (fire-and-forget)\n- Concurrency: router must be thread-safe\n- Filter matching: exact string match for MVP, consider glob later\n- Context deadline should short-circuit long timeouts\n- Consider max waiters per event type to prevent resource exhaustion","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:49:09.756048371-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:09:10.042254324-05:00","closed_at":"2026-01-09T17:09:10.042254324-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-xds.2","depends_on_id":"meow-xds","type":"parent-child","created_at":"2026-01-09T02:49:09.757091011-05:00","created_by":"ubuntu"},{"issue_id":"meow-xds.2","depends_on_id":"meow-xds.1","type":"blocks","created_at":"2026-01-09T02:50:19.43666218-05:00","created_by":"ubuntu"}]}
{"id":"meow-xds.3","title":"Implement meow event CLI Command","description":"## Background\n\nAgents need a CLI command to emit events. This command sends an event to the orchestrator via IPC and returns immediately (fire-and-forget).\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 14: CLI Commands\n\n```bash\n# Emit an event\nmeow event \u003ctype\u003e [--data key=value...]\n\n# Examples\nmeow event agent-stopped\nmeow event tool-completed --data tool=Bash --data exit_code=0\nmeow event custom-event --data payload=some json string\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- cmd/meow/cmd/event.go (new)\n\n```go\nfunc runEvent(cmd *cobra.Command, args []string) error {\n    eventType := args[0]\n    \n    // Parse --data flags into map\n    data := make(map[string]any)\n    for _, kv := range dataFlags {\n        parts := strings.SplitN(kv, \"=\", 2)\n        if len(parts) != 2 {\n            return fmt.Errorf(\"invalid data format: %s (expected key=value)\", kv)\n        }\n        key, value := parts[0], parts[1]\n        \n        // Try to parse as JSON first, fall back to string\n        var parsed any\n        if err := json.Unmarshal([]byte(value), \u0026parsed); err != nil {\n            parsed = value\n        }\n        data[key] = parsed\n    }\n    \n    // Get orchestrator socket from env\n    sockPath := os.Getenv(\"MEOW_ORCH_SOCK\")\n    if sockPath == \"\" {\n        return fmt.Errorf(\"MEOW_ORCH_SOCK not set (are you running in a MEOW workflow?)\")\n    }\n    \n    // Send event via IPC\n    client := ipc.NewClient(sockPath)\n    _, err := client.Send(\u0026ipc.EventMessage{\n        Type:      ipc.MsgEvent,\n        EventType: eventType,\n        Data:      data,\n    })\n    \n    return err\n}\n```\n\n## Acceptance Criteria\n\n- [ ] meow event \u003ctype\u003e sends event to orchestrator\n- [ ] --data key=value adds data to event\n- [ ] Multiple --data flags supported\n- [ ] JSON values in --data parsed correctly\n- [ ] String values preserved as strings\n- [ ] Error if MEOW_ORCH_SOCK not set\n- [ ] Returns immediately (no blocking)\n- [ ] Exit 0 on success, non-zero on error\n- [ ] Unit test for data parsing\n\n## Considerations\n\n- MEOW_ORCH_SOCK is set by orchestrator when spawning agents\n- If called outside a workflow, should give helpful error\n- Consider --timeout flag for how long to wait for ack (default: 5s)\n- Data parsing: integers become numbers, quoted strings become strings\n- Consider --quiet flag to suppress output","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:49:35.625609843-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:10:42.906861628-05:00","closed_at":"2026-01-09T17:10:42.906861628-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-xds.3","depends_on_id":"meow-xds","type":"parent-child","created_at":"2026-01-09T02:49:35.626741891-05:00","created_by":"ubuntu"},{"issue_id":"meow-xds.3","depends_on_id":"meow-xds.1","type":"blocks","created_at":"2026-01-09T02:50:20.366518242-05:00","created_by":"ubuntu"},{"issue_id":"meow-xds.3","depends_on_id":"meow-xds.2","type":"blocks","created_at":"2026-01-09T02:50:22.394936541-05:00","created_by":"ubuntu"}]}
{"id":"meow-xds.4","title":"Implement meow await-event CLI Command","description":"## Background\n\nShell scripts (including branch conditions) need a way to wait for events. This command blocks until a matching event arrives or timeout occurs.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 14: CLI Commands\n\n```bash\n# Wait for an event\nmeow await-event \u003ctype\u003e [--filter key=value...] [--timeout duration]\n\n# Examples\nmeow await-event tool-completed --filter tool=Bash --timeout 5m\nmeow await-event agent-stopped --timeout 1h\nmeow await-event deployment-ready --filter env=staging\n```\n\nExit codes:\n- 0: Event matched\n- 1: Timeout\n- 2: Error (socket not found, invalid args)\n\nOutput on success (JSON):\n```json\n{\"event_type\": \"tool-completed\", \"data\": {\"tool\": \"Bash\", \"exit_code\": 0}}\n```\n\n## Implementation Details\n\nKey files to create/modify:\n- cmd/meow/cmd/await_event.go (new)\n\n```go\nfunc runAwaitEvent(cmd *cobra.Command, args []string) error {\n    eventType := args[0]\n    \n    // Parse filters\n    filter := make(map[string]string)\n    for _, kv := range filterFlags {\n        parts := strings.SplitN(kv, \"=\", 2)\n        if len(parts) != 2 {\n            return fmt.Errorf(\"invalid filter format: %s\", kv)\n        }\n        filter[parts[0]] = parts[1]\n    }\n    \n    // Get socket\n    sockPath := os.Getenv(\"MEOW_ORCH_SOCK\")\n    if sockPath == \"\" {\n        return fmt.Errorf(\"MEOW_ORCH_SOCK not set\")\n    }\n    \n    // Send await request\n    client := ipc.NewClient(sockPath)\n    resp, err := client.Send(\u0026ipc.AwaitEventMessage{\n        Type:      ipc.MsgAwaitEvent,\n        EventType: eventType,\n        Filter:    filter,\n        Timeout:   timeout,\n    })\n    \n    if err != nil {\n        os.Exit(2)\n    }\n    \n    switch r := resp.(type) {\n    case *ipc.EventMatchMessage:\n        json.NewEncoder(os.Stdout).Encode(r)\n        return nil\n    case *ipc.ErrorMessage:\n        if strings.Contains(r.Message, \"timeout\") {\n            os.Exit(1)\n        }\n        return fmt.Errorf(\"%s\", r.Message)\n    }\n    \n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] meow await-event \u003ctype\u003e blocks until event matches\n- [ ] --filter key=value filters events\n- [ ] Multiple filters ANDed together\n- [ ] --timeout flag with duration (default: no timeout? or 24h?)\n- [ ] Exit 0 on match, 1 on timeout, 2 on error\n- [ ] Outputs matched event as JSON on success\n- [ ] Works in branch condition context\n- [ ] Unit test for filter parsing\n- [ ] Integration test for event matching\n\n## Considerations\n\n- Default timeout: probably should be required, or very long default (24h)\n- Connection to orchestrator must stay open while waiting\n- Signal handling: Ctrl+C should exit cleanly with code 2\n- JSON output enables scripts to parse event data\n- Consider --quiet flag to suppress output (just exit code matters)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:49:36.671275803-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:10:42.909379215-05:00","closed_at":"2026-01-09T17:10:42.909379215-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-xds.4","depends_on_id":"meow-xds","type":"parent-child","created_at":"2026-01-09T02:49:36.672539636-05:00","created_by":"ubuntu"},{"issue_id":"meow-xds.4","depends_on_id":"meow-xds.2","type":"blocks","created_at":"2026-01-09T02:50:23.388350461-05:00","created_by":"ubuntu"}]}
{"id":"meow-xds.5","title":"Implement meow step-status CLI Command","description":"## Background\n\nA utility command for monitoring workflows and scripting. Allows checking the status of steps from shell scripts, enabling conditional logic based on workflow state.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 14: CLI Commands\n\n```bash\n# Check step status\nmeow step-status \u003cstep-id\u003e\nmeow step-status \u003cstep-id\u003e --is done\nmeow step-status \u003cstep-id\u003e --is running\n\n# Example usage in scripts\nif meow step-status setup-step --is done; then\n  echo \"Setup complete\"\nfi\n```\n\nOutput (without --is):\n```\ndone\n```\n\nExit codes:\n- 0: Status matches (with --is) or status retrieved (without --is)\n- 1: Status does not match (with --is)\n- 2: Error (step not found, socket error)\n\n## Implementation Details\n\nKey files to create/modify:\n- cmd/meow/cmd/step_status.go (new)\n- internal/ipc/messages.go - Add GetStepStatus message type\n\nNew IPC message:\n```go\ntype GetStepStatusMessage struct {\n    Type     string `json:\"type\"`     // \"get_step_status\"\n    Workflow string `json:\"workflow\"`\n    StepID   string `json:\"step_id\"`\n}\n\ntype StepStatusMessage struct {\n    Type   string `json:\"type\"`   // \"step_status\"\n    StepID string `json:\"step_id\"`\n    Status string `json:\"status\"` // \"pending\", \"running\", \"done\", \"failed\"\n}\n```\n\nCLI implementation:\n```go\nfunc runStepStatus(cmd *cobra.Command, args []string) error {\n    stepID := args[0]\n    \n    sockPath := os.Getenv(\"MEOW_ORCH_SOCK\")\n    workflowID := os.Getenv(\"MEOW_WORKFLOW\")\n    \n    client := ipc.NewClient(sockPath)\n    resp, err := client.Send(\u0026ipc.GetStepStatusMessage{\n        Type:     ipc.MsgGetStepStatus,\n        Workflow: workflowID,\n        StepID:   stepID,\n    })\n    \n    if err != nil {\n        os.Exit(2)\n    }\n    \n    status := resp.(*ipc.StepStatusMessage).Status\n    \n    if isFlag != \"\" {\n        if status == isFlag {\n            os.Exit(0)\n        }\n        os.Exit(1)\n    }\n    \n    fmt.Println(status)\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] meow step-status \u003cstep-id\u003e prints status\n- [ ] --is flag checks if status matches\n- [ ] Exit 0 when status matches (with --is)\n- [ ] Exit 1 when status does not match (with --is)\n- [ ] Exit 2 on error\n- [ ] GetStepStatusMessage IPC type defined\n- [ ] Handler in orchestrator IPC\n- [ ] Works from within agent context (MEOW_WORKFLOW set)\n- [ ] Unit tests\n\n## Considerations\n\n- Could also support --wait flag to poll until status matches\n- Consider --json flag for machine-readable output\n- Step IDs with dots (from expansions) must be handled correctly\n- Could add --workflow flag to check other workflows (not just current)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-09T02:50:05.823372675-05:00","created_by":"ubuntu","updated_at":"2026-01-09T17:10:42.911657856-05:00","closed_at":"2026-01-09T17:10:42.911657856-05:00","close_reason":"Closed","dependencies":[{"issue_id":"meow-xds.5","depends_on_id":"meow-xds","type":"parent-child","created_at":"2026-01-09T02:50:05.824530315-05:00","created_by":"ubuntu"},{"issue_id":"meow-xds.5","depends_on_id":"meow-xds.2","type":"blocks","created_at":"2026-01-09T02:50:24.619110281-05:00","created_by":"ubuntu"}]}
{"id":"meow-xds.6","title":"Integrate Event Translator with Adapters","description":"## Background\n\nAdapters can optionally include an event-translator.sh script that converts agent-specific events to generic MEOW events. This task connects the event system to the adapter system.\n\n## Specification Reference\n\nMVP-SPEC-v2 Section 6: Event Translator Script\n\n```bash\n#!/bin/bash\n# ~/.meow/adapters/claude/event-translator.sh\nHOOK_TYPE=\"$1\"\nshift\n\ncase \"$HOOK_TYPE\" in\n  Stop)\n    meow event agent-stopped\n    ;;\n  PreToolUse)\n    meow event tool-starting --data tool=\"$1\"\n    ;;\n  PostToolUse)\n    meow event tool-completed --data tool=\"$1\"\n    ;;\nesac\n```\n\nAdapter config specifies how to configure agent for events:\n```toml\n[events]\ntranslator = \"./event-translator.sh\"\n\n[events.agent_config]\nStop = \"{{adapter_dir}}/event-translator.sh Stop\"\nPreToolUse = \"{{adapter_dir}}/event-translator.sh PreToolUse $TOOL_NAME\"\n```\n\n## Implementation Details\n\nKey files to modify:\n- internal/adapter/loader.go - Resolve event translator path\n- internal/orchestrator/agent_manager.go - Ensure MEOW_ORCH_SOCK available to scripts\n\nThe event translator is called by the agent (e.g., via Claude hooks), not by MEOW directly. MEOW needs to:\n\n1. When running adapter setup, ensure translator path is absolute\n2. Set MEOW_ORCH_SOCK in agent environment so translator can call meow event\n3. Document how adapters should configure their agents\n\nPath resolution in adapter:\n```go\nfunc (a *AdapterConfig) GetTranslatorPath(adapterDir string) string {\n    if a.Events.Translator == \"\" {\n        return \"\"\n    }\n    \n    translator := a.Events.Translator\n    if strings.HasPrefix(translator, \"./\") {\n        translator = filepath.Join(adapterDir, translator[2:])\n    }\n    \n    return translator\n}\n```\n\nTemplate expansion in agent_config:\n```go\nfunc (a *AdapterConfig) ExpandAgentConfig(adapterDir string) map[string]string {\n    result := make(map[string]string)\n    for k, v := range a.Events.AgentConfig {\n        result[k] = strings.ReplaceAll(v, \"{{adapter_dir}}\", adapterDir)\n    }\n    return result\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Event translator path resolved correctly (relative to adapter dir)\n- [ ] {{adapter_dir}} expanded in events.agent_config values\n- [ ] MEOW_ORCH_SOCK available to translator scripts\n- [ ] Documentation for creating event translators\n- [ ] Built-in claude adapter has working event translator\n- [ ] Integration test: translator emits event, orchestrator receives it\n\n## Considerations\n\n- The translator runs in the agent context, not orchestrator context\n- MEOW_ORCH_SOCK must be set for meow event to work\n- Translator scripts should be executable (handled by adapter install)\n- This depends on both the Adapter and Event systems being implemented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T02:50:06.908787014-05:00","created_by":"ubuntu","updated_at":"2026-01-09T02:50:06.908787014-05:00","dependencies":[{"issue_id":"meow-xds.6","depends_on_id":"meow-xds","type":"parent-child","created_at":"2026-01-09T02:50:06.909740678-05:00","created_by":"ubuntu"},{"issue_id":"meow-xds.6","depends_on_id":"meow-xds.3","type":"blocks","created_at":"2026-01-09T02:50:29.739636438-05:00","created_by":"ubuntu"},{"issue_id":"meow-xds.6","depends_on_id":"meow-354.4","type":"blocks","created_at":"2026-01-09T02:50:30.689755126-05:00","created_by":"ubuntu"}]}
{"id":"meow-xju","title":"Implement meow continue for crash recovery","description":"Resume interrupted workflow from persisted state. See IMPLEMENTATION-PLAN section meow-modules-cli-continue.","status":"tombstone","priority":1,"issue_type":"task","created_at":"2026-01-07T16:39:25.229851616-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Superseded by v2 pivot - will be recreated","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-xkz","title":"Implement variable substitution with shell escaping","description":"# Implement Variable Substitution with Shell Escaping\n\n## File: internal/template/substitute.go\n\n## Purpose\n\nReplace \\`{{variable}}\\` references in templates with actual values. Includes:\n- Missing variable detection (fail loudly)\n- Shell context escaping for command/condition fields\n\n## Implementation\n\n\\`\\`\\`go\npackage template\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strings\"\n)\n\nvar varPattern = regexp.MustCompile(\\`\\{\\{([^}]+)\\}\\}\\`)\n\n// SubstitutionContext provides values for variable replacement.\ntype SubstitutionContext struct {\n    Variables map[string]string   // From workflow vars + meow run --var\n    Outputs   map[string]any      // From completed step outputs\n    Builtins  map[string]string   // workflow_id, timestamp, date\n}\n\n// SubstituteError indicates a variable could not be resolved.\ntype SubstituteError struct {\n    Variable string\n    Context  string // Where it was referenced (step ID, field name)\n}\n\nfunc (e *SubstituteError) Error() string {\n    return fmt.Sprintf(\"undefined variable: %s (in %s)\", e.Variable, e.Context)\n}\n\n// Substitute replaces all {{var}} references in a string.\n// Returns error if any variable is undefined.\nfunc Substitute(template string, ctx *SubstitutionContext, context string) (string, error) {\n    var errs []error\n    \n    result := varPattern.ReplaceAllStringFunc(template, func(match string) string {\n        // Extract variable name from {{name}}\n        varName := strings.TrimSpace(match[2 : len(match)-2])\n        \n        value, err := ctx.Resolve(varName)\n        if err != nil {\n            errs = append(errs, \u0026SubstituteError{Variable: varName, Context: context})\n            return match // Leave unreplaced for error message\n        }\n        \n        return value\n    })\n    \n    if len(errs) \u003e 0 {\n        return \"\", errs[0] // Return first error\n    }\n    \n    return result, nil\n}\n\n// SubstituteShell replaces variables with shell-escaped values.\n// Use for command and condition fields to prevent injection.\nfunc SubstituteShell(template string, ctx *SubstitutionContext, context string) (string, error) {\n    var errs []error\n    \n    result := varPattern.ReplaceAllStringFunc(template, func(match string) string {\n        varName := strings.TrimSpace(match[2 : len(match)-2])\n        \n        value, err := ctx.Resolve(varName)\n        if err != nil {\n            errs = append(errs, \u0026SubstituteError{Variable: varName, Context: context})\n            return match\n        }\n        \n        // Shell-escape the value\n        return ShellEscape(value)\n    })\n    \n    if len(errs) \u003e 0 {\n        return \"\", errs[0]\n    }\n    \n    return result, nil\n}\n\n// ShellEscape quotes a string for safe shell use.\n// Uses single quotes and escapes embedded single quotes.\nfunc ShellEscape(s string) string {\n    // If empty, return empty quoted string\n    if s == \"\" {\n        return \"''\"\n    }\n    \n    // If no special characters, return as-is\n    if !needsEscaping(s) {\n        return s\n    }\n    \n    // Wrap in single quotes, escape embedded single quotes\n    // '\\'' = end quote, literal single quote, start quote\n    escaped := strings.ReplaceAll(s, \"'\", \"'\\\\''\")\n    return \"'\" + escaped + \"'\"\n}\n\nfunc needsEscaping(s string) bool {\n    for _, c := range s {\n        switch c {\n        case ' ', '\\t', '\\n', '\\\\', '\"', '\\'', '\\`', '$', '!', '\u0026', '|', ';', '(', ')', '\u003c', '\u003e', '*', '?', '[', ']', '{', '}', '#', '~', '=':\n            return true\n        }\n    }\n    return false\n}\n\n// Resolve looks up a variable value.\nfunc (ctx *SubstitutionContext) Resolve(name string) (string, error) {\n    // Check for output reference: step_id.outputs.field\n    if strings.Contains(name, \".outputs.\") {\n        return ctx.resolveOutput(name)\n    }\n    \n    // Check builtins\n    if v, ok := ctx.Builtins[name]; ok {\n        return v, nil\n    }\n    \n    // Check workflow variables\n    if v, ok := ctx.Variables[name]; ok {\n        return v, nil\n    }\n    \n    return \"\", fmt.Errorf(\"undefined: %s\", name)\n}\n\nfunc (ctx *SubstitutionContext) resolveOutput(name string) (string, error) {\n    // Parse step_id.outputs.field\n    parts := strings.SplitN(name, \".outputs.\", 2)\n    if len(parts) != 2 {\n        return \"\", fmt.Errorf(\"invalid output reference: %s\", name)\n    }\n    \n    stepID := parts[0]\n    field := parts[1]\n    \n    stepOutputs, ok := ctx.Outputs[stepID]\n    if !ok {\n        return \"\", fmt.Errorf(\"no outputs for step: %s\", stepID)\n    }\n    \n    outputMap, ok := stepOutputs.(map[string]any)\n    if !ok {\n        return \"\", fmt.Errorf(\"invalid outputs for step: %s\", stepID)\n    }\n    \n    value, ok := outputMap[field]\n    if !ok {\n        return \"\", fmt.Errorf(\"no output %s in step %s\", field, stepID)\n    }\n    \n    return fmt.Sprintf(\"%v\", value), nil\n}\n\\`\\`\\`\n\n## Usage in Template Processing\n\n\\`\\`\\`go\n// For prompts, template references, etc. (no escaping)\nprompt, err := Substitute(step.Agent.Prompt, ctx, step.ID+\".prompt\")\nif err != nil {\n    // Fail the step - missing variable\n    return err\n}\n\n// For shell commands and conditions (with escaping)\ncommand, err := SubstituteShell(step.Shell.Command, ctx, step.ID+\".command\")\nif err != nil {\n    return err\n}\n\ncondition, err := SubstituteShell(step.Branch.Condition, ctx, step.ID+\".condition\")\nif err != nil {\n    return err\n}\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Substitute() replaces all {{var}} references\n- [ ] SubstituteShell() escapes values for safe shell use\n- [ ] SubstituteError for undefined variables\n- [ ] ShellEscape() properly quotes values\n- [ ] Resolve() handles workflow vars, builtins, and outputs\n- [ ] Output reference parsing (step.outputs.field)\n- [ ] Unit tests for normal substitution\n- [ ] Unit tests for shell escaping edge cases\n- [ ] Unit tests for missing variable detection\n- [ ] Unit tests for output references","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T20:28:20.351021048-05:00","created_by":"ubuntu","updated_at":"2026-01-08T22:14:35.285749334-05:00","closed_at":"2026-01-08T22:14:35.285749334-05:00","close_reason":"Superseded by MVP-SPEC-v2 pivot. These features will be implemented as part of the new orchestrator architecture.","dependencies":[{"issue_id":"meow-xkz","depends_on_id":"pivot-104","type":"blocks","created_at":"2026-01-08T20:29:48.44675419-05:00","created_by":"ubuntu"},{"issue_id":"meow-xkz","depends_on_id":"meow-104","type":"blocks","created_at":"2026-01-08T20:29:48.44675419-05:00","created_by":"ubuntu"}]}
{"id":"meow-xxv7","title":"Write simulator unit tests","description":"# Task: Write Simulator Unit Tests\n\n## Parent Feature\nmeow-a0z: Core Simulator Binary\n\n## Objective\n\nWrite unit tests for the simulator itself, ensuring its components work correctly in isolation.\n\n## Test Files\n\n### cmd/meow-agent-sim/state_test.go\n\n```go\nfunc TestStateTransitions(t *testing.T) {\n    // STARTING → IDLE\n    // IDLE → WORKING\n    // WORKING → IDLE\n    // WORKING → ASKING\n    // ASKING → WORKING\n}\n\nfunc TestStateString(t *testing.T) {\n    // All states have string representation\n}\n```\n\n### cmd/meow-agent-sim/behavior_test.go\n\n```go\nfunc TestBehaviorMatching_Contains(t *testing.T) {\n    // Substring matching\n}\n\nfunc TestBehaviorMatching_Regex(t *testing.T) {\n    // Regex pattern matching\n}\n\nfunc TestBehaviorMatching_FirstMatchWins(t *testing.T) {\n    // Order matters\n}\n\nfunc TestBehaviorMatching_Default(t *testing.T) {\n    // Fallback to default\n}\n```\n\n### cmd/meow-agent-sim/config_test.go\n\n```go\nfunc TestLoadConfig(t *testing.T) {\n    // Valid YAML loads\n}\n\nfunc TestLoadConfig_Defaults(t *testing.T) {\n    // Missing fields get defaults\n}\n\nfunc TestLoadConfig_Duration(t *testing.T) {\n    // \"100ms\", \"1s\" parse correctly\n}\n```\n\n### cmd/meow-agent-sim/ipc_test.go\n\n```go\nfunc TestIPCClient_StepDone(t *testing.T) {\n    // Message format correct\n}\n\nfunc TestIPCClient_GetPrompt(t *testing.T) {\n    // Returns prompt or empty\n}\n\nfunc TestIPCClient_NoSocket(t *testing.T) {\n    // Error when socket not set\n}\n```\n\n## Acceptance Criteria\n\n1. [ ] State machine tests pass\n2. [ ] Behavior matching tests pass\n3. [ ] Config loading tests pass\n4. [ ] IPC client tests pass\n5. [ ] \u003e80% coverage on simulator code\n\n## Dependencies\n\n- All simulator implementation tasks\n\n## Estimated Size\n\nMedium (~400 lines of tests)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:04:53.020474051-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:04:53.020474051-05:00","dependencies":[{"issue_id":"meow-xxv7","depends_on_id":"meow-za1y","type":"blocks","created_at":"2026-01-09T20:04:59.134771153-05:00","created_by":"ubuntu"},{"issue_id":"meow-xxv7","depends_on_id":"meow-v0bp","type":"blocks","created_at":"2026-01-09T20:04:59.262118974-05:00","created_by":"ubuntu"},{"issue_id":"meow-xxv7","depends_on_id":"meow-vvr9","type":"blocks","created_at":"2026-01-09T20:04:59.387470393-05:00","created_by":"ubuntu"},{"issue_id":"meow-xxv7","depends_on_id":"meow-086","type":"blocks","created_at":"2026-01-09T20:04:59.499557067-05:00","created_by":"ubuntu"}]}
{"id":"meow-y9d","title":"meow run: orchestrator integration issues","description":"## Summary\n\nTesting `meow run` with a sample template revealed multiple issues in the orchestrator-agent integration. Some were fixed during this session, others remain.\n\n## Issues Fixed\n\n### 1. Orchestrator processed all beads, not just workflow beads\n**Location:** `internal/orchestrator/beadstore.go:106-131`\n**Problem:** `GetNextReady()` and `AllDone()` returned/checked ALL beads including issue tracker beads (which have no Type field).\n**Fix:** Added check `if bead.Type == \"\"` to skip non-workflow beads.\n\n### 2. TmuxManager.Start not idempotent\n**Location:** `internal/agent/tmux.go:125-157`\n**Problem:** If a tmux session already existed (from previous run), Start failed with \"session already exists\" and kept retrying forever.\n**Fix:** Added SessionExists check at start - if session exists, track the agent and return success.\n\n### 3. SendKeys not pressing Enter properly\n**Location:** `internal/agent/tmux_wrapper.go:162-184`\n**Problem:** `tmux send-keys` wasn't pressing Enter because text and Enter were sent as single command args, which tmux interprets differently.\n**Fix:** Split into two calls: first send text with `-l` flag (literal), then send Enter separately.\n\n### 4. MEOW_AGENT env var not set for spawned agents\n**Location:** `internal/template/baker.go:485-494`\n**Problem:** `meow prime` couldn't identify which agent was asking because MEOW_AGENT wasn't set.\n**Fix:** Added `Env: map[string]string{\"MEOW_AGENT\": bead.Assignee}` to StartSpec.\n\n### 5. Startup delay too short\n**Location:** `internal/agent/tmux.go:177-179`\n**Problem:** 500ms wasn't enough for Claude to fully initialize before receiving prompt.\n**Fix:** Increased to 5 seconds.\n\n## Issues Remaining\n\n### 1. Tier field not serialized to JSON (CRITICAL)\n**Location:** `internal/template/baker.go` and/or bead serialization\n**Problem:** Despite `determineTier()` returning `TierWisp` for ephemeral workflow tasks, the Tier field is missing from serialized beads in `.beads/issues.jsonl`.\n**Impact:** `meow prime` filters by `Tier: types.TierWisp` so it can't find the agent's tasks, returning \"No tasks assigned to this agent.\"\n**Debug info:** The `labels` field shows `[\"meow:ephemeral\"]` correctly, but `tier` field is absent.\n**Needs investigation:** Check if Tier is being set but not persisted, or if there's a serialization issue.\n\n### 2. meow prime can't find assigned tasks\n**Related to:** Tier field issue above\n**Symptom:** Agent runs `meow prime`, gets \"No tasks assigned to this agent\" even though `bd list --status=in_progress` shows the task correctly assigned.\n\n## Test Template Used\n\n`.meow/templates/hello-test.meow.toml` with `--var agent=\u003ctest-agent\u003e`\n\n## Files Modified\n\n- `internal/orchestrator/beadstore.go` - Bead filtering\n- `internal/agent/tmux.go` - Idempotent start, longer delay\n- `internal/agent/tmux_wrapper.go` - SendKeys fix\n- `internal/template/baker.go` - MEOW_AGENT env var\n\n## Verification\n\nAfter fixes, the orchestrator:\n- Correctly dispatches only workflow beads\n- Creates tmux sessions with Claude\n- Sends `meow prime` command which executes\n- Claude agent starts processing\n\nBut the agent can't find its assigned work due to the Tier serialization bug.","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T03:58:37.384236655-05:00","created_by":"ubuntu","updated_at":"2026-01-08T16:27:32.749527775-05:00","closed_at":"2026-01-08T16:27:32.749527775-05:00","close_reason":"Pivoted approach: Instead of fixing tier field serialization (band-aid), we're redesigning MEOW to own its bead storage completely. See meow-g5s for the new research task."}
{"id":"meow-ym3","title":"Implement wisp lifecycle management (burn/squash)","description":"Implement wisp cleanup per SPEC-ADDENDUM (lines 859-904).\n\n## When Wisps Get Burned\n\n- **On workflow completion** (all beads in workflow are closed)\n- **NOT on agent stop** (agent might resume)\n- **NOT on work bead close** (workflow machinery still needed)\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) cleanupWorkflow(ctx context.Context, workflowID string) error {\n    beads, _ := o.store.List(ctx, BeadFilter{\n        WorkflowID: workflowID,\n    })\n    \n    // Check if all beads are closed\n    allClosed := true\n    for _, bead := range beads {\n        if bead.Status != StatusClosed {\n            allClosed = false\n            break\n        }\n    }\n    \n    if allClosed {\n        // Delete non-work beads (wisps and orchestrator)\n        for _, bead := range beads {\n            if bead.Tier != TierWork {\n                _ = o.store.Delete(ctx, bead.ID)\n            }\n        }\n    }\n    \n    return nil\n}\n```\n\n## Cleanup Options\n\n```toml\n# .meow/config.toml\n[cleanup]\nephemeral = \"on_complete\"  # on_complete | manual | never\n```\n\n## Squash to Digest (Optional)\n\nBefore burning, optionally create a summary:\n```go\nfunc (o *Orchestrator) squashWisps(ctx context.Context, workflowID string, workBeadID string) error {\n    wisps, _ := o.store.List(ctx, BeadFilter{\n        WorkflowID: workflowID,\n        Tier:       TierWisp,\n    })\n    \n    // Generate digest\n    digest := generateDigest(wisps)\n    \n    // Append to work bead notes\n    workBead, _ := o.store.Get(ctx, workBeadID)\n    workBead.Notes += \"\\n\\n\" + digest\n    o.store.Update(ctx, workBead)\n    \n    // Then burn\n    return o.burnWisps(ctx, workflowID)\n}\n```\n\n## File Location\nModify: `internal/orchestrator/orchestrator.go`\n\n## Acceptance Criteria\n- [ ] cleanupWorkflow() deletes wisps and orchestrator beads\n- [ ] Only cleanup when all workflow beads closed\n- [ ] Work beads preserved\n- [ ] Optional squash to digest before burn\n- [ ] Cleanup triggered after workflow completion","status":"tombstone","priority":0,"issue_type":"task","created_at":"2026-01-07T16:39:24.725195883-05:00","created_by":"ubuntu","updated_at":"2026-01-09T19:54:59.321910259-05:00","close_reason":"Implemented tier-based wisp lifecycle management: cleanupWorkflow() burns wisps/orchestrator on workflow completion, squashWisps() creates digest before burning, updated Run() to use tier-based cleanup, comprehensive unit tests","deleted_at":"2026-01-09T19:54:59.321910259-05:00","deleted_by":"batch delete","delete_reason":"batch delete","original_type":"task"}
{"id":"meow-za1y","title":"Implement behavior matching engine","description":"# Task: Implement Behavior Matching Engine\n\n## Parent Feature\nmeow-a0z: Core Simulator Binary\n\n## Objective\n\nImplement the behavior matching system that maps incoming prompts to configured actions.\n\n## Matching Logic\n\n1. Iterate through behaviors in order\n2. For each behavior, check if pattern matches prompt\n3. First match wins\n4. If no match, use default behavior\n\n## Pattern Types\n\n- **contains** (default): Substring match\n- **regex**: Regular expression match\n\n## Implementation\n\n### File: cmd/meow-agent-sim/behavior.go\n\n```go\npackage main\n\nimport (\n    \"regexp\"\n    \"strings\"\n)\n\ntype ActionType string\n\nconst (\n    ActionComplete        ActionType = \"complete\"\n    ActionAsk             ActionType = \"ask\"\n    ActionFail            ActionType = \"fail\"\n    ActionFailThenSucceed ActionType = \"fail_then_succeed\"\n    ActionHang            ActionType = \"hang\"\n    ActionCrash           ActionType = \"crash\"\n)\n\ntype Behavior struct {\n    Match   string     `yaml:\"match\"`\n    Type    string     `yaml:\"type\"` // \"contains\" or \"regex\"\n    Action  Action     `yaml:\"action\"`\n    regex   *regexp.Regexp // Compiled regex, nil if contains\n}\n\ntype Action struct {\n    Type        ActionType        `yaml:\"type\"`\n    Delay       time.Duration     `yaml:\"delay\"`\n    Outputs     map[string]any    `yaml:\"outputs\"`\n    Events      []EventDef        `yaml:\"events\"`\n    Question    string            `yaml:\"question\"`\n    FailCount   int               `yaml:\"fail_count\"`\n    FailMessage string            `yaml:\"fail_message\"`\n    ExitCode    int               `yaml:\"exit_code\"`\n}\n\nfunc (s *Simulator) matchBehavior(prompt string) *Behavior {\n    for i := range s.config.Behaviors {\n        b := \u0026s.config.Behaviors[i]\n        if b.matches(prompt) {\n            s.logger.Debug(\"behavior matched\",\n                \"pattern\", b.Match,\n                \"prompt\", truncate(prompt, 50),\n            )\n            return b\n        }\n    }\n\n    s.logger.Debug(\"using default behavior\", \"prompt\", truncate(prompt, 50))\n    return \u0026s.config.Default.Behavior\n}\n\nfunc (b *Behavior) matches(prompt string) bool {\n    if b.Type == \"regex\" {\n        if b.regex == nil {\n            var err error\n            b.regex, err = regexp.Compile(b.Match)\n            if err != nil {\n                return false\n            }\n        }\n        return b.regex.MatchString(prompt)\n    }\n\n    // Default: contains\n    return strings.Contains(prompt, b.Match)\n}\n\nfunc (s *Simulator) executeBehavior(b *Behavior, prompt string) error {\n    s.logger.Debug(\"executing behavior\",\n        \"type\", b.Action.Type,\n        \"delay\", b.Action.Delay,\n    )\n\n    // Apply delay\n    if b.Action.Delay \u003e 0 {\n        time.Sleep(b.Action.Delay)\n    }\n\n    switch b.Action.Type {\n    case ActionComplete:\n        return s.actionComplete(b.Action)\n    case ActionAsk:\n        return s.actionAsk(b.Action)\n    case ActionFail:\n        return s.actionFail(b.Action)\n    case ActionFailThenSucceed:\n        return s.actionFailThenSucceed(b.Action)\n    case ActionHang:\n        return s.actionHang()\n    case ActionCrash:\n        return s.actionCrash(b.Action)\n    default:\n        return fmt.Errorf(\"unknown action type: %s\", b.Action.Type)\n    }\n}\n```\n\n## Action Implementations\n\n```go\nfunc (s *Simulator) actionComplete(a Action) error {\n    // Emit tool events if configured\n    s.emitToolEvents(a.Events)\n\n    // Call meow done\n    if err := s.ipc.StepDone(a.Outputs); err != nil {\n        s.logger.Error(\"meow done failed\", \"error\", err)\n        return err\n    }\n\n    s.transitionTo(StateIdle)\n    return nil\n}\n\nfunc (s *Simulator) actionAsk(a Action) error {\n    fmt.Println(a.Question)\n    s.transitionTo(StateAsking)\n    return nil\n}\n\nfunc (s *Simulator) actionFail(a Action) error {\n    fmt.Fprintln(os.Stderr, \"Error:\", a.FailMessage)\n    s.transitionTo(StateIdle) // Don't call meow done\n    return nil\n}\n\nfunc (s *Simulator) actionFailThenSucceed(a Action) error {\n    // Track attempts per pattern (needs state)\n    // First N attempts fail, then succeed\n    // Implementation in full task\n}\n\nfunc (s *Simulator) actionHang() error {\n    // Do nothing, stay in WORKING forever\n    select {} // Block forever\n}\n\nfunc (s *Simulator) actionCrash(a Action) error {\n    os.Exit(a.ExitCode)\n    return nil // unreachable\n}\n```\n\n## Acceptance Criteria\n\n1. [ ] Contains matching works\n2. [ ] Regex matching works\n3. [ ] First match wins\n4. [ ] Default fallback works\n5. [ ] All action types implemented\n6. [ ] Delay respected before action\n\n## Dependencies\n\n- meow-086: State machine (need state transitions)\n\n## Estimated Size\n\nMedium (~250 lines)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-09T20:00:47.067442973-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:00:47.067442973-05:00","dependencies":[{"issue_id":"meow-za1y","depends_on_id":"meow-086","type":"blocks","created_at":"2026-01-09T20:00:53.463907217-05:00","created_by":"ubuntu"}]}
{"id":"meow-zphg","title":"Add Makefile targets for E2E tests","description":"Add Makefile targets: build-e2e (build sim + meow), install-sim-adapter, test-e2e, test-e2e-stress, test-all. Ensure proper dependency ordering.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T20:04:30.739426069-05:00","created_by":"ubuntu","updated_at":"2026-01-09T20:04:30.739426069-05:00","dependencies":[{"issue_id":"meow-zphg","depends_on_id":"meow-mjh7","type":"blocks","created_at":"2026-01-09T20:04:36.748115738-05:00","created_by":"ubuntu"}]}
{"id":"meow-zva","title":"Bug: Code bead code field not substituted in baker","description":"## Problem\n\nIn `internal/template/baker.go`, the module-format code path in `workflowStepToBead()` manually substitutes title, instructions, and assignee, but then passes the ORIGINAL `step` (not substituted) to `setTypeSpec()`:\n\n```go\n// Line 252 in workflowStepToBead:\nif err := b.setTypeSpec(bead, step, stepToID); err != nil {  // ← original step!\n```\n\nMeanwhile, the legacy path at line 368 correctly uses the substituted step:\n```go\n// Line 368 in legacyStepToBead:\nif err := b.setTypeSpec(bead, subbed, stepToID); err != nil {  // ← substituted!\n```\n\n## Impact\n\nVariables like \\`{{test_name}}\\` appear literally in:\n- Code field of code beads\n- Condition field of condition beads\n\n## Expected Behavior\n\nThe module format path should either:\n1. Call `SubstituteStep()` before `setTypeSpec()` like the legacy path does\n2. Or substitute code/condition fields alongside title/instructions/assignee\n\n## Files\n- `internal/template/baker.go:252` - `workflowStepToBead()` passes original step\n- `internal/template/baker.go:368` - `legacyStepToBead()` correctly passes substituted step\n- `internal/template/vars.go:299` - `SubstituteStep()` handles Code and Condition correctly\n\n## Acceptance Criteria\n- [ ] Code field in code beads is substituted\n- [ ] Condition field in condition beads is substituted\n- [ ] Test with template containing \\`{{variable}}\\` in code field","status":"closed","priority":1,"issue_type":"bug","assignee":"agent2","created_at":"2026-01-08T03:03:17.455606938-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:27:32.926736694-05:00","closed_at":"2026-01-08T03:27:32.926736694-05:00","close_reason":"Closed","labels":["baker","bug","module-format"]}
{"id":"meow-zyc","title":"module.go: Task output specifications not parsed","description":"## Location\n`internal/template/module.go:200-261`\n\n## Problem\nThe `parseModuleStep()` function doesn't parse the outputs section for task beads. This means task output specifications can't be defined in module-format templates:\n\n```toml\n[[main.steps]]\nid = \"select-work\"\ntype = \"task\"\ntitle = \"Select next work bead\"\n\n# This section is NEVER parsed:\n[main.steps.outputs]\nrequired = [\n    { name = \"work_bead\", type = \"bead_id\", description = \"The bead to implement\" }\n]\n```\n\n## Impact\n- Cannot define validated outputs in module-format templates\n- Output validation (a key MVP feature per spec) unavailable for module format\n- Agent decisions can't be captured and validated\n\n## Spec Reference\nFrom MVP-SPEC.md:\n\u003e Tasks can require **validated outputs** that Claude must provide when closing. This enables reliable data flow from Claude's decisions to subsequent beads.\n\n## Fix\n1. Add outputs field to Step struct (if not present)\n2. Parse `data[\"outputs\"]` in parseModuleStep()\n3. Convert to TaskOutputSpec for bead creation\n\n## Severity\nMEDIUM - Missing feature for output validation in module format","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T02:23:06.870936755-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:35:17.787949507-05:00","closed_at":"2026-01-08T02:35:17.787949507-05:00","close_reason":"Fixed: Added Outputs field to Step struct and parsing for task output specifications in module.go"}
{"id":"pivot-000","title":"EPIC: MVP-SPEC-v2 Pivot - Workflow-Centric Architecture","description":"# The Big Pivot: Bead-Centric → Workflow-Centric\n\n## Background\n\nMEOW Stack started as a bead-aware orchestrator with three tiers (work/wisp/orchestrator). This created:\n- Tight coupling to beads task tracker\n- Conceptual confusion (are we a task tracker or workflow engine?)\n- Complex visibility model agents had to understand\n\n## The New Vision (MVP-SPEC-v2)\n\nMEOW is a **coordination language** for AI agents. Key shifts:\n\n1. **Task-tracking agnostic** - Users bring their own systems (beads, Jira, GitHub, sticky notes)\n2. **Single primitive** - Step with 7 executors (not 8 bead types)\n3. **No tiers** - Workflows are opaque to agents; they see prompts, not internals\n4. **Workflow state files** - YAML per-workflow, not JSONL bead store\n5. **meow done** - Signals step completion (not bead close)\n\n## Scope of This Pivot\n\n- Remove all bead integration code\n- Remove three-tier model (work/wisp/orchestrator)\n- Implement new Step/Workflow types\n- Switch persistence from JSONL to YAML\n- Update CLI commands\n- Update documentation\n\n## Key Documents\n\n- docs/MVP-SPEC-v2.md - The new specification\n- docs/IMPLEMENTATION-GUIDE.md - Detailed implementation guidance\n\n## Success Criteria\n\n- `meow run template.toml` starts a workflow stored in .meow/workflows/*.yaml\n- `meow prime` shows current step prompt to agents\n- `meow done` signals step completion with output validation\n- Workflows execute through all 7 executor types\n- No references to beads/tiers remain in core code","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:00Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00"}
{"id":"pivot-100","title":"EPIC: Type System Refactor","description":"# Type System Refactor\n\n## Why This Comes First\n\nThe type system is the foundation. Every other component depends on Step, Workflow, and ExecutorType definitions. Getting this right enables parallel work on other epics.\n\n## What Changes\n\n### Remove (from internal/types/bead.go)\n- BeadType enum (8 types)\n- BeadTier enum (work/wisp/orchestrator)\n- HookBead, SourceWorkflow fields\n- All type-specific specs (ConditionSpec, etc.)\n- Bead struct entirely (after migration)\n\n### Add (new files)\n- internal/types/executor.go - ExecutorType enum (7 values)\n- internal/types/step.go - Step struct with executor configs\n- internal/types/workflow.go - Workflow struct with state\n\n## The 7 Executors\n\n| Executor | Category | Purpose |\n|----------|----------|--------|\n| shell | Orchestrator | Run shell command, capture outputs |\n| spawn | Orchestrator | Start agent in tmux session |\n| kill | Orchestrator | Stop agent's tmux session |\n| expand | Orchestrator | Inline another workflow's steps |\n| branch | Orchestrator | Conditional execution (was 'condition') |\n| agent | External | Assign work to agent, wait for meow done |\n| gate | External | Human approval, wait for meow approve |\n\n## Key Design Decisions\n\n1. **Executor configs as embedded structs** - Each step has optional config for its executor type (ShellConfig, SpawnConfig, etc.). Only one is populated.\n\n2. **Status on Step, not separate** - Step.Status tracks lifecycle (pending/running/done/failed).\n\n3. **Outputs stored on Step** - When step completes, outputs captured directly on step.\n\n4. **No Tier field** - Visibility is implicit. Agents see their prompts, period.\n\n## Mapping from Old to New\n\n| Old BeadType | New Executor | Notes |\n|--------------|--------------|-------|\n| task | agent | mode: autonomous |\n| collaborative | agent | mode: interactive |\n| gate | gate | Same concept |\n| condition | branch | Renamed for clarity |\n| code | shell | Renamed for clarity |\n| start | spawn | Renamed for clarity |\n| stop | kill | Renamed for clarity |\n| expand | expand | Same |","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:01Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-100","depends_on_id":"pivot-000","type":"blocks","created_at":"2026-01-08T12:00:01Z","created_by":"claude"}]}
{"id":"pivot-101","title":"Define ExecutorType enum","description":"# Define ExecutorType Enum\n\n## File: internal/types/executor.go\n\n## Implementation\n\n```go\npackage types\n\n// ExecutorType determines who runs a step and how.\n// IMPORTANT: There are exactly 6 executors. Gate is NOT an executor -\n// human approval is implemented via branch + meow await-approval.\ntype ExecutorType string\n\nconst (\n    // Orchestrator executors - run internally, complete synchronously\n    ExecutorShell  ExecutorType = \"shell\"  // Run shell command\n    ExecutorSpawn  ExecutorType = \"spawn\"  // Start agent in tmux\n    ExecutorKill   ExecutorType = \"kill\"   // Stop agent's tmux session\n    ExecutorExpand ExecutorType = \"expand\" // Inline another workflow\n    ExecutorBranch ExecutorType = \"branch\" // Conditional execution\n\n    // External executors - wait for external completion signal\n    ExecutorAgent ExecutorType = \"agent\" // Agent does work, signals meow done\n)\n\n// IsOrchestrator returns true if this executor runs internally.\nfunc (e ExecutorType) IsOrchestrator() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch:\n        return true\n    }\n    return false\n}\n\n// IsExternal returns true if this executor waits for external signal.\nfunc (e ExecutorType) IsExternal() bool {\n    return e == ExecutorAgent\n}\n\n// Valid returns true if this is a recognized executor type.\nfunc (e ExecutorType) Valid() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch, ExecutorAgent:\n        return true\n    }\n    return false\n}\n```\n\n## Rationale\n\n- **6 executors only** - Gate is NOT a primitive (per MVP-SPEC-v2)\n- **shell** not \"code\" - More intuitive, matches spec language\n- **spawn/kill** not \"start/stop\" - Clearer about what's happening (process lifecycle)\n- **branch** not \"condition\" - Describes what it does (branching), not what it evaluates\n- **agent** not \"task\" - Describes who runs it, consistent with other executors\n\n## Human Approval Pattern (NOT an executor)\n\nHuman gates are implemented via composition:\n```toml\n[[steps]]\nid = \"review-gate\"\nexecutor = \"branch\"\ncondition = \"meow await-approval review-gate --timeout 24h\"\n```\n\n## Acceptance Criteria\n\n- [ ] ExecutorType enum with exactly 6 values (NO gate)\n- [ ] IsOrchestrator() helper (returns true for shell, spawn, kill, expand, branch)\n- [ ] IsExternal() helper (returns true only for agent)\n- [ ] Valid() validation\n- [ ] Unit tests for all methods\n","notes":"**UPDATED for v2 spec**: Only 6 executors - gate is NOT a primitive, it's a composition using branch + meow await-approval. Remove ExecutorGate from enum.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:02Z","created_by":"claude","updated_at":"2026-01-08T22:50:58.914657827-05:00","closed_at":"2026-01-08T22:50:58.914657827-05:00","close_reason":"Implemented ExecutorType enum with 6 executors (no gate), IsOrchestrator(), IsExternal(), Valid() methods, and comprehensive tests"}
{"id":"pivot-102","title":"Define StepStatus enum","description":"# Define StepStatus Enum\n\n## File: internal/types/step.go (or executor.go)\n\n## Implementation\n\n```go\n// StepStatus represents the lifecycle state of a step.\ntype StepStatus string\n\nconst (\n    StepStatusPending    StepStatus = \"pending\"    // Waiting for dependencies\n    StepStatusRunning    StepStatus = \"running\"    // Currently executing\n    StepStatusCompleting StepStatus = \"completing\" // Agent called meow done, orchestrator handling transition\n    StepStatusDone       StepStatus = \"done\"       // Completed successfully\n    StepStatusFailed     StepStatus = \"failed\"     // Execution failed\n)\n\n// Valid returns true if this is a recognized status.\nfunc (s StepStatus) Valid() bool {\n    switch s {\n    case StepStatusPending, StepStatusRunning, StepStatusCompleting, StepStatusDone, StepStatusFailed:\n        return true\n    }\n    return false\n}\n\n// IsTerminal returns true if this status is final (done or failed).\nfunc (s StepStatus) IsTerminal() bool {\n    return s == StepStatusDone || s == StepStatusFailed\n}\n\n// CanTransitionTo returns true if transitioning from s to target is valid.\nfunc (s StepStatus) CanTransitionTo(target StepStatus) bool {\n    switch s {\n    case StepStatusPending:\n        return target == StepStatusRunning\n    case StepStatusRunning:\n        return target == StepStatusCompleting || target == StepStatusDone || target == StepStatusFailed || target == StepStatusPending // Reset on crash\n    case StepStatusCompleting:\n        return target == StepStatusDone || target == StepStatusRunning // Back to running if validation fails\n    case StepStatusDone, StepStatusFailed:\n        return false // Terminal states\n    }\n    return false\n}\n```\n\n## Design Notes\n\n- **\\`completing\\` status added** - Critical for preventing stop hook interference during orchestrator transitions. When agent calls \\`meow done\\`, step goes to \\`completing\\` while orchestrator validates outputs and prepares next prompt.\n- **Reset allowed** - Running can go back to pending for crash recovery.\n- **Completing can retry** - If validation fails, step goes back to running so agent can retry.\n- **Terminal states** - Once done/failed, no further transitions.\n\n## Status Lifecycle\n\n\\`\\`\\`\npending ──► running ──► completing ──► done\n              │             │\n              │             └──► (back to running if validation fails)\n              │\n              └──► failed\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] StepStatus enum with 5 values (including completing)\n- [ ] Valid() validation\n- [ ] IsTerminal() helper\n- [ ] CanTransitionTo() state machine with completing transitions\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:03Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.964300077-05:00","closed_at":"2026-01-08T22:58:49.964300077-05:00","close_reason":"Implemented as part of persistence track commit e21ff43"}
{"id":"pivot-103","title":"Define executor config structs","description":"# Define Executor Config Structs\n\n## File: internal/types/step.go\n\n## Implementation\n\nEach executor has its own config struct. Only one is populated per step.\n**IMPORTANT: No GateConfig - gate is NOT an executor per MVP-SPEC-v2.**\n\n```go\n// ShellConfig for executor: shell\ntype ShellConfig struct {\n    Command string            `yaml:\"command\" toml:\"command\"`\n    Workdir string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env     map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    OnError string            `yaml:\"on_error,omitempty\" toml:\"on_error,omitempty\"` // continue | fail (default: fail)\n    Outputs map[string]OutputSource `yaml:\"outputs,omitempty\" toml:\"outputs,omitempty\"`\n}\n\n// OutputSource defines where to capture output from\ntype OutputSource struct {\n    Source string `yaml:\"source\" toml:\"source\"` // stdout | stderr | exit_code | file:/path\n}\n\n// SpawnConfig for executor: spawn\ntype SpawnConfig struct {\n    Agent         string            `yaml:\"agent\" toml:\"agent\"`\n    Workdir       string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env           map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    ResumeSession string            `yaml:\"resume_session,omitempty\" toml:\"resume_session,omitempty\"`\n}\n\n// KillConfig for executor: kill\ntype KillConfig struct {\n    Agent    string `yaml:\"agent\" toml:\"agent\"`\n    Graceful bool   `yaml:\"graceful,omitempty\" toml:\"graceful,omitempty\"` // Default: true\n    Timeout  int    `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"`   // Seconds, default: 10\n}\n\n// ExpandConfig for executor: expand\ntype ExpandConfig struct {\n    Template  string            `yaml:\"template\" toml:\"template\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n}\n\n// BranchTarget defines what to expand for a branch outcome.\ntype BranchTarget struct {\n    Template  string            `yaml:\"template,omitempty\" toml:\"template,omitempty\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n    Inline    []InlineStep      `yaml:\"inline,omitempty\" toml:\"inline,omitempty\"`\n}\n\n// BranchConfig for executor: branch\ntype BranchConfig struct {\n    Condition string        `yaml:\"condition\" toml:\"condition\"` // Shell command, exit 0 = true\n    OnTrue    *BranchTarget `yaml:\"on_true,omitempty\" toml:\"on_true,omitempty\"`\n    OnFalse   *BranchTarget `yaml:\"on_false,omitempty\" toml:\"on_false,omitempty\"`\n    OnTimeout *BranchTarget `yaml:\"on_timeout,omitempty\" toml:\"on_timeout,omitempty\"`\n    Timeout   string        `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"` // Duration string\n}\n\n// AgentOutputDef defines an expected output from an agent step\ntype AgentOutputDef struct {\n    Required    bool   `yaml:\"required\" toml:\"required\"`\n    Type        string `yaml:\"type\" toml:\"type\"` // string | number | boolean | json | file_path\n    Description string `yaml:\"description,omitempty\" toml:\"description,omitempty\"`\n}\n\n// AgentConfig for executor: agent\ntype AgentConfig struct {\n    Agent   string                    `yaml:\"agent\" toml:\"agent\"`\n    Prompt  string                    `yaml:\"prompt\" toml:\"prompt\"`\n    Mode    string                    `yaml:\"mode,omitempty\" toml:\"mode,omitempty\"` // autonomous (default) | interactive\n    Outputs map[string]AgentOutputDef `yaml:\"outputs,omitempty\" toml:\"outputs,omitempty\"`\n    Timeout string                    `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"` // Max time for step\n}\n```\n\n## Acceptance Criteria\n\n- [ ] ShellConfig with command, workdir, env, on_error, outputs\n- [ ] SpawnConfig with agent, workdir, env, resume_session\n- [ ] KillConfig with agent, graceful, timeout\n- [ ] ExpandConfig with template, variables\n- [ ] BranchConfig with condition, on_true, on_false, on_timeout, timeout\n- [ ] AgentConfig with agent, prompt, mode, outputs, timeout\n- [ ] BranchTarget for expansion targets\n- [ ] AgentOutputDef for output definitions\n- [ ] **NO GateConfig** - gate is not an executor\n- [ ] Unit tests for validation\n","notes":"**UPDATED for v2 spec**: Remove GateConfig - gates are implemented via branch + meow await-approval. Only 5 orchestrator executor configs (shell, spawn, kill, expand, branch) + 1 external (agent).","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:04Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.966377001-05:00","closed_at":"2026-01-08T22:58:49.966377001-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"pivot-103","depends_on_id":"pivot-101","type":"blocks","created_at":"2026-01-08T12:00:04Z","created_by":"claude"}]}
{"id":"pivot-104","title":"Define Step struct","description":"# Define Step Struct\n\n## File: internal/types/step.go\n\n## Implementation\n\n```go\n// Step is the single primitive in MEOW. Everything is a step.\n// IMPORTANT: Only 6 executor configs - NO Gate field (gate is not an executor).\ntype Step struct {\n    // Identity\n    ID       string       `yaml:\"id\"`\n    Executor ExecutorType `yaml:\"executor\"`\n\n    // Lifecycle\n    Status    StepStatus `yaml:\"status\"`\n    StartedAt *time.Time `yaml:\"started_at,omitempty\"`\n    DoneAt    *time.Time `yaml:\"done_at,omitempty\"`\n\n    // Dependencies\n    Needs []string `yaml:\"needs,omitempty\"`\n\n    // Expansion tracking (for crash recovery)\n    ExpandedFrom string   `yaml:\"expanded_from,omitempty\"` // Parent expand step ID\n    ExpandedInto []string `yaml:\"expanded_into,omitempty\"` // Child step IDs (on expand steps)\n\n    // Data\n    Outputs map[string]any `yaml:\"outputs,omitempty\"`\n    Error   *StepError     `yaml:\"error,omitempty\"`\n\n    // Executor-specific config (exactly one populated based on Executor)\n    // NOTE: Only 6 configs for 6 executors. NO Gate - it's a branch pattern.\n    Shell  *ShellConfig  `yaml:\"shell,omitempty\"`\n    Spawn  *SpawnConfig  `yaml:\"spawn,omitempty\"`\n    Kill   *KillConfig   `yaml:\"kill,omitempty\"`\n    Expand *ExpandConfig `yaml:\"expand,omitempty\"`\n    Branch *BranchConfig `yaml:\"branch,omitempty\"`\n    Agent  *AgentConfig  `yaml:\"agent,omitempty\"`\n}\n\n// StepError captures failure information.\ntype StepError struct {\n    Message string `yaml:\"message\"`\n    Code    int    `yaml:\"code,omitempty\"`    // Exit code for shell\n    Output  string `yaml:\"output,omitempty\"`  // stderr or other context\n}\n\n// InlineStep is used for inline step definitions in branch targets.\ntype InlineStep struct {\n    ID       string            `yaml:\"id\" toml:\"id\"`\n    Executor ExecutorType      `yaml:\"executor\" toml:\"executor\"`\n    Prompt   string            `yaml:\"prompt,omitempty\" toml:\"prompt,omitempty\"`\n    Agent    string            `yaml:\"agent,omitempty\" toml:\"agent,omitempty\"`\n    Needs    []string          `yaml:\"needs,omitempty\" toml:\"needs,omitempty\"`\n}\n```\n\n## Helper Methods\n\n```go\n// IsReady returns true if all dependencies are done.\nfunc (s *Step) IsReady(steps map[string]*Step) bool {\n    if s.Status != StepStatusPending {\n        return false\n    }\n    for _, depID := range s.Needs {\n        dep, ok := steps[depID]\n        if !ok || dep.Status != StepStatusDone {\n            return false\n        }\n    }\n    return true\n}\n\n// Validate checks the step is well-formed.\nfunc (s *Step) Validate() error {\n    if s.ID == \"\" {\n        return fmt.Errorf(\"step ID is required\")\n    }\n    if strings.Contains(s.ID, \".\") {\n        return fmt.Errorf(\"step ID cannot contain dots (reserved for expansion prefixes)\")\n    }\n    if !s.Executor.Valid() {\n        return fmt.Errorf(\"invalid executor: %s\", s.Executor)\n    }\n    return s.validateConfig()\n}\n\n// validateConfig ensures exactly one config is set matching the executor\nfunc (s *Step) validateConfig() error {\n    // Count non-nil configs and verify match\n    configs := map[ExecutorType]bool{\n        ExecutorShell:  s.Shell != nil,\n        ExecutorSpawn:  s.Spawn != nil,\n        ExecutorKill:   s.Kill != nil,\n        ExecutorExpand: s.Expand != nil,\n        ExecutorBranch: s.Branch != nil,\n        ExecutorAgent:  s.Agent != nil,\n    }\n    \n    if !configs[s.Executor] {\n        return fmt.Errorf(\"step %s: missing config for executor %s\", s.ID, s.Executor)\n    }\n    \n    for exec, hasConfig := range configs {\n        if hasConfig \u0026\u0026 exec != s.Executor {\n            return fmt.Errorf(\"step %s: has config for %s but executor is %s\", s.ID, exec, s.Executor)\n        }\n    }\n    return nil\n}\n\n// Complete marks the step as done with outputs.\nfunc (s *Step) Complete(outputs map[string]any) error {\n    if !s.Status.CanTransitionTo(StepStatusDone) {\n        return fmt.Errorf(\"cannot complete step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusDone\n    s.DoneAt = \u0026now\n    s.Outputs = outputs\n    return nil\n}\n\n// Fail marks the step as failed with error info.\nfunc (s *Step) Fail(err *StepError) error {\n    if !s.Status.CanTransitionTo(StepStatusFailed) {\n        return fmt.Errorf(\"cannot fail step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusFailed\n    s.DoneAt = \u0026now\n    s.Error = err\n    return nil\n}\n\n// SetCompleting marks the step as transitioning to done.\nfunc (s *Step) SetCompleting() error {\n    if !s.Status.CanTransitionTo(StepStatusCompleting) {\n        return fmt.Errorf(\"cannot set completing in status %s\", s.Status)\n    }\n    s.Status = StepStatusCompleting\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Step struct with 6 executor config fields (NO Gate)\n- [ ] StepError struct\n- [ ] InlineStep for branch targets\n- [ ] IsReady() helper\n- [ ] Validate() method with step ID dot check\n- [ ] validateConfig() for executor/config match\n- [ ] Complete(), Fail(), SetCompleting() methods\n- [ ] Unit tests for all methods and status transitions\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:05Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.968252706-05:00","closed_at":"2026-01-08T22:58:49.968252706-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"pivot-104","depends_on_id":"pivot-102","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"},{"issue_id":"pivot-104","depends_on_id":"pivot-103","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"}]}
{"id":"pivot-105","title":"Define Workflow struct","description":"# Define Workflow Struct\n\n## File: internal/types/workflow.go\n\n## Implementation\n\n\\`\\`\\`go\npackage types\n\nimport \"time\"\n\n// WorkflowStatus represents the lifecycle state of a workflow.\ntype WorkflowStatus string\n\nconst (\n    WorkflowStatusPending WorkflowStatus = \"pending\" // Created but not started\n    WorkflowStatusRunning WorkflowStatus = \"running\" // Orchestrator is processing\n    WorkflowStatusDone    WorkflowStatus = \"done\"    // All steps completed\n    WorkflowStatusFailed  WorkflowStatus = \"failed\"  // A step failed\n)\n\n// AgentInfo tracks persisted state for an agent.\ntype AgentInfo struct {\n    TmuxSession string \\`yaml:\"tmux_session\"\\`\n    Status      string \\`yaml:\"status\"\\`       // active, idle\n    Workdir     string \\`yaml:\"workdir\"\\`\n    CurrentStep string \\`yaml:\"current_step,omitempty\"\\`\n}\n\n// Workflow represents a running workflow instance.\ntype Workflow struct {\n    // Identity\n    ID       string \\`yaml:\"id\"\\`       // Unique identifier (e.g., \"wf-abc123\")\n    Template string \\`yaml:\"template\"\\` // Source template path\n\n    // Lifecycle\n    Status    WorkflowStatus \\`yaml:\"status\"\\`\n    StartedAt time.Time      \\`yaml:\"started_at\"\\`\n    DoneAt    *time.Time     \\`yaml:\"done_at,omitempty\"\\`\n\n    // Configuration\n    Variables map[string]string \\`yaml:\"variables,omitempty\"\\`\n\n    // Agent state - tracked for crash recovery and file_path validation\n    Agents map[string]*AgentInfo \\`yaml:\"agents,omitempty\"\\`\n\n    // State - all steps with their current state\n    Steps map[string]*Step \\`yaml:\"steps\"\\`\n}\n\n// NewWorkflow creates a new workflow instance.\nfunc NewWorkflow(id, template string, vars map[string]string) *Workflow {\n    return \u0026Workflow{\n        ID:        id,\n        Template:  template,\n        Status:    WorkflowStatusPending,\n        StartedAt: time.Now(),\n        Variables: vars,\n        Agents:    make(map[string]*AgentInfo),\n        Steps:     make(map[string]*Step),\n    }\n}\n\n// AddStep adds a step to the workflow.\nfunc (w *Workflow) AddStep(step *Step) error {\n    if _, exists := w.Steps[step.ID]; exists {\n        return fmt.Errorf(\"step %s already exists\", step.ID)\n    }\n    w.Steps[step.ID] = step\n    return nil\n}\n\n// RegisterAgent adds or updates agent state.\nfunc (w *Workflow) RegisterAgent(id string, info *AgentInfo) {\n    w.Agents[id] = info\n}\n\n// GetAgentWorkdir returns the working directory for an agent.\n// Used for file_path output validation.\nfunc (w *Workflow) GetAgentWorkdir(agentID string) (string, bool) {\n    agent, ok := w.Agents[agentID]\n    if !ok {\n        return \"\", false\n    }\n    return agent.Workdir, true\n}\n\n// GetReadySteps returns all steps that are ready to execute.\nfunc (w *Workflow) GetReadySteps() []*Step {\n    var ready []*Step\n    for _, step := range w.Steps {\n        if step.IsReady(w.Steps) {\n            ready = append(ready, step)\n        }\n    }\n    return ready\n}\n\n// AllDone returns true if all steps are in terminal state.\nfunc (w *Workflow) AllDone() bool {\n    for _, step := range w.Steps {\n        if !step.Status.IsTerminal() {\n            return false\n        }\n    }\n    return true\n}\n\n// HasFailed returns true if any step has failed.\nfunc (w *Workflow) HasFailed() bool {\n    for _, step := range w.Steps {\n        if step.Status == StepStatusFailed {\n            return true\n        }\n    }\n    return false\n}\n\n// Complete marks the workflow as done.\nfunc (w *Workflow) Complete() {\n    now := time.Now()\n    w.Status = WorkflowStatusDone\n    w.DoneAt = \u0026now\n}\n\n// Fail marks the workflow as failed.\nfunc (w *Workflow) Fail() {\n    now := time.Now()\n    w.Status = WorkflowStatusFailed\n    w.DoneAt = \u0026now\n}\n\n// GetStep retrieves a step by ID.\nfunc (w *Workflow) GetStep(id string) (*Step, bool) {\n    step, ok := w.Steps[id]\n    return step, ok\n}\n\n// GetStepsForAgent returns steps assigned to the given agent.\nfunc (w *Workflow) GetStepsForAgent(agentID string) []*Step {\n    var result []*Step\n    for _, step := range w.Steps {\n        if step.Executor == ExecutorAgent \u0026\u0026 step.Agent != nil \u0026\u0026 step.Agent.Agent == agentID {\n            result = append(result, step)\n        }\n    }\n    return result\n}\n\\`\\`\\`\n\n## Design Notes\n\n- **Steps as map** - O(1) lookup by ID, which is common during dependency resolution.\n- **Variables stored** - The resolved variables are saved so we can reconstruct context on restart.\n- **Agents field** - Tracks agent state for:\n  - Crash recovery (check if tmux session still exists)\n  - file_path validation (resolve relative paths against agent's workdir)\n- **No parent/child relationship** - Expanded steps are just more steps in the map with dependency links.\n\n## YAML Representation\n\n\\`\\`\\`yaml\n# .meow/workflows/wf-abc123.yaml\nid: wf-abc123\ntemplate: work-loop.meow.toml\nstatus: running\nstarted_at: 2026-01-08T21:00:00Z\n\nvariables:\n  agent: claude-1\n\nagents:\n  claude-1:\n    tmux_session: meow-wf-abc123-claude-1\n    status: active\n    workdir: /data/projects/myapp/.meow/worktrees/claude-1\n    current_step: impl.write-tests\n\nsteps:\n  # ... step definitions ...\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] WorkflowStatus enum\n- [ ] AgentInfo struct for persisted agent state\n- [ ] Workflow struct with Agents field\n- [ ] NewWorkflow() constructor initializes Agents map\n- [ ] RegisterAgent() method\n- [ ] GetAgentWorkdir() for file_path validation\n- [ ] AddStep() method\n- [ ] GetReadySteps() helper\n- [ ] AllDone() and HasFailed() helpers\n- [ ] GetStepsForAgent() for agent queries\n- [ ] Unit tests","notes":"**UPDATED for v2 spec**: Need to add Cleanup field (shell script that runs on workflow end), ClaudeSession field to AgentInfo (for session resume), and WorkflowStatusCleaningUp/WorkflowStatusStopped status values.","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:06Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.970090044-05:00","closed_at":"2026-01-08T22:58:49.970090044-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"pivot-105","depends_on_id":"pivot-104","type":"blocks","created_at":"2026-01-08T12:00:06Z","created_by":"claude"}]}
{"id":"pivot-106","title":"Remove old bead types","description":"# Remove Old Bead Types\n\n## Context\n\nOnce new types are in place and the orchestrator is updated, we can remove the old bead-centric types. This is the cleanup step.\n\n## Files to Modify\n\n### internal/types/bead.go - DELETE ENTIRELY\n\nRemove:\n- BeadType enum\n- BeadTier enum\n- BeadStatus enum (replaced by StepStatus)\n- Bead struct\n- All spec structs (ConditionSpec, StartSpec, etc.)\n- All validation methods\n\n### internal/types/agent.go - KEEP\n\nAgent type is still needed for agent state tracking.\n\n## Migration Strategy\n\n1. First, implement new types alongside old\n2. Update orchestrator to use new types\n3. Update CLI to use new types\n4. Only then delete old types\n\nThis task should be done LAST in the type system epic.\n\n## Acceptance Criteria\n\n- [ ] internal/types/bead.go deleted\n- [ ] No imports of old bead types remain\n- [ ] All tests pass with new types\n- [ ] No references to BeadType, BeadTier, etc.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:07Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-106","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"pivot-106","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"pivot-106","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"pivot-106","depends_on_id":"pivot-501","type":"blocks","created_at":"2026-01-08T22:22:05.088766438-05:00","created_by":"ubuntu"},{"issue_id":"pivot-106","depends_on_id":"pivot-502","type":"blocks","created_at":"2026-01-08T22:22:06.815632593-05:00","created_by":"ubuntu"},{"issue_id":"pivot-106","depends_on_id":"pivot-503","type":"blocks","created_at":"2026-01-08T22:22:08.053806741-05:00","created_by":"ubuntu"}]}
{"id":"pivot-200","title":"EPIC: Workflow State Persistence","description":"# Workflow State Persistence\n\n## The Big Change\n\nPreviously: All state in `.beads/issues.jsonl` (JSONL format, shared with bd CLI)\nNow: Per-workflow YAML files in `.meow/workflows/`\n\n## Why YAML?\n\n1. **Human-readable** - Easy to debug, inspect, manually edit if needed\n2. **Per-workflow files** - No giant monolithic file, easy cleanup\n3. **Atomic writes** - Write to temp, rename (no partial states)\n4. **Git-trackable** - Can version control workflow state if desired\n5. **No lock contention** - Each workflow is independent\n\n## Directory Structure\n\n```\n.meow/\n├── config.toml              # User configuration\n├── agents.yaml              # Active agent sessions\n├── orchestrator.lock        # Prevents concurrent instances\n└── workflows/\n    ├── wf-abc123.yaml       # Workflow instance state\n    └── wf-def456.yaml\n```\n\n## Workflow State File Format\n\n```yaml\n# .meow/workflows/wf-abc123.yaml\nid: wf-abc123\ntemplate: work-loop.meow.toml\nstatus: running\nstarted_at: 2026-01-08T21:00:00Z\n\nvariables:\n  agent: claude-1\n\nsteps:\n  select:\n    executor: agent\n    status: done\n    done_at: 2026-01-08T21:02:00Z\n    agent:\n      agent: claude-1\n      prompt: \"Select the next task...\"\n    outputs:\n      task_id: \"PROJ-123\"\n\n  implement:\n    executor: expand\n    status: done\n    expand:\n      template: \".tdd\"\n\n  implement.load-context:\n    executor: agent\n    status: running\n    needs: [\"implement\"]\n    agent:\n      agent: claude-1\n      prompt: \"Load context...\"\n```\n\n## Key Operations\n\n- **Create** - New workflow from template\n- **Load** - Read workflow state from YAML\n- **Save** - Write workflow state to YAML (atomic)\n- **List** - Enumerate all workflow files\n- **Delete** - Remove completed workflow file\n\n## No More Bead Store\n\nThe BeadStore interface is replaced by WorkflowStore. No more:\n- Tier filtering\n- HookBead queries\n- JSONL parsing","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:10Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-200","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:10Z","created_by":"claude"}]}
{"id":"pivot-201","title":"Define WorkflowStore interface","description":"# Define WorkflowStore Interface\n\n## File: internal/orchestrator/workflowstore.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// WorkflowStore provides persistence for workflow state.\ntype WorkflowStore interface {\n    // Create persists a new workflow.\n    Create(ctx context.Context, wf *types.Workflow) error\n\n    // Get retrieves a workflow by ID.\n    Get(ctx context.Context, id string) (*types.Workflow, error)\n\n    // Save persists workflow state (atomic write).\n    Save(ctx context.Context, wf *types.Workflow) error\n\n    // Delete removes a workflow.\n    Delete(ctx context.Context, id string) error\n\n    // List returns all workflows matching filter.\n    List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error)\n\n    // GetByAgent returns workflows with steps assigned to agent.\n    GetByAgent(ctx context.Context, agentID string) ([]*types.Workflow, error)\n}\n\n// WorkflowFilter for listing workflows.\ntype WorkflowFilter struct {\n    Status types.WorkflowStatus // Filter by status\n}\n```\n\n## Design Notes\n\n- **Simple interface** - Just CRUD + listing\n- **No tier filtering** - Tiers don't exist in new model\n- **GetByAgent** - Needed for `meow prime` to find agent's work\n- **Atomic Save** - Implementation must be atomic (temp file + rename)\n\n## Acceptance Criteria\n\n- [ ] WorkflowStore interface defined\n- [ ] WorkflowFilter struct\n- [ ] Interface documented","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:11Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.971932522-05:00","closed_at":"2026-01-08T22:58:49.971932522-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"pivot-201","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T12:00:11Z","created_by":"claude"}]}
{"id":"pivot-202","title":"Implement YAMLWorkflowStore","description":"# Implement YAMLWorkflowStore\n\n## File: internal/orchestrator/yamlstore.go\n\n## Implementation\n\nThis implementation includes **atomic file writes** and **orchestrator lock management** (previously meow-204).\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n    \"syscall\"\n\n    \"gopkg.in/yaml.v3\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// YAMLWorkflowStore persists workflows as YAML files with atomic writes.\ntype YAMLWorkflowStore struct {\n    dir      string   // .meow/workflows\n    lockFile *os.File // Exclusive lock to prevent multiple orchestrators\n}\n\n// NewYAMLWorkflowStore creates a new store and acquires exclusive lock.\nfunc NewYAMLWorkflowStore(dir string) (*YAMLWorkflowStore, error) {\n    if err := os.MkdirAll(dir, 0755); err != nil {\n        return nil, fmt.Errorf(\"creating workflow dir: %w\", err)\n    }\n    \n    // Acquire exclusive lock\n    lockPath := filepath.Join(dir, \".lock\")\n    lockFile, err := os.OpenFile(lockPath, os.O_CREATE|os.O_RDWR, 0644)\n    if err != nil {\n        return nil, fmt.Errorf(\"opening lock file: %w\", err)\n    }\n    \n    if err := syscall.Flock(int(lockFile.Fd()), syscall.LOCK_EX|syscall.LOCK_NB); err != nil {\n        lockFile.Close()\n        return nil, fmt.Errorf(\"another orchestrator is running (lock held): %w\", err)\n    }\n    \n    // Recover from any interrupted writes\n    if err := recoverInterruptedWrites(dir); err != nil {\n        lockFile.Close()\n        return nil, fmt.Errorf(\"recovering interrupted writes: %w\", err)\n    }\n    \n    return \u0026YAMLWorkflowStore{dir: dir, lockFile: lockFile}, nil\n}\n\n// Close releases the lock.\nfunc (s *YAMLWorkflowStore) Close() error {\n    if s.lockFile != nil {\n        syscall.Flock(int(s.lockFile.Fd()), syscall.LOCK_UN)\n        return s.lockFile.Close()\n    }\n    return nil\n}\n\n// recoverInterruptedWrites handles .tmp files left from crashed writes.\nfunc recoverInterruptedWrites(dir string) error {\n    entries, err := os.ReadDir(dir)\n    if err != nil {\n        return err\n    }\n    \n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml.tmp\") {\n            continue\n        }\n        \n        tmpPath := filepath.Join(dir, entry.Name())\n        mainPath := strings.TrimSuffix(tmpPath, \".tmp\")\n        \n        // Check if main file exists and is valid\n        if _, err := os.Stat(mainPath); err == nil {\n            // Main file exists, delete orphan temp\n            os.Remove(tmpPath)\n        } else {\n            // Main file missing, promote temp\n            os.Rename(tmpPath, mainPath)\n        }\n    }\n    return nil\n}\n\n// Save persists workflow state atomically (write-then-rename).\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow) error {\n    data, err := yaml.Marshal(wf)\n    if err != nil {\n        return fmt.Errorf(\"marshaling workflow: %w\", err)\n    }\n    \n    mainPath := filepath.Join(s.dir, wf.ID+\".yaml\")\n    tmpPath := mainPath + \".tmp\"\n    \n    // Write to temp file\n    if err := os.WriteFile(tmpPath, data, 0644); err != nil {\n        return fmt.Errorf(\"writing temp file: %w\", err)\n    }\n    \n    // Atomic rename\n    if err := os.Rename(tmpPath, mainPath); err != nil {\n        os.Remove(tmpPath) // Clean up on failure\n        return fmt.Errorf(\"renaming temp file: %w\", err)\n    }\n    \n    return nil\n}\n\n// Get retrieves a workflow by ID.\nfunc (s *YAMLWorkflowStore) Get(ctx context.Context, id string) (*types.Workflow, error) {\n    path := filepath.Join(s.dir, id+\".yaml\")\n    data, err := os.ReadFile(path)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil, fmt.Errorf(\"workflow not found: %s\", id)\n        }\n        return nil, err\n    }\n    \n    var wf types.Workflow\n    if err := yaml.Unmarshal(data, \u0026wf); err != nil {\n        return nil, fmt.Errorf(\"parsing workflow %s: %w\", id, err)\n    }\n    return \u0026wf, nil\n}\n\n// Create persists a new workflow.\nfunc (s *YAMLWorkflowStore) Create(ctx context.Context, wf *types.Workflow) error {\n    path := filepath.Join(s.dir, wf.ID+\".yaml\")\n    if _, err := os.Stat(path); err == nil {\n        return fmt.Errorf(\"workflow already exists: %s\", wf.ID)\n    }\n    return s.Save(ctx, wf)\n}\n\n// Delete removes a workflow.\nfunc (s *YAMLWorkflowStore) Delete(ctx context.Context, id string) error {\n    path := filepath.Join(s.dir, id+\".yaml\")\n    return os.Remove(path)\n}\n\n// List returns all workflows matching filter.\nfunc (s *YAMLWorkflowStore) List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error) {\n    entries, err := os.ReadDir(s.dir)\n    if err != nil {\n        return nil, err\n    }\n    \n    var workflows []*types.Workflow\n    for _, entry := range entries {\n        if !strings.HasSuffix(entry.Name(), \".yaml\") || entry.Name() == \".lock\" {\n            continue\n        }\n        \n        id := strings.TrimSuffix(entry.Name(), \".yaml\")\n        wf, err := s.Get(ctx, id)\n        if err != nil {\n            continue // Skip invalid files\n        }\n        \n        if filter.Status != \"\" \u0026\u0026 wf.Status != filter.Status {\n            continue\n        }\n        workflows = append(workflows, wf)\n    }\n    return workflows, nil\n}\n\n// GetByAgent returns workflows with steps assigned to agent.\nfunc (s *YAMLWorkflowStore) GetByAgent(ctx context.Context, agentID string) ([]*types.Workflow, error) {\n    all, err := s.List(ctx, WorkflowFilter{})\n    if err != nil {\n        return nil, err\n    }\n    \n    var result []*types.Workflow\n    for _, wf := range all {\n        for _, step := range wf.Steps {\n            if step.Agent != nil \u0026\u0026 step.Agent.Agent == agentID {\n                result = append(result, wf)\n                break\n            }\n        }\n    }\n    return result, nil\n}\n```\n\n## Key Features\n\n1. **Atomic writes** - write-then-rename pattern prevents corruption\n2. **Exclusive lock** - prevents multiple orchestrators via flock()\n3. **Crash recovery** - handles orphan .tmp files on startup\n4. **Clean shutdown** - Close() releases lock\n\n## Acceptance Criteria\n\n- [ ] Create, Get, Save, Delete, List, GetByAgent methods\n- [ ] Atomic file writes (temp file + rename)\n- [ ] Exclusive lock via flock() on .lock file\n- [ ] recoverInterruptedWrites() on startup\n- [ ] Close() releases lock\n- [ ] Filter by status in List()\n- [ ] Unit tests for all methods\n- [ ] Test crash recovery scenarios\n- [ ] Test lock contention\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:12Z","created_by":"claude","updated_at":"2026-01-08T22:58:49.973822351-05:00","closed_at":"2026-01-08T22:58:49.973822351-05:00","close_reason":"Implemented as part of persistence track commit e21ff43","dependencies":[{"issue_id":"pivot-202","depends_on_id":"pivot-201","type":"blocks","created_at":"2026-01-08T12:00:12Z","created_by":"claude"}]}
{"id":"pivot-203","title":"Implement workflow ID generation","description":"# Implement Workflow ID Generation\n\n## File: internal/orchestrator/id.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"time\"\n)\n\n// GenerateWorkflowID creates a unique workflow identifier.\n// Format: wf-{timestamp_hex}-{random_hex}\n// Example: wf-1a2b3c4d-e5f6g7h8\nfunc GenerateWorkflowID() string {\n    ts := time.Now().UnixNano()\n    randBytes := make([]byte, 4)\n    rand.Read(randBytes)\n    return fmt.Sprintf(\"wf-%x-%s\", ts, hex.EncodeToString(randBytes))\n}\n\n// GenerateStepID creates a unique step identifier within a workflow.\n// Format: {parent}.{step_id}\n// Example: implement.load-context (from expand step \"implement\")\nfunc GenerateExpandedStepID(parentID, stepID string) string {\n    if parentID == \"\" {\n        return stepID\n    }\n    return parentID + \".\" + stepID\n}\n```\n\n## Design Notes\n\n- **Timestamp prefix** - Makes IDs roughly sortable by creation time\n- **Random suffix** - Prevents collisions for rapid creation\n- **Dot notation for expanded steps** - Makes hierarchy visible in IDs\n\n## Acceptance Criteria\n\n- [ ] GenerateWorkflowID() creates unique IDs\n- [ ] GenerateExpandedStepID() handles parent.child notation\n- [ ] IDs are filesystem-safe (no special chars)\n- [ ] Unit tests verify uniqueness","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:13Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-203","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T12:00:13Z","created_by":"claude"},{"issue_id":"pivot-203","depends_on_id":"pivot-201","type":"blocks","created_at":"2026-01-08T22:21:25.960023982-05:00","created_by":"ubuntu"}]}
{"id":"pivot-204","title":"Remove BeadStore and bead persistence","description":"# Remove BeadStore and Bead Persistence\n\n## Context\n\nOnce WorkflowStore is implemented and the orchestrator is using it, we can remove all bead persistence code.\n\n## Files to Remove/Modify\n\n### Remove entirely:\n- internal/orchestrator/beadstore.go\n- Any JSONL parsing code for beads\n\n### Modify:\n- internal/orchestrator/orchestrator.go - Remove BeadStore dependency\n- cmd/meow/cmd/*.go - Remove bead-specific queries\n\n## What We're NOT Removing\n\n- `.beads/` directory itself - Users may still use beads for task tracking\n- bd CLI integration - Templates can still prompt agents to use `bd`\n\nWe're just removing MEOW's internal use of beads as its state store.\n\n## Migration Strategy\n\n1. Implement WorkflowStore\n2. Update orchestrator to use WorkflowStore\n3. Update CLI to use WorkflowStore\n4. Remove BeadStore code\n\n## Acceptance Criteria\n\n- [ ] BeadStore interface removed\n- [ ] No JSONL parsing for beads\n- [ ] Orchestrator uses WorkflowStore\n- [ ] All tests pass without bead store","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:14Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-204","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:14Z","created_by":"claude"},{"issue_id":"pivot-204","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:14Z","created_by":"claude"}]}
{"id":"pivot-300","title":"EPIC: Template System Alignment","description":"# Template System Alignment\n\n## What's Changing\n\nThe template system is largely correct but needs updates for the new model:\n\n1. **executor field** instead of **type field**\n2. **Remove ephemeral/hooks_to** - No more tier detection\n3. **Remove legacy format** - Clean break, module format only\n4. **Agent mode field** - Replace collaborative type\n\n## Template Format (Before vs After)\n\n### Before (bead-centric)\n```toml\n[main]\nephemeral = true        # ← REMOVE\nhooks_to = \"work_bead\"  # ← REMOVE\n\n[[main.steps]]\nid = \"do-work\"\ntype = \"task\"           # ← CHANGE TO executor\nassignee = \"{{agent}}\"  # ← CHANGE TO agent field in config\ninstructions = \"...\"    # ← CHANGE TO prompt field in config\n```\n\n### After (workflow-centric)\n```toml\n[main]\nname = \"work-loop\"\ndescription = \"...\"\n\n[[main.steps]]\nid = \"do-work\"\nexecutor = \"agent\"      # ← executor, not type\nagent = \"{{agent}}\"\nprompt = \"...\"          # ← prompt, not instructions\nmode = \"autonomous\"     # ← optional, default\n\n[main.steps.outputs]\ntask_id = { required = true, type = \"string\" }\n```\n\n## Parser Changes\n\n- Parse `executor` field instead of `type`\n- Map TOML fields to executor config structs\n- Remove tier detection logic from baker\n- Remove HookBead assignment\n\n## Files Affected\n\n- internal/template/module.go - Parser\n- internal/template/baker.go - Bead→Step creation\n- internal/template/vars.go - Variable substitution (mostly unchanged)\n- internal/template/loader.go - Template loading (mostly unchanged)","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:20Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-300","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:20Z","created_by":"claude"}]}
{"id":"pivot-301","title":"Update template parser for executor field","description":"# Update Template Parser for Executor Field\n\n## File: internal/template/module.go\n\n## Changes\n\n### Step struct update\n\n```go\n// Before\ntype Step struct {\n    ID           string   `toml:\"id\"`\n    Type         string   `toml:\"type\"`  // ← Remove\n    Instructions string   `toml:\"instructions\"`\n    Assignee     string   `toml:\"assignee\"`\n    // ...\n}\n\n// After\ntype Step struct {\n    ID       string `toml:\"id\"`\n    Executor string `toml:\"executor\"` // ← Add\n\n    // Agent executor fields\n    Agent  string `toml:\"agent,omitempty\"`\n    Prompt string `toml:\"prompt,omitempty\"`\n    Mode   string `toml:\"mode,omitempty\"` // autonomous | interactive\n\n    // Shell executor fields\n    Command string `toml:\"command,omitempty\"`\n    Workdir string `toml:\"workdir,omitempty\"`\n    OnError string `toml:\"on_error,omitempty\"`\n\n    // Spawn executor fields (also uses Agent, Workdir)\n    ResumeSession string `toml:\"resume_session,omitempty\"`\n\n    // Kill executor fields (uses Agent)\n    Graceful *bool `toml:\"graceful,omitempty\"`\n    Timeout  int   `toml:\"timeout,omitempty\"`\n\n    // Expand executor fields\n    Template  string            `toml:\"template,omitempty\"`\n    Variables map[string]string `toml:\"variables,omitempty\"`\n\n    // Branch executor fields\n    Condition string               `toml:\"condition,omitempty\"`\n    OnTrue    *ExpansionTarget     `toml:\"on_true,omitempty\"`\n    OnFalse   *ExpansionTarget     `toml:\"on_false,omitempty\"`\n    OnTimeout *ExpansionTarget     `toml:\"on_timeout,omitempty\"`\n\n    // Gate executor fields (uses Prompt)\n    // Timeout already defined above\n\n    // Shared\n    Needs   []string          `toml:\"needs,omitempty\"`\n    Env     map[string]string `toml:\"env,omitempty\"`\n    Outputs map[string]any    `toml:\"outputs,omitempty\"`\n}\n```\n\n### Validation update\n\nValidate that required fields are present based on executor:\n\n```go\nfunc (s *Step) Validate() error {\n    switch s.Executor {\n    case \"shell\":\n        if s.Command == \"\" {\n            return fmt.Errorf(\"shell executor requires command\")\n        }\n    case \"agent\":\n        if s.Agent == \"\" {\n            return fmt.Errorf(\"agent executor requires agent\")\n        }\n        if s.Prompt == \"\" {\n            return fmt.Errorf(\"agent executor requires prompt\")\n        }\n    // ... etc\n    }\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Step struct uses executor field\n- [ ] All executor-specific fields present\n- [ ] Validation checks required fields per executor\n- [ ] Old 'type' field no longer parsed\n- [ ] Update all test templates\n- [ ] Unit tests for each executor type","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:21Z","created_by":"claude","updated_at":"2026-01-08T22:57:24.474662286-05:00","closed_at":"2026-01-08T22:57:24.474662286-05:00","close_reason":"Implemented executor field in Step struct with validation per executor type. Added unit tests.","dependencies":[{"issue_id":"pivot-301","depends_on_id":"pivot-103","type":"blocks","created_at":"2026-01-08T12:00:21Z","created_by":"claude"}]}
{"id":"pivot-302","title":"Remove ephemeral and hooks_to from workflow","description":"# Remove ephemeral and hooks_to from Workflow\n\n## File: internal/template/module.go\n\n## Changes\n\n### Remove from Workflow struct\n\n```go\n// Before\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Ephemeral   bool            `toml:\"ephemeral,omitempty\"`   // ← Remove\n    Internal    bool            `toml:\"internal,omitempty\"`\n    HooksTo     string          `toml:\"hooks_to,omitempty\"`    // ← Remove\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n\n// After\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Internal    bool            `toml:\"internal,omitempty\"`\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n```\n\n### Why These Are Removed\n\n**ephemeral**: Was used to mark workflows whose steps become \"wisps\" (agent-visible ephemeral steps). In the new model, there's no tier distinction - all steps are just steps.\n\n**hooks_to**: Was used to link wisp steps to a work bead ID. In the new model, MEOW is task-tracking agnostic - it doesn't know about beads.\n\n## Migration Note\n\nExisting templates with these fields will have them ignored (TOML parsing allows extra fields). We should update example templates to remove them.\n\n## Acceptance Criteria\n\n- [ ] ephemeral field removed from Workflow struct\n- [ ] hooks_to field removed from Workflow struct\n- [ ] Update all example templates\n- [ ] Update tests that used these fields\n- [ ] No runtime errors if old templates have these fields","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:22Z","created_by":"claude","updated_at":"2026-01-08T23:03:18.939121034-05:00","closed_at":"2026-01-08T23:03:18.939121034-05:00","close_reason":"Removed ephemeral and hooks_to from Workflow struct. Step.Ephemeral retained as legacy.","dependencies":[{"issue_id":"pivot-302","depends_on_id":"pivot-300","type":"blocks","created_at":"2026-01-08T12:00:22Z","created_by":"claude"},{"issue_id":"pivot-302","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T22:21:28.226286481-05:00","created_by":"ubuntu"}]}
{"id":"pivot-303","title":"Refactor baker to create Steps instead of Beads","description":"# Refactor Baker to Create Steps Instead of Beads\n\n## File: internal/template/baker.go\n\n## The Big Change\n\nThe baker currently transforms template workflows into Bead objects. It needs to transform them into Step objects instead.\n\n### Before\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Bead, error) {\n    var beads []*types.Bead\n    for _, step := range workflow.Steps {\n        bead := b.workflowStepToBead(step, vars)\n        beads = append(beads, bead)\n    }\n    return beads, nil\n}\n```\n\n### After\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Step, error) {\n    var steps []*types.Step\n    for _, templateStep := range workflow.Steps {\n        step := b.templateStepToStep(templateStep, vars)\n        steps = append(steps, step)\n    }\n    return steps, nil\n}\n\nfunc (b *Baker) templateStepToStep(ts *Step, vars map[string]string) *types.Step {\n    step := \u0026types.Step{\n        ID:       ts.ID,\n        Executor: types.ExecutorType(ts.Executor),\n        Status:   types.StepStatusPending,\n        Needs:    ts.Needs,\n    }\n\n    // Set executor-specific config\n    switch step.Executor {\n    case types.ExecutorShell:\n        step.Shell = \u0026types.ShellConfig{\n            Command: substitute(ts.Command, vars),\n            Workdir: substitute(ts.Workdir, vars),\n            Env:     substituteMap(ts.Env, vars),\n            OnError: ts.OnError,\n        }\n    case types.ExecutorAgent:\n        step.Agent = \u0026types.AgentConfig{\n            Agent:  substitute(ts.Agent, vars),\n            Prompt: substitute(ts.Prompt, vars),\n            Mode:   types.AgentMode(ts.Mode),\n        }\n    // ... other executors\n    }\n\n    return step\n}\n```\n\n## What to Remove\n\n- Tier detection logic (determineTier)\n- HookBead assignment\n- SourceWorkflow assignment\n- All bead-specific field setting\n\n## Acceptance Criteria\n\n- [ ] Baker.Bake() returns []*types.Step\n- [ ] All 7 executor types create correct config\n- [ ] Variable substitution works in all fields\n- [ ] No tier/HookBead logic remains\n- [ ] Unit tests for each executor type","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:23Z","created_by":"claude","updated_at":"2026-01-08T23:52:03.912888016-05:00","closed_at":"2026-01-08T23:52:03.912888016-05:00","close_reason":"Closed","dependencies":[{"issue_id":"pivot-303","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"},{"issue_id":"pivot-303","depends_on_id":"pivot-302","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"},{"issue_id":"pivot-303","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T22:21:32.735452222-05:00","created_by":"ubuntu"}]}
{"id":"pivot-304","title":"Remove legacy [meta] format support","description":"# Remove Legacy [meta] Format Support\n\n## Context\n\nThe template system currently supports two formats:\n1. Legacy: `[meta]` section + `[[steps]]` array\n2. Module: `[workflow-name]` sections\n\nPer the clean break decision, we're removing legacy format support.\n\n## Files to Modify\n\n### internal/template/parser.go\n\n- Remove `ParseLegacy()` function\n- Remove format detection logic\n- Remove any `[meta]` parsing code\n\n### internal/template/module.go\n\n- Remove `IsLegacyFormat()` detection\n- Parser should only handle module format\n\n## Error Handling\n\nIf someone tries to use a legacy template:\n```\nError: Legacy template format ([meta] section) is no longer supported.\nPlease convert to module format. See docs/MVP-SPEC-v2.md for format.\n```\n\n## Acceptance Criteria\n\n- [ ] Legacy parser removed\n- [ ] Clear error for legacy templates\n- [ ] All example templates use module format\n- [ ] Tests updated to use module format only","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:24Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-304","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:24Z","created_by":"claude"}]}
{"id":"pivot-305","title":"Update example templates for new format","description":"# Update Example Templates for New Format\n\n## Files to Update\n\nAll templates in:\n- cmd/meow/cmd/templates/\n- examples/templates/\n- testdata/templates/\n\n## Changes Required\n\n1. `type` → `executor`\n2. `assignee` → `agent` (in step, for agent executor)\n3. `instructions` → `prompt`\n4. Remove `ephemeral` and `hooks_to`\n5. Add `mode` field for interactive steps (was `collaborative` type)\n\n## Example Conversion\n\n### Before\n```toml\n[main]\nephemeral = true\nhooks_to = \"work_bead\"\n\n[[main.steps]]\nid = \"do-work\"\ntype = \"task\"\nassignee = \"{{agent}}\"\ninstructions = \"Do the work\"\n```\n\n### After\n```toml\n[main]\nname = \"work\"\n\n[[main.steps]]\nid = \"do-work\"\nexecutor = \"agent\"\nagent = \"{{agent}}\"\nprompt = \"Do the work\"\nmode = \"autonomous\"\n```\n\n## Templates to Create\n\nNew canonical examples:\n- simple-agent.meow.toml - Single agent step\n- sequential.meow.toml - A → B → C\n- branching.meow.toml - Conditional flow\n- looping.meow.toml - Recursive expansion\n- multi-agent.meow.toml - Parallel agents\n- human-gate.meow.toml - Human approval flow\n\n## Acceptance Criteria\n\n- [ ] All existing templates converted\n- [ ] New canonical examples created\n- [ ] All templates validate successfully\n- [ ] README updated with new format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:25Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-305","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:25Z","created_by":"claude"},{"issue_id":"pivot-305","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T22:21:34.383363589-05:00","created_by":"ubuntu"}]}
{"id":"pivot-400","title":"EPIC: Orchestrator Refactor","description":"# Orchestrator Refactor\n\n## Current State\n\nThe orchestrator (`internal/orchestrator/orchestrator.go`) currently:\n- Uses BeadStore for state\n- Dispatches by BeadType (8 types)\n- Has tier-based priority sorting\n- Manages bead lifecycle\n\n## New Model\n\nThe orchestrator will:\n- Use WorkflowStore for state\n- Dispatch by ExecutorType (7 executors)\n- Simple priority: orchestrator executors before external\n- Manage step lifecycle within workflows\n\n## Key Changes\n\n### Main Loop\n\n```go\n// Before\nfor {\n    bead, _ := store.GetNextReady(ctx)\n    if bead == nil {\n        if store.AllDone(ctx) { break }\n        continue\n    }\n    dispatch(bead)\n}\n\n// After\nfor {\n    // Process all active workflows\n    for _, wf := range store.List(ctx, WorkflowFilter{Status: Running}) {\n        step := getNextReadyStep(wf)\n        if step == nil {\n            if wf.AllDone() {\n                wf.Complete()\n                store.Save(ctx, wf)\n            }\n            continue\n        }\n        dispatch(ctx, wf, step)\n        store.Save(ctx, wf)  // Persist after each step\n    }\n}\n```\n\n### Dispatch\n\n```go\n// Before\nswitch bead.Type {\ncase BeadTypeTask: handleTask(bead)\ncase BeadTypeCode: handleCode(bead)\n// ... 8 cases\n}\n\n// After\nswitch step.Executor {\ncase ExecutorShell:  handleShell(ctx, wf, step)\ncase ExecutorSpawn:  handleSpawn(ctx, wf, step)\ncase ExecutorKill:   handleKill(ctx, wf, step)\ncase ExecutorExpand: handleExpand(ctx, wf, step)\ncase ExecutorBranch: handleBranch(ctx, wf, step)\ncase ExecutorAgent:  handleAgent(ctx, wf, step)\ncase ExecutorGate:   handleGate(ctx, wf, step)\n}\n```\n\n## Files Affected\n\n- internal/orchestrator/orchestrator.go - Main refactor\n- internal/orchestrator/state.go - Use WorkflowStore\n- internal/orchestrator/expander.go - Update for Step model","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:30Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-400","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T12:00:30Z","created_by":"claude"},{"issue_id":"pivot-400","depends_on_id":"pivot-300","type":"blocks","created_at":"2026-01-08T12:00:30Z","created_by":"claude"}]}
{"id":"pivot-401","title":"Refactor orchestrator for WorkflowStore","description":"# Refactor Orchestrator for WorkflowStore\n\n## File: internal/orchestrator/orchestrator.go\n\n## Changes\n\n### Constructor\n\n```go\n// Before\nfunc New(cfg *config.Config, store BeadStore, agents AgentManager, ...) *Orchestrator\n\n// After\nfunc New(cfg *config.Config, store WorkflowStore, agents AgentManager, ...) *Orchestrator\n```\n\n### Main Loop\n\nThe orchestrator processes ALL ready steps in each tick, enabling parallel agent execution.\n\n```go\nfunc (o *Orchestrator) Run(ctx context.Context) error {\n    ticker := time.NewTicker(o.cfg.PollInterval)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case \u003c-ctx.Done():\n            return ctx.Err()\n        case msg := \u003c-o.ipcChan:\n            o.handleIPC(ctx, msg) // Handle meow done, meow prime requests\n        case \u003c-ticker.C:\n            if err := o.tick(ctx); err != nil {\n                if err == errAllDone {\n                    return nil\n                }\n                o.logger.Error(\"tick error\", \"error\", err)\n            }\n        }\n    }\n}\n\nfunc (o *Orchestrator) tick(ctx context.Context) error {\n    workflows, _ := o.store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n\n    allComplete := true\n    for _, wf := range workflows {\n        if err := o.processWorkflow(ctx, wf); err != nil {\n            return err\n        }\n        if wf.Status == types.WorkflowStatusRunning {\n            allComplete = false\n        }\n    }\n\n    if allComplete \u0026\u0026 len(workflows) \u003e 0 {\n        return errAllDone\n    }\n    return nil\n}\n\nfunc (o *Orchestrator) processWorkflow(ctx context.Context, wf *types.Workflow) error {\n    // Check timeouts for running agent steps\n    o.checkStepTimeouts(ctx, wf)\n    \n    readySteps := wf.GetReadySteps()\n    if len(readySteps) == 0 {\n        if wf.AllDone() {\n            wf.Complete()\n            return o.store.Save(ctx, wf)\n        }\n        return nil // Waiting for external completion\n    }\n\n    // Sort by priority: orchestrator executors first, then by creation time\n    sort.Slice(readySteps, func(i, j int) bool {\n        if readySteps[i].Executor.IsOrchestrator() != readySteps[j].Executor.IsOrchestrator() {\n            return readySteps[i].Executor.IsOrchestrator()\n        }\n        return readySteps[i].ID \u003c readySteps[j].ID\n    })\n\n    // Process ALL ready steps (enables parallel agent execution)\n    for _, step := range readySteps {\n        // For agent steps, only inject if agent is idle\n        if step.Executor == types.ExecutorAgent {\n            if !o.agentIsIdle(wf, step.Agent.Agent) {\n                continue\n            }\n        }\n        if err := o.dispatch(ctx, wf, step); err != nil {\n            o.logger.Error(\"dispatch error\", \"step\", step.ID, \"error\", err)\n        }\n    }\n\n    return o.store.Save(ctx, wf)\n}\n```\n\n### Dispatch (6 Executors Only)\n\n```go\nfunc (o *Orchestrator) dispatch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    o.logger.Info(\"dispatching step\", \"id\", step.ID, \"executor\", step.Executor)\n\n    switch step.Executor {\n    case types.ExecutorShell:\n        return o.handleShell(ctx, wf, step)\n    case types.ExecutorSpawn:\n        return o.handleSpawn(ctx, wf, step)\n    case types.ExecutorKill:\n        return o.handleKill(ctx, wf, step)\n    case types.ExecutorExpand:\n        return o.handleExpand(ctx, wf, step)\n    case types.ExecutorBranch:\n        return o.handleBranch(ctx, wf, step)\n    case types.ExecutorAgent:\n        return o.handleAgent(ctx, wf, step)\n    default:\n        return fmt.Errorf(\"unknown executor: %s\", step.Executor)\n    }\n}\n\n// agentIsIdle returns true if no step assigned to this agent is running/completing\nfunc (o *Orchestrator) agentIsIdle(wf *types.Workflow, agentID string) bool {\n    for _, step := range wf.Steps {\n        if step.Agent != nil \u0026\u0026 step.Agent.Agent == agentID {\n            if step.Status == types.StepStatusRunning || step.Status == types.StepStatusCompleting {\n                return false\n            }\n        }\n    }\n    return true\n}\n```\n\n## Key Points\n\n- **6 executors only** - NO gate case (gate is branch + await-approval pattern)\n- **Process ALL ready steps** - enables parallel agent execution\n- **Agent idle check** - don't inject prompt to busy agent\n- **IPC integration** - handle meow done messages\n- **Timeout checking** - monitor running agent steps\n\n## Acceptance Criteria\n\n- [ ] Constructor takes WorkflowStore (not BeadStore)\n- [ ] Main loop with IPC message handling\n- [ ] dispatch() with exactly 6 cases (NO gate)\n- [ ] agentIsIdle() helper for parallel dispatch\n- [ ] Process ALL ready steps per tick\n- [ ] Orchestrator executors before agent executors\n- [ ] Save workflow after processing\n- [ ] Unit tests with WorkflowStore\n","notes":"**UPDATED for v2 spec**:\n1. Only 6 executors (no gate - it's a branch pattern)\n2. Must process ALL ready steps in each tick (parallel execution)\n3. Must handle IPC messages from agents (meow done)\n4. Must check step timeouts for running agent steps\n5. Must send ESC + inject prompts to agents directly","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:31Z","created_by":"claude","updated_at":"2026-01-08T23:51:21.052303601-05:00","closed_at":"2026-01-08T23:51:21.052303601-05:00","close_reason":"Refactored orchestrator to use WorkflowStore instead of BeadStore. All 6 executor dispatch cases implemented with stubs. Tests pass with manually-created Workflow/Step objects.","dependencies":[{"issue_id":"pivot-401","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"},{"issue_id":"pivot-401","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"}]}
{"id":"pivot-402","title":"Implement shell executor handler","description":"# Implement Shell Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleShell(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Shell == nil {\n        return fmt.Errorf(\"shell step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Execute command\n    outputs, err := o.executor.Execute(ctx, step.Shell)\n    if err != nil {\n        if step.Shell.OnError == \"continue\" {\n            o.logger.Warn(\"shell failed, continuing\", \"step\", step.ID, \"error\", err)\n            step.Complete(outputs)\n            return nil\n        }\n        step.Fail(\u0026types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(outputs)\n    return nil\n}\n```\n\n## Shell Executor Interface\n\n```go\ntype ShellExecutor interface {\n    Execute(ctx context.Context, cfg *types.ShellConfig) (map[string]any, error)\n}\n```\n\nThis should already exist from the old CodeExecutor - just needs interface rename.\n\n## Output Capture\n\nOutputs captured based on outputs config in template:\n- `stdout` - trimmed stdout\n- `stderr` - trimmed stderr\n- `exit_code` - integer exit code\n- `file:/path` - file contents\n\n## Acceptance Criteria\n\n- [ ] handleShell implementation\n- [ ] Uses ShellConfig from step\n- [ ] Respects on_error setting\n- [ ] Captures outputs correctly\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:32Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.97127465-05:00","closed_at":"2026-01-08T23:55:57.97127465-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"pivot-402","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:32Z","created_by":"claude"}]}
{"id":"pivot-403","title":"Implement spawn executor handler","description":"# Implement Spawn Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleSpawn(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Spawn == nil {\n        return fmt.Errorf(\"spawn step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Build agent start config\n    cfg := \u0026agent.StartConfig{\n        AgentID:       step.Spawn.Agent,\n        Workdir:       step.Spawn.Workdir,\n        Env:           step.Spawn.Env,\n        Prompt:        step.Spawn.Prompt,\n        ResumeSession: step.Spawn.ResumeSession,\n    }\n\n    // Set default prompt\n    if cfg.Prompt == \"\" {\n        cfg.Prompt = \"meow prime\"\n    }\n\n    // Always set MEOW_AGENT env var\n    if cfg.Env == nil {\n        cfg.Env = make(map[string]string)\n    }\n    cfg.Env[\"MEOW_AGENT\"] = step.Spawn.Agent\n    cfg.Env[\"MEOW_WORKFLOW\"] = wf.ID\n\n    // Start agent\n    if err := o.agents.Start(ctx, cfg); err != nil {\n        step.Fail(\u0026types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Agent Manager Interface\n\n```go\ntype AgentManager interface {\n    Start(ctx context.Context, cfg *agent.StartConfig) error\n    Stop(ctx context.Context, cfg *agent.StopConfig) error\n    IsRunning(ctx context.Context, agentID string) (bool, error)\n}\n```\n\n## Key Behaviors\n\n1. Sets MEOW_AGENT and MEOW_WORKFLOW env vars\n2. Default prompt is \"meow prime\"\n3. Creates tmux session meow-{agent}\n4. Auto-completes when agent starts\n\n## Acceptance Criteria\n\n- [ ] handleSpawn implementation\n- [ ] Sets MEOW_AGENT env var\n- [ ] Sets MEOW_WORKFLOW env var\n- [ ] Default prompt handling\n- [ ] Resume session support\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:33Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.973322479-05:00","closed_at":"2026-01-08T23:55:57.973322479-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"pivot-403","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:33Z","created_by":"claude"}]}
{"id":"pivot-404","title":"Implement kill executor handler","description":"# Implement Kill Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleKill(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Kill == nil {\n        return fmt.Errorf(\"kill step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    cfg := \u0026agent.StopConfig{\n        AgentID:  step.Kill.Agent,\n        Graceful: step.Kill.Graceful,\n        Timeout:  step.Kill.Timeout,\n    }\n\n    // Defaults\n    if cfg.Timeout == 0 {\n        cfg.Timeout = 10\n    }\n\n    if err := o.agents.Stop(ctx, cfg); err != nil {\n        // Log but don't fail - agent might already be dead\n        o.logger.Warn(\"kill step error\", \"step\", step.ID, \"error\", err)\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Graceful shutdown by default (SIGTERM, wait, SIGKILL)\n2. Default timeout 10 seconds\n3. Doesn't fail if agent already dead\n\n## Acceptance Criteria\n\n- [ ] handleKill implementation\n- [ ] Graceful shutdown support\n- [ ] Default timeout handling\n- [ ] Handles already-dead agents\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:34Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.975141081-05:00","closed_at":"2026-01-08T23:55:57.975141081-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"pivot-404","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:34Z","created_by":"claude"}]}
{"id":"pivot-405","title":"Implement expand executor handler","description":"# Implement Expand Executor Handler\n\n## File: internal/orchestrator/executors/expand.go\n\n## Purpose\n\nExpand a template's steps into the current workflow. Handles:\n- Template resolution (same file, external file)\n- Variable substitution\n- Step ID prefixing for uniqueness\n- Tracking ExpandedFrom/ExpandedInto for crash recovery\n- Resource limit checking (depth and total steps)\n\n## Implementation\n\n\\`\\`\\`go\npackage executors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"path/filepath\"\n    \n    \"github.com/meow-stack/meow-machine/internal/config\"\n    \"github.com/meow-stack/meow-machine/internal/template\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\ntype ExpandExecutor struct {\n    loader *template.Loader\n    limits *config.Limits\n}\n\nfunc NewExpandExecutor(loader *template.Loader, limits *config.Limits) *ExpandExecutor {\n    return \u0026ExpandExecutor{loader: loader, limits: limits}\n}\n\n// ExpansionContext tracks depth for resource limit checking.\ntype ExpansionContext struct {\n    Depth    int\n    MaxDepth int\n}\n\nfunc (e *ExpandExecutor) Execute(\n    ctx context.Context,\n    step *types.Step,\n    wf *types.Workflow,\n    subCtx *template.SubstitutionContext,\n    expCtx *ExpansionContext,\n) error {\n    // Check expansion depth limit\n    if expCtx.Depth \u003e= expCtx.MaxDepth {\n        return \u0026LimitExceededError{\n            Limit: \"max_expansion_depth\",\n            Value: expCtx.Depth,\n            Max:   expCtx.MaxDepth,\n        }\n    }\n    \n    cfg := step.Expand\n    \n    // Resolve template reference\n    tmpl, err := e.loader.Load(cfg.Template)\n    if err != nil {\n        return fmt.Errorf(\"loading template %s: %w\", cfg.Template, err)\n    }\n    \n    // Create substitution context with step's variables\n    childCtx := subCtx.WithVariables(cfg.Variables)\n    \n    // Expand template steps\n    expandedIDs := make([]string, 0)\n    for _, tmplStep := range tmpl.Steps {\n        // Prefix step ID with parent step ID for uniqueness\n        newID := step.ID + \".\" + tmplStep.ID\n        \n        // Clone and substitute\n        newStep, err := e.expandStep(tmplStep, newID, step.ID, childCtx)\n        if err != nil {\n            return fmt.Errorf(\"expanding step %s: %w\", tmplStep.ID, err)\n        }\n        \n        // Update dependencies to use prefixed IDs\n        newStep.Needs = e.prefixNeeds(tmplStep.Needs, step.ID, tmpl.Steps)\n        \n        // Track expansion relationship\n        newStep.ExpandedFrom = step.ID\n        \n        // Add to workflow\n        if err := wf.AddStep(newStep); err != nil {\n            return err\n        }\n        \n        expandedIDs = append(expandedIDs, newID)\n    }\n    \n    // Track what this step expanded into\n    step.ExpandedInto = expandedIDs\n    \n    // Check total steps limit\n    if len(wf.Steps) \u003e e.limits.MaxTotalSteps {\n        // Rollback: delete the steps we just added\n        for _, id := range expandedIDs {\n            delete(wf.Steps, id)\n        }\n        step.ExpandedInto = nil\n        \n        return \u0026LimitExceededError{\n            Limit: \"max_total_steps\",\n            Value: len(wf.Steps),\n            Max:   e.limits.MaxTotalSteps,\n        }\n    }\n    \n    // Success - mark step done\n    step.Status = types.StepStatusDone\n    \n    return nil\n}\n\nfunc (e *ExpandExecutor) expandStep(\n    tmpl *types.Step,\n    newID string,\n    parentID string,\n    ctx *template.SubstitutionContext,\n) (*types.Step, error) {\n    // Clone the step\n    newStep := \u0026types.Step{\n        ID:       newID,\n        Executor: tmpl.Executor,\n        Status:   types.StepStatusPending,\n    }\n    \n    // Substitute variables in config based on executor type\n    // ... (executor-specific substitution)\n    \n    return newStep, nil\n}\n\nfunc (e *ExpandExecutor) prefixNeeds(needs []string, parentID string, tmplSteps []*types.Step) []string {\n    // Build set of step IDs in template\n    tmplIDs := make(map[string]bool)\n    for _, s := range tmplSteps {\n        tmplIDs[s.ID] = true\n    }\n    \n    result := make([]string, len(needs))\n    for i, need := range needs {\n        if tmplIDs[need] {\n            // Internal dependency - prefix\n            result[i] = parentID + \".\" + need\n        } else {\n            // External dependency - keep as-is\n            result[i] = need\n        }\n    }\n    \n    // Add dependency on parent expand step\n    result = append(result, parentID)\n    \n    return result\n}\n\\`\\`\\`\n\n## Template Resolution\n\n| Reference | Resolution |\n|-----------|------------|\n| \\`.tdd\\` | Same file, workflow named \\`tdd\\` |\n| \\`main\\` | Same file, workflow named \\`main\\` |\n| \\`helpers#tdd\\` | File \\`helpers.meow.toml\\`, workflow \\`tdd\\` |\n| \\`helpers\\` | File \\`helpers.meow.toml\\`, workflow \\`main\\` |\n| \\`./lib/utils#helper\\` | Relative path |\n\n## Step ID Prefixing\n\nExpanded steps get prefixed IDs for uniqueness:\n- Parent step: \\`implement\\`\n- Template steps: \\`load\\`, \\`test\\`, \\`code\\`\n- Expanded IDs: \\`implement.load\\`, \\`implement.test\\`, \\`implement.code\\`\n\nRecursive expansion continues prefixing:\n- \\`implement.continue.find-work\\`\n- \\`implement.continue.continue.find-work\\`\n\n## Acceptance Criteria\n\n- [ ] Template loading via Loader\n- [ ] Variable substitution in expanded steps\n- [ ] Step ID prefixing for uniqueness\n- [ ] Dependency prefixing for internal refs\n- [ ] ExpandedFrom set on child steps\n- [ ] ExpandedInto set on parent step\n- [ ] Expansion depth limit checking\n- [ ] Total steps limit checking with rollback\n- [ ] Unit tests for template resolution\n- [ ] Unit tests for step prefixing\n- [ ] Unit tests for limit enforcement\n- [ ] Integration test with nested expansions","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:35Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.9769778-05:00","closed_at":"2026-01-08T23:55:57.9769778-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"pivot-405","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:35Z","created_by":"claude"},{"issue_id":"pivot-405","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T22:21:45.600436695-05:00","created_by":"ubuntu"}]}
{"id":"pivot-406","title":"Implement branch executor handler","description":"# Implement Branch Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\nBranch evaluation runs in a goroutine because the condition may block.\n\n```go\nfunc (o *Orchestrator) handleBranch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Branch == nil {\n        return fmt.Errorf(\"branch step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    // Save initial state\n    o.store.Save(ctx, wf)\n\n    // Run condition in goroutine (may block)\n    go o.evalBranch(ctx, wf.ID, step.ID)\n\n    return nil\n}\n\nfunc (o *Orchestrator) evalBranch(ctx context.Context, workflowID, stepID string) {\n    // Load fresh workflow state\n    wf, err := o.store.Get(ctx, workflowID)\n    if err != nil {\n        o.logger.Error(\"loading workflow for branch\", \"error\", err)\n        return\n    }\n    step := wf.Steps[stepID]\n\n    // Parse timeout\n    var timeout time.Duration\n    if step.Branch.Timeout != \"\" {\n        timeout, _ = time.ParseDuration(step.Branch.Timeout)\n    }\n\n    // Execute condition\n    execCtx := ctx\n    if timeout \u003e 0 {\n        var cancel context.CancelFunc\n        execCtx, cancel = context.WithTimeout(ctx, timeout)\n        defer cancel()\n    }\n\n    shellCfg := \u0026types.ShellConfig{Command: step.Branch.Condition}\n    outputs, err := o.executor.Execute(execCtx, shellCfg)\n\n    // Determine which branch to take\n    var target *types.BranchTarget\n    if execCtx.Err() == context.DeadlineExceeded {\n        target = step.Branch.OnTimeout\n        if target == nil {\n            target = step.Branch.OnFalse\n        }\n    } else if err != nil {\n        target = step.Branch.OnFalse\n    } else {\n        exitCode, _ := outputs[\"exit_code\"].(int)\n        if exitCode == 0 {\n            target = step.Branch.OnTrue\n        } else {\n            target = step.Branch.OnFalse\n        }\n    }\n\n    // Expand target\n    if target != nil {\n        if err := o.expandBranchTarget(ctx, wf, step, target); err != nil {\n            o.logger.Error(\"expanding branch\", \"step\", stepID, \"error\", err)\n        }\n    }\n\n    // Complete step\n    step.Complete(nil)\n    o.store.Save(ctx, wf)\n}\n```\n\n## Key Behaviors\n\n1. Condition runs in goroutine (non-blocking)\n2. Timeout support with fallback to on_false\n3. Exit code 0 = true, anything else = false\n4. Expand either template or inline steps\n\n## Acceptance Criteria\n\n- [ ] handleBranch implementation\n- [ ] Goroutine execution\n- [ ] Timeout handling\n- [ ] True/false/timeout branching\n- [ ] Template expansion\n- [ ] Inline step expansion\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:36Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.978783086-05:00","closed_at":"2026-01-08T23:55:57.978783086-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"pivot-406","depends_on_id":"pivot-405","type":"blocks","created_at":"2026-01-08T12:00:36Z","created_by":"claude"},{"issue_id":"pivot-406","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T22:21:47.176976117-05:00","created_by":"ubuntu"}]}
{"id":"pivot-407","title":"Implement agent executor handler","description":"# Implement Agent Executor Handler\n\n## File: internal/orchestrator/executors/agent.go\n\n## Purpose\n\nHandle agent steps: inject prompt, wait for meow done, validate outputs. Key responsibilities:\n- Mark step running and inject prompt via tmux\n- Handle meow done IPC with completing status transition\n- Validate outputs against definitions (including file_path scope)\n- Handle autonomous vs interactive mode for stop hook\n\n## Implementation\n\n\\`\\`\\`go\npackage executors\n\nimport (\n    \"context\"\n    \"fmt\"\n    \n    \"github.com/meow-stack/meow-machine/internal/ipc\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\ntype AgentExecutor struct {\n    agents    *AgentManager\n    validator *OutputValidator\n    tmux      *TmuxManager\n}\n\nfunc NewAgentExecutor(agents *AgentManager, validator *OutputValidator, tmux *TmuxManager) *AgentExecutor {\n    return \u0026AgentExecutor{\n        agents:    agents,\n        validator: validator,\n        tmux:      tmux,\n    }\n}\n\n// Start marks step running and injects prompt.\nfunc (e *AgentExecutor) Start(ctx context.Context, step *types.Step, wf *types.Workflow) error {\n    cfg := step.Agent\n    \n    // Mark step running\n    step.Status = types.StepStatusRunning\n    \n    // Update agent's current step\n    e.agents.SetCurrentStep(cfg.Agent, step.ID)\n    \n    // Build prompt with expected outputs\n    prompt := e.buildPrompt(cfg)\n    \n    // Inject prompt via tmux send-keys\n    session := e.agents.GetSession(cfg.Agent)\n    if err := e.tmux.SendKeys(ctx, session, prompt); err != nil {\n        return fmt.Errorf(\"injecting prompt: %w\", err)\n    }\n    \n    return nil\n}\n\nfunc (e *AgentExecutor) buildPrompt(cfg *types.AgentConfig) string {\n    prompt := cfg.Prompt\n    \n    // Add output expectations if defined\n    if len(cfg.Outputs) \u003e 0 {\n        prompt += \"\\n\\n## Expected Outputs\\n\\n\"\n        prompt += \"When complete, run: meow done --output \u003ckey\u003e=\u003cvalue\u003e\\n\\n\"\n        for name, def := range cfg.Outputs {\n            required := \"\"\n            if def.Required {\n                required = \" (required)\"\n            }\n            prompt += fmt.Sprintf(\"- %s (%s)%s\", name, def.Type, required)\n            if def.Description != \"\" {\n                prompt += \": \" + def.Description\n            }\n            prompt += \"\\n\"\n        }\n    } else {\n        prompt += \"\\n\\nWhen complete, run: meow done\"\n    }\n    \n    return prompt\n}\n\n// HandleCompletion processes meow done from agent.\nfunc (e *AgentExecutor) HandleCompletion(\n    ctx context.Context,\n    step *types.Step,\n    wf *types.Workflow,\n    msg *ipc.StepDoneMessage,\n) error {\n    cfg := step.Agent\n    \n    // Transition to completing\n    if err := step.SetCompleting(); err != nil {\n        return err\n    }\n    \n    // Validate outputs if defined\n    if cfg.Outputs != nil {\n        errs := e.validator.ValidateOutputs(msg.Outputs, cfg.Outputs, cfg.Agent)\n        if len(errs) \u003e 0 {\n            // Validation failed - back to running\n            step.Status = types.StepStatusRunning\n            \n            // Return error message to agent\n            return \u0026ValidationFailedError{\n                Errors: errs,\n                Defs:   cfg.Outputs,\n            }\n        }\n    }\n    \n    // Validation passed - complete\n    step.Complete(msg.Outputs)\n    \n    // Mark agent as idle (no current step)\n    e.agents.SetIdle(cfg.Agent)\n    \n    return nil\n}\n\n// GetPromptForHook returns prompt for stop hook query.\nfunc (e *AgentExecutor) GetPromptForHook(step *types.Step) string {\n    cfg := step.Agent\n    \n    // Check step status\n    switch step.Status {\n    case types.StepStatusCompleting:\n        // Transition in progress, stay quiet\n        return \"\"\n        \n    case types.StepStatusRunning:\n        // Check mode\n        if cfg.Mode == types.AgentModeInteractive {\n            // Interactive mode - allow human conversation\n            return \"\"\n        }\n        // Autonomous mode - re-inject prompt as nudge\n        return e.buildPrompt(cfg)\n        \n    default:\n        // Not running/completing - agent is idle\n        return \"\"\n    }\n}\n\\`\\`\\`\n\n## Mode Handling\n\n\\`\\`\\`go\n// AgentMode determines stop hook behavior.\ntype AgentMode string\n\nconst (\n    AgentModeAutonomous  AgentMode = \"autonomous\"  // Default - stop hook re-injects prompt\n    AgentModeInteractive AgentMode = \"interactive\" // Stop hook returns empty, allows conversation\n)\n\\`\\`\\`\n\n**Autonomous mode (default):**\n- Stop hook fires → meow prime → returns current prompt\n- This \"nudges\" Claude to continue working\n- Ralph Wiggum loop ensures persistence\n\n**Interactive mode:**\n- Stop hook fires → meow prime → returns empty\n- Claude waits for human input\n- Enables natural conversation during step execution\n\n## Step Completion Flow\n\n\\`\\`\\`\n1. Agent calls: meow done --output x=y\n2. meow done CLI → IPC → Orchestrator\n3. Orchestrator: step.SetCompleting()\n4. Orchestrator: validate outputs\n   - If invalid: step.Status = running, return error to agent\n   - If valid: step.Complete(outputs)\n5. Orchestrator: send ESC to agent tmux session\n6. Orchestrator: find next step for this agent\n7. If found: inject next prompt\n8. If not found: agent sits idle (stop hook returns empty)\n\\`\\`\\`\n\n## Acceptance Criteria\n\n- [ ] Start() marks step running and injects prompt\n- [ ] buildPrompt() includes output expectations\n- [ ] HandleCompletion() uses completing status\n- [ ] Output validation with file_path scope\n- [ ] Validation failure returns step to running\n- [ ] GetPromptForHook() handles all statuses\n- [ ] Mode handling (autonomous vs interactive)\n- [ ] Agent state updates (current step, idle)\n- [ ] Unit tests for prompt building\n- [ ] Unit tests for completion flow\n- [ ] Unit tests for mode handling\n- [ ] Integration with IPC server","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:37Z","created_by":"claude","updated_at":"2026-01-08T23:55:57.980625152-05:00","closed_at":"2026-01-08T23:55:57.980625152-05:00","close_reason":"Implemented as standalone testable handlers in executor_*.go files","dependencies":[{"issue_id":"pivot-407","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:37Z","created_by":"claude"},{"issue_id":"pivot-407","depends_on_id":"meow-410","type":"blocks","created_at":"2026-01-08T22:21:49.071762935-05:00","created_by":"ubuntu"}]}
{"id":"pivot-408","title":"Implement gate executor handler","description":"# Implement Gate Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleGate(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Gate == nil {\n        return fmt.Errorf(\"gate step %s missing config\", step.ID)\n    }\n\n    // Mark running - human will complete via meow approve/reject\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = \u0026now\n\n    o.logger.Info(\"gate awaiting approval\",\n        \"workflow\", wf.ID,\n        \"step\", step.ID,\n    )\n\n    return nil\n}\n```\n\n## Key Points\n\n1. **External completion** - Human runs `meow approve` or `meow reject`\n2. **No assignee** - Gates are human-facing, not agent-facing\n3. **Timeout handling** - Future enhancement (auto-reject after timeout)\n\n## Completion Flow\n\n```\n1. handleGate marks step running\n2. Human sees gate via meow gates\n3. Human runs meow approve wf-xxx step-id\n4. meow approve finds step, marks done\n5. Next tick, orchestrator sees step is done\n\nOR\n\n3. Human runs meow reject wf-xxx step-id --reason \"...\"\n4. meow reject finds step, marks failed with reason\n5. Workflow may fail depending on error handling\n```\n\n## Acceptance Criteria\n\n- [ ] handleGate implementation\n- [ ] Marks step running\n- [ ] Logs for visibility\n- [ ] Unit tests","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:38Z","created_by":"claude","updated_at":"2026-01-08T22:15:50.196156243-05:00","closed_at":"2026-01-08T22:15:50.196156243-05:00","close_reason":"Gates are NOT a primitive executor in v2 spec. Human approval is implemented via branch executor + 'meow await-approval' command as the condition.","dependencies":[{"issue_id":"pivot-408","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:38Z","created_by":"claude"}]}
{"id":"pivot-409","title":"Implement crash recovery for workflows","description":"# Implement Crash Recovery for Workflows\n\n## File: internal/orchestrator/orchestrator.go\n\n## Recovery Protocol\n\nOn orchestrator startup:\n\n```go\nfunc (o *Orchestrator) Recover(ctx context.Context) error {\n    // Load all running workflows\n    workflows, err := o.store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n    if err != nil {\n        return err\n    }\n\n    for _, wf := range workflows {\n        modified := false\n        \n        // First pass: identify and clean up partial expansions\n        partialExpands := make(map[string]bool)\n        for _, step := range wf.Steps {\n            if step.Executor == types.ExecutorExpand \u0026\u0026 step.Status == types.StepStatusRunning {\n                partialExpands[step.ID] = true\n            }\n        }\n        \n        // Delete any partially-expanded child steps\n        for stepID, step := range wf.Steps {\n            if step.ExpandedFrom != \"\" \u0026\u0026 partialExpands[step.ExpandedFrom] {\n                o.logger.Info(\"deleting partial expansion child\", \"step\", stepID, \"parent\", step.ExpandedFrom)\n                delete(wf.Steps, stepID)\n                modified = true\n            }\n        }\n        \n        // Second pass: handle running/completing steps\n        for _, step := range wf.Steps {\n            if step.Status != types.StepStatusRunning \u0026\u0026 step.Status != types.StepStatusCompleting {\n                continue\n            }\n            \n            // Treat \"completing\" as \"running\" for recovery purposes\n            // (orchestrator crashed during transition)\n            \n            // Handle based on executor type\n            if step.Executor.IsOrchestrator() {\n                // Orchestrator step was mid-execution - reset\n                o.logger.Info(\"resetting orchestrator step\", \"step\", step.ID, \"was_status\", step.Status)\n                step.Status = types.StepStatusPending\n                step.StartedAt = nil\n                modified = true\n            } else if step.Executor == types.ExecutorAgent {\n                // Check if agent is still alive\n                running, _ := o.agents.IsRunning(ctx, step.Agent.Agent)\n                if !running {\n                    // Agent dead - reset to pending (will need respawn)\n                    o.logger.Info(\"resetting step from dead agent\",\n                        \"step\", step.ID,\n                        \"agent\", step.Agent.Agent,\n                    )\n                    step.Status = types.StepStatusPending\n                    step.StartedAt = nil\n                    modified = true\n                } else {\n                    // Agent still alive - keep running\n                    // Don't immediately re-inject prompt!\n                    // Wait for either:\n                    // - Agent to call meow done (normal completion)\n                    // - Stop hook to fire (calls meow prime, gets current prompt)\n                    // This avoids injecting duplicate prompts\n                    if step.Status == types.StepStatusCompleting {\n                        step.Status = types.StepStatusRunning\n                        modified = true\n                    }\n                }\n            }\n            // Gates stay running - human might still approve\n        }\n\n        if modified {\n            o.store.Save(ctx, wf)\n        }\n    }\n\n    return nil\n}\n```\n\n## Recovery Rules\n\n| Executor | Status | Recovery Action |\n|----------|--------|-----------------|\n| shell, spawn, kill, expand, branch | running | Reset to pending |\n| shell, spawn, kill, expand, branch | completing | Reset to pending |\n| expand | running | Delete partial child steps, reset to pending |\n| agent | running (agent alive) | Keep running, wait for stop hook |\n| agent | running (agent dead) | Reset to pending |\n| agent | completing | Set to running, wait for stop hook |\n| gate | running | Keep running (human might approve) |\n\n## Partial Expansion Recovery\n\nIf an \\`expand\\` step was \\`running\\` when orchestrator crashed:\n1. The workflow file may contain partially-inserted child steps\n2. Find all steps with \\`expanded_from: \u003cexpand-step-id\u003e\\`\n3. Delete these partial child steps from the workflow\n4. Reset the expand step to \\`pending\\`\n5. The expand will run cleanly on resume\n\n## Agent Re-injection Strategy\n\nFor agent steps that remain \\`running\\` after recovery (agent still alive):\n- DO NOT immediately re-inject the prompt\n- The agent may still be working\n- Wait for either:\n  - Agent calls \\`meow done\\` (normal completion)\n  - Stop hook fires (calls \\`meow prime\\` which returns current prompt)\n- This avoids injecting duplicate prompts into a working agent\n\n## Acceptance Criteria\n\n- [ ] Recover() method handles all step statuses\n- [ ] Correctly handles \\`completing\\` status (treat as running)\n- [ ] Deletes partially-expanded child steps\n- [ ] Resets orchestrator steps to pending\n- [ ] Checks agent tmux sessions via agents.IsRunning()\n- [ ] Keeps live agents running without re-injection\n- [ ] Preserves gate steps\n- [ ] Unit tests for each recovery scenario\n- [ ] Integration test with simulated crash during expansion","notes":"**UPDATED for v2 spec**: No gate executor to handle. Remove references to ExecutorGate. Branch steps running conditions (including await-approval) can be kept running - the condition process is still alive.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:39Z","created_by":"claude","updated_at":"2026-01-08T22:16:27.018157024-05:00","dependencies":[{"issue_id":"pivot-409","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T22:21:51.067052476-05:00","created_by":"ubuntu"}]}
{"id":"pivot-410","title":"Remove tier-based logic from orchestrator","description":"# Remove Tier-Based Logic from Orchestrator\n\n## Context\n\nThe current orchestrator has tier-aware logic:\n- Priority sorting by tier\n- Wisp burning/cleanup\n- Tier filtering in queries\n\nAll of this should be removed.\n\n## Code to Remove\n\n### internal/orchestrator/orchestrator.go\n\n```go\n// Remove these functions\nfunc (o *Orchestrator) cleanupWorkflow(...)\nfunc (o *Orchestrator) burnWisps(...)\nfunc (o *Orchestrator) squashWisps(...)\nfunc (o *Orchestrator) generateWispDigest(...)\n\n// Remove tier-based priority in GetNextReady\nfunc tierPriority(tier BeadTier) int { ... }\n```\n\n### internal/orchestrator/beadstore.go\n\nThis entire file is removed in pivot-204.\n\n## New Priority Logic\n\nSimpler: orchestrator executors before external.\n\n```go\nsort.Slice(readySteps, func(i, j int) bool {\n    return readySteps[i].Executor.IsOrchestrator() \u0026\u0026 \n           !readySteps[j].Executor.IsOrchestrator()\n})\n```\n\n## Acceptance Criteria\n\n- [ ] No references to BeadTier\n- [ ] No wisp burning code\n- [ ] Simple priority logic\n- [ ] All tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:40Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-410","depends_on_id":"pivot-409","type":"blocks","created_at":"2026-01-08T12:00:40Z","created_by":"claude"}]}
{"id":"pivot-500","title":"EPIC: CLI Alignment","description":"# CLI Alignment\n\n## Overview\n\nThe CLI commands need updates to work with the new workflow model.\n\n## Key Changes\n\n| Old | New | Notes |\n|-----|-----|-------|\n| meow close | meow done | Signals step completion |\n| meow prime (bead-centric) | meow prime (step-centric) | Shows current step |\n| meow approve/reject | Same | Works with workflow/step IDs |\n| meow status | Same | Shows workflow status |\n| meow run | Same | Creates and runs workflow |\n\n## New Behaviors\n\n### meow done\n\n```bash\n# Before (bead-centric)\nmeow close meow-abc.step-1 --output key=value\n\n# After (agent-centric)\nmeow done --output key=value\n# Uses MEOW_AGENT env var to find current step\n```\n\n### meow prime\n\n```bash\n# Returns prompt for current step only\n# No tier filtering - just finds running agent step\n# Returns empty for interactive mode or no work\n```\n\n### meow approve/reject\n\n```bash\nmeow approve wf-abc123 gate-step-id\nmeow reject wf-abc123 gate-step-id --reason \"...\"\n```\n\n## Files Affected\n\n- cmd/meow/cmd/done.go (rename from close.go)\n- cmd/meow/cmd/prime.go\n- cmd/meow/cmd/approve.go\n- cmd/meow/cmd/reject.go\n- cmd/meow/cmd/run.go\n- cmd/meow/cmd/status.go","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:50Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-500","depends_on_id":"pivot-400","type":"blocks","created_at":"2026-01-08T12:00:50Z","created_by":"claude"}]}
{"id":"pivot-501","title":"Implement meow done command","description":"# Implement meow done Command\n\n## File: cmd/meow/cmd/done.go (rename from close.go)\n\n## Usage\n\n```bash\n# Simple completion\nmeow done\n\n# With outputs\nmeow done --output key=value --output other=value2\n\n# With JSON outputs\nmeow done --output-json '{\"key\": \"value\"}'\n\n# With notes\nmeow done --notes \"Completed successfully\"\n```\n\n## Implementation\n\n```go\nvar doneCmd = \u0026cobra.Command{\n    Use:   \"done\",\n    Short: \"Signal step completion\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        // Get agent ID from environment\n        agentID := os.Getenv(\"MEOW_AGENT\")\n        if agentID == \"\" {\n            return fmt.Errorf(\"MEOW_AGENT not set - are you running in a MEOW session?\")\n        }\n\n        // Find workflow with running step for this agent\n        store := getWorkflowStore()\n        workflows, _ := store.GetByAgent(ctx, agentID)\n\n        var targetWf *types.Workflow\n        var targetStep *types.Step\n        for _, wf := range workflows {\n            for _, step := range wf.Steps {\n                if step.Executor == types.ExecutorAgent \u0026\u0026\n                   step.Status == types.StepStatusRunning \u0026\u0026\n                   step.Agent.Agent == agentID {\n                    targetWf = wf\n                    targetStep = step\n                    break\n                }\n            }\n        }\n\n        if targetStep == nil {\n            return fmt.Errorf(\"no running step found for agent %s\", agentID)\n        }\n\n        // Parse outputs\n        outputs := parseOutputs(outputFlags, outputJSON)\n\n        // Validate outputs against step definition\n        if err := validateOutputs(targetStep.Agent.Outputs, outputs); err != nil {\n            return err\n        }\n\n        // Complete step\n        targetStep.Complete(outputs)\n        return store.Save(ctx, targetWf)\n    },\n}\n```\n\n## Output Validation\n\n```go\nfunc validateOutputs(defs map[string]types.OutputDef, outputs map[string]any) error {\n    for name, def := range defs {\n        val, ok := outputs[name]\n        if !ok \u0026\u0026 def.Required {\n            return fmt.Errorf(\"missing required output: %s\", name)\n        }\n        if ok {\n            if err := validateType(val, def.Type); err != nil {\n                return fmt.Errorf(\"output %s: %w\", name, err)\n            }\n        }\n    }\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Rename close.go to done.go\n- [ ] Uses MEOW_AGENT env var\n- [ ] Finds running step for agent\n- [ ] Parses --output and --output-json\n- [ ] Validates required outputs\n- [ ] Completes step\n- [ ] Clear error messages\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:51Z","created_by":"claude","updated_at":"2026-01-09T02:21:16.750805102-05:00","closed_at":"2026-01-09T02:21:16.750805102-05:00","close_reason":"Implemented in agent orchestration work","dependencies":[{"issue_id":"pivot-501","depends_on_id":"pivot-407","type":"blocks","created_at":"2026-01-08T12:00:51Z","created_by":"claude"},{"issue_id":"pivot-501","depends_on_id":"meow-410","type":"blocks","created_at":"2026-01-08T22:21:55.307861119-05:00","created_by":"ubuntu"}]}
{"id":"pivot-502","title":"Update meow prime for workflow model","description":"# Update meow prime for Workflow Model\n\n## File: cmd/meow/cmd/prime.go\n\n## Usage\n\n```bash\n# Default - uses MEOW_AGENT env var\nmeow prime\n\n# Explicit agent\nmeow prime --agent claude-1\n\n# For stop-hook injection\nmeow prime --format prompt\n\n# Machine-readable\nmeow prime --format json\n```\n\n## Output Format (Human)\n\n```markdown\n## Write Tests\n\nWrite failing tests that define the expected behavior for PROJ-123.\n\n### Required Outputs\n- `test_file` (string): Path to the test file\n\n### When Done\nmeow done --output test_file=\u003cpath\u003e\n```\n\n## Implementation\n\n```go\nfunc runPrime(cmd *cobra.Command, args []string) error {\n    agentID := agentFlag\n    if agentID == \"\" {\n        agentID = os.Getenv(\"MEOW_AGENT\")\n    }\n    if agentID == \"\" {\n        return fmt.Errorf(\"agent not specified and MEOW_AGENT not set\")\n    }\n\n    store := getWorkflowStore()\n    workflows, _ := store.GetByAgent(ctx, agentID)\n\n    // Find running agent step for this agent\n    var step *types.Step\n    for _, wf := range workflows {\n        for _, s := range wf.Steps {\n            if s.Executor == types.ExecutorAgent \u0026\u0026\n               s.Status == types.StepStatusRunning \u0026\u0026\n               s.Agent.Agent == agentID {\n                step = s\n                break\n            }\n        }\n    }\n\n    if step == nil {\n        // No work - return empty for stop-hook\n        if format == \"prompt\" {\n            return nil\n        }\n        fmt.Println(\"No work assigned\")\n        return nil\n    }\n\n    // Check interactive mode\n    if step.Agent.Mode == types.AgentModeInteractive {\n        // Interactive mode - return empty to break auto-loop\n        if format == \"prompt\" {\n            return nil\n        }\n        fmt.Println(\"Interactive mode - waiting for conversation\")\n        return nil\n    }\n\n    // Format output\n    switch format {\n    case \"prompt\":\n        fmt.Print(formatPrompt(step))\n    case \"json\":\n        json.NewEncoder(os.Stdout).Encode(step)\n    default:\n        fmt.Print(formatHuman(step))\n    }\n\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Uses MEOW_AGENT env var by default\n2. Returns empty for interactive mode (breaks stop-hook loop)\n3. Returns empty if no work (workflow complete)\n4. Shows prompt and expected outputs\n\n## Acceptance Criteria\n\n- [ ] Uses MEOW_AGENT env var\n- [ ] Finds running agent step\n- [ ] Returns empty for interactive mode\n- [ ] Returns empty if no work\n- [ ] Formats prompt with outputs\n- [ ] --format prompt for stop-hook\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:52Z","created_by":"claude","updated_at":"2026-01-09T02:39:54.492779199-05:00","closed_at":"2026-01-09T02:39:54.492779199-05:00","close_reason":"Implemented meow prime for workflow model with IPC support for stop-hook and file-based reading for text/json formats","dependencies":[{"issue_id":"pivot-502","depends_on_id":"pivot-407","type":"blocks","created_at":"2026-01-08T12:00:52Z","created_by":"claude"},{"issue_id":"pivot-502","depends_on_id":"meow-410","type":"blocks","created_at":"2026-01-08T22:21:56.164043752-05:00","created_by":"ubuntu"}]}
{"id":"pivot-503","title":"Update meow run for workflow model","description":"# Update meow run for Workflow Model\n\n## File: cmd/meow/cmd/run.go\n\n## Usage\n\n```bash\n# Run template\nmeow run template.meow.toml\n\n# Run specific workflow in module\nmeow run template.meow.toml#tdd\n\n# With variables\nmeow run template.meow.toml --var agent=claude-1 --var task_id=PROJ-123\n```\n\n## Implementation\n\n```go\nfunc runRun(cmd *cobra.Command, args []string) error {\n    templateRef := args[0]\n\n    // Parse variables\n    vars := parseVarFlags(varFlags)\n\n    // Load template\n    loader := template.NewLoader(searchPaths)\n    _, workflow, err := loader.Load(ctx, templateRef)\n    if err != nil {\n        return fmt.Errorf(\"loading template: %w\", err)\n    }\n\n    // Validate required variables\n    if err := validateVars(workflow.Variables, vars); err != nil {\n        return err\n    }\n\n    // Bake into steps\n    baker := template.NewBaker()\n    steps, err := baker.Bake(ctx, workflow, vars)\n    if err != nil {\n        return fmt.Errorf(\"baking template: %w\", err)\n    }\n\n    // Create workflow\n    wf := types.NewWorkflow(\n        orchestrator.GenerateWorkflowID(),\n        templateRef,\n        vars,\n    )\n    for _, step := range steps {\n        wf.AddStep(step)\n    }\n    wf.Status = types.WorkflowStatusRunning\n\n    // Persist workflow\n    store := getWorkflowStore()\n    if err := store.Create(ctx, wf); err != nil {\n        return fmt.Errorf(\"creating workflow: %w\", err)\n    }\n\n    fmt.Printf(\"Started workflow: %s\\n\", wf.ID)\n    fmt.Printf(\"Steps: %d\\n\", len(wf.Steps))\n\n    // Start orchestrator\n    orch := orchestrator.New(cfg, store, agents, loader, baker, executor, logger)\n    return orch.Run(ctx)\n}\n```\n\n## Key Changes from Old Version\n\n1. Creates Workflow not beads\n2. Uses WorkflowStore\n3. Starts orchestrator loop (was missing!)\n\n## Acceptance Criteria\n\n- [ ] Loads template\n- [ ] Validates variables\n- [ ] Bakes into steps\n- [ ] Creates workflow\n- [ ] Starts orchestrator\n- [ ] Prints workflow ID\n- [ ] Unit tests","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:53Z","created_by":"claude","updated_at":"2026-01-09T02:21:16.759290199-05:00","closed_at":"2026-01-09T02:21:16.759290199-05:00","close_reason":"Implemented in agent orchestration work","dependencies":[{"issue_id":"pivot-503","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:53Z","created_by":"claude"},{"issue_id":"pivot-503","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T12:00:53Z","created_by":"claude"}]}
{"id":"pivot-504","title":"Update meow approve/reject for workflow model","description":"# Update meow approve/reject for Workflow Model\n\n## Files:\n- cmd/meow/cmd/approve.go\n- cmd/meow/cmd/reject.go\n\n## Usage\n\n```bash\nmeow approve wf-abc123 gate-step-id\nmeow approve wf-abc123 gate-step-id --notes \"LGTM\"\n\nmeow reject wf-abc123 gate-step-id --reason \"Missing tests\"\n```\n\n## Implementation (approve)\n\n```go\nvar approveCmd = \u0026cobra.Command{\n    Use:   \"approve \u003cworkflow-id\u003e \u003cstep-id\u003e\",\n    Short: \"Approve a gate step\",\n    Args:  cobra.ExactArgs(2),\n    RunE: func(cmd *cobra.Command, args []string) error {\n        workflowID := args[0]\n        stepID := args[1]\n\n        store := getWorkflowStore()\n        wf, err := store.Get(ctx, workflowID)\n        if err != nil {\n            return fmt.Errorf(\"loading workflow: %w\", err)\n        }\n        if wf == nil {\n            return fmt.Errorf(\"workflow not found: %s\", workflowID)\n        }\n\n        step, ok := wf.Steps[stepID]\n        if !ok {\n            return fmt.Errorf(\"step not found: %s\", stepID)\n        }\n\n        if step.Executor != types.ExecutorGate {\n            return fmt.Errorf(\"step %s is not a gate (executor: %s)\", stepID, step.Executor)\n        }\n\n        if step.Status != types.StepStatusRunning {\n            return fmt.Errorf(\"gate not pending approval (status: %s)\", step.Status)\n        }\n\n        step.Complete(map[string]any{\"approved\": true, \"notes\": notes})\n        if err := store.Save(ctx, wf); err != nil {\n            return fmt.Errorf(\"saving workflow: %w\", err)\n        }\n\n        fmt.Printf(\"Approved: %s\\n\", stepID)\n        return nil\n    },\n}\n```\n\n## Implementation (reject)\n\nSimilar but marks step as failed:\n\n```go\nstep.Fail(\u0026types.StepError{\n    Message: reason,\n})\n```\n\n## Acceptance Criteria\n\n- [ ] approve loads workflow and step\n- [ ] Validates step is a gate\n- [ ] Validates gate is running\n- [ ] Marks step done with approval info\n- [ ] reject marks step failed with reason\n- [ ] Unit tests","notes":"**UPDATED for v2 spec**: Gate is NOT an executor - it's a branch pattern. approve/reject work by signaling to 'meow await-approval' command running in a branch condition. Approval state is tracked in orchestrator's IPC registry.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:54Z","created_by":"claude","updated_at":"2026-01-08T22:16:23.126249149-05:00","dependencies":[{"issue_id":"pivot-504","depends_on_id":"meow-507","type":"blocks","created_at":"2026-01-08T22:22:01.138456159-05:00","created_by":"ubuntu"}]}
{"id":"pivot-505","title":"Update meow status for workflow model","description":"# Update meow status for Workflow Model\n\n## File: cmd/meow/cmd/status.go\n\n## Usage\n\n```bash\n# List all workflows\nmeow status\n\n# Show specific workflow\nmeow status wf-abc123\n\n# Show with steps\nmeow status wf-abc123 --steps\n\n# JSON output\nmeow status --json\n```\n\n## Output Format\n\n```\nWorkflows:\n  wf-abc123  running   work-loop.meow.toml    5/10 steps done\n  wf-def456  done      deploy.meow.toml       12/12 steps done\n\n$ meow status wf-abc123 --steps\nWorkflow: wf-abc123\nTemplate: work-loop.meow.toml\nStatus:   running\nStarted:  2026-01-08 21:00:00\n\nSteps:\n  ✓ select              done      agent      00:02:00\n  ✓ implement           done      expand     00:00:01\n  ✓ implement.load      done      agent      00:03:00\n  → implement.tests     running   agent      00:05:00\n  ○ implement.impl      pending   agent\n  ○ implement.commit    pending   agent\n```\n\n## Implementation\n\nUpdate to use WorkflowStore and show workflow/step structure.\n\n## Acceptance Criteria\n\n- [ ] Lists all workflows\n- [ ] Shows workflow details\n- [ ] Shows steps with --steps flag\n- [ ] JSON output format\n- [ ] No tier/bead references\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:55Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-505","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:55Z","created_by":"claude"}]}
{"id":"pivot-506","title":"Update meow gates command","description":"# Update meow gates Command\n\n## File: cmd/meow/cmd/gates.go (may need to create)\n\n## Usage\n\n```bash\n# List all pending gates\nmeow gates\n\n# Filter by workflow\nmeow gates --workflow wf-abc123\n```\n\n## Output Format\n\n```\nPending Gates:\n\nWorkflow: wf-abc123\nStep:     review-gate\nPrompt:\n  Review the implementation for PROJ-123.\n  Changes: Added auth endpoint\n  Approve if ready to merge.\n\nCommands:\n  meow approve wf-abc123 review-gate\n  meow reject wf-abc123 review-gate --reason \"...\"\n\n---\n\nWorkflow: wf-def456\nStep:     deploy-approval\n...\n```\n\n## Implementation\n\n```go\nfunc runGates(cmd *cobra.Command, args []string) error {\n    store := getWorkflowStore()\n    workflows, _ := store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n\n    var gates []*gateInfo\n    for _, wf := range workflows {\n        if workflowFilter != \"\" \u0026\u0026 wf.ID != workflowFilter {\n            continue\n        }\n        for _, step := range wf.Steps {\n            if step.Executor == types.ExecutorGate \u0026\u0026 step.Status == types.StepStatusRunning {\n                gates = append(gates, \u0026gateInfo{wf, step})\n            }\n        }\n    }\n\n    if len(gates) == 0 {\n        fmt.Println(\"No pending gates\")\n        return nil\n    }\n\n    for _, g := range gates {\n        formatGate(g)\n    }\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Lists pending gates\n- [ ] Shows prompt for each gate\n- [ ] Shows approve/reject commands\n- [ ] Filter by workflow\n- [ ] Unit tests","notes":"**UPDATED for v2 spec**: Gates are branch steps whose condition is 'meow await-approval'. This command should find branch steps with await-approval conditions that are currently running/blocking.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:56Z","created_by":"claude","updated_at":"2026-01-08T22:16:25.860305817-05:00"}
{"id":"pivot-507","title":"Remove bead-specific CLI code","description":"# Remove Bead-Specific CLI Code\n\n## Context\n\nOnce all CLI commands are updated, remove any remaining bead-specific code.\n\n## Files to Clean Up\n\n- Remove references to BeadStore\n- Remove tier filtering in queries\n- Remove HookBead display\n- Remove bead ID parsing\n\n## Specifically\n\n- cmd/meow/cmd/close.go - DELETE (renamed to done.go)\n- Any helper functions for bead queries\n- Any formatting code for bead output\n\n## Acceptance Criteria\n\n- [ ] No BeadStore references in CLI\n- [ ] No tier filtering\n- [ ] close.go removed\n- [ ] All CLI tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:57Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-507","depends_on_id":"pivot-501","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-502","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-503","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-504","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-505","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"}]}
{"id":"pivot-600","title":"EPIC: Documentation \u0026 Cleanup","description":"# Documentation \u0026 Cleanup\n\n## Overview\n\nFinal phase: update all documentation and clean up dead code.\n\n## Documentation Updates\n\n1. **ARCHITECTURE.md** - Complete rewrite\n   - Remove three-tier model\n   - Document 7 executors\n   - Update component diagram\n   - Update interfaces\n\n2. **CLAUDE.md** - Update agent instructions\n   - Remove molecule/wisp references\n   - Simplify to: meow prime, meow done\n   - Update command reference\n\n3. **README.md** - Update getting started\n   - New template format\n   - New CLI commands\n   - New concepts\n\n4. **MVP-SPEC-v2.md** - Already done (the source of this pivot)\n\n5. **IMPLEMENTATION-GUIDE.md** - Already done\n\n## Code Cleanup\n\n1. Delete internal/types/bead.go\n2. Delete internal/orchestrator/beadstore.go\n3. Delete tier-related code\n4. Delete legacy template parser\n5. Clean up unused imports\n\n## Testing Cleanup\n\n1. Update all tests to use new types\n2. Remove bead-based test fixtures\n3. Add workflow-based test fixtures\n4. Ensure full coverage","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:59Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-600","depends_on_id":"pivot-500","type":"blocks","created_at":"2026-01-08T12:00:59Z","created_by":"claude"}]}
{"id":"pivot-601","title":"Rewrite ARCHITECTURE.md","description":"# Rewrite ARCHITECTURE.md\n\n## File: ARCHITECTURE.md\n\n## New Structure\n\n1. **The One Sentence** - MEOW is a workflow execution engine that coordinates AI agents through programmable templates.\n\n2. **Core Concepts**\n   - Templates = Programs (TOML)\n   - Workflows = Running instances (YAML state)\n   - Steps = Instructions\n   - Executors = Who runs each step\n\n3. **The 7 Executors**\n   - Table with orchestrator vs external\n   - Each executor's purpose and config\n\n4. **Data Flow**\n   - Template → Parse → Bake → Workflow → Execute\n   - Step outputs → Variable substitution\n\n5. **Component Diagram**\n   - Updated for new architecture\n   - No BeadStore, no tiers\n\n6. **Key Interfaces**\n   - WorkflowStore\n   - AgentManager\n   - ShellExecutor\n   - TemplateLoader\n   - Baker\n\n7. **File Layout**\n   - Updated directory structure\n\n## What to Remove\n\n- Three-tier model section\n- Bead types table\n- Wisp lifecycle section\n- HookBead concept\n- Beads integration section\n\n## Acceptance Criteria\n\n- [ ] New architecture documented\n- [ ] No tier references\n- [ ] No bead references\n- [ ] Accurate component diagram\n- [ ] Accurate interfaces","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:01:01Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-601","depends_on_id":"pivot-410","type":"blocks","created_at":"2026-01-08T12:01:01Z","created_by":"claude"},{"issue_id":"pivot-601","depends_on_id":"meow-603","type":"blocks","created_at":"2026-01-08T22:22:09.926870703-05:00","created_by":"ubuntu"}]}
{"id":"pivot-602","title":"Update CLAUDE.md for new model","description":"# Update CLAUDE.md for New Model\n\n## File: CLAUDE.md\n\n## Key Changes\n\n### Remove\n- References to molecules\n- References to wisps\n- References to tiers\n- `bd mol stack`, `bd mol current` commands\n- HookBead concept\n\n### Update\n- \"At Session Start\" - Use `meow prime` to see current work\n- \"During Execution\" - Run `meow done` when complete\n- \"Commands Reference\" - Update for new CLI\n\n### New Content\n\n```markdown\n## Execution Protocol\n\n### At Session Start\n\n1. **Check for work**:\n   ```bash\n   meow prime\n   ```\n   This shows your current step with instructions.\n\n2. **Read the instructions** and execute them.\n\n### During Execution\n\n1. Follow the step instructions\n2. When done, signal completion:\n   ```bash\n   meow done --output key=value\n   ```\n\n### Environment Variables\n\nMEOW sets these when spawning agents:\n- `MEOW_AGENT` - Your agent identifier\n- `MEOW_WORKFLOW` - Current workflow ID (for debugging)\n\n### Commands\n\n| Command | Purpose |\n|---------|--------|\n| `meow prime` | See current work |\n| `meow done` | Signal completion |\n| `meow done --output k=v` | Complete with outputs |\n```\n\n## Acceptance Criteria\n\n- [ ] No molecule references\n- [ ] No wisp references\n- [ ] No tier references\n- [ ] Updated command reference\n- [ ] Accurate execution protocol","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:01:02Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-602","depends_on_id":"pivot-501","type":"blocks","created_at":"2026-01-08T12:01:02Z","created_by":"claude"},{"issue_id":"pivot-602","depends_on_id":"pivot-601","type":"blocks","created_at":"2026-01-08T22:22:11.104551474-05:00","created_by":"ubuntu"}]}
{"id":"pivot-603","title":"Delete dead code","description":"# Delete Dead Code\n\n## Files to Delete\n\n### internal/types/\n- bead.go - Entire file (after verification)\n\n### internal/orchestrator/\n- beadstore.go - Entire file\n\n### internal/template/\n- parser.go - If only legacy parsing (check first)\n\n### cmd/meow/cmd/\n- close.go - Replaced by done.go\n\n## Code to Remove from Files\n\n### internal/orchestrator/orchestrator.go\n- `cleanupWorkflow()`\n- `burnWisps()`\n- `squashWisps()`\n- `generateWispDigest()`\n- `cleanupEphemeralBeads()`\n- Any tier-related helper functions\n\n### internal/template/baker.go\n- `determineTier()`\n- HookBead assignment code\n- Any tier/wisp logic\n\n### internal/template/module.go\n- `Ephemeral` field handling\n- `HooksTo` field handling\n\n## Verification Process\n\n1. Run full test suite\n2. Grep for removed identifiers\n3. Check for unused imports\n4. Run `go build` to verify no references\n\n## Acceptance Criteria\n\n- [ ] All dead code deleted\n- [ ] No dangling references\n- [ ] Tests still pass\n- [ ] Clean build","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:01:03Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-603","depends_on_id":"pivot-106","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"},{"issue_id":"pivot-603","depends_on_id":"pivot-204","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"},{"issue_id":"pivot-603","depends_on_id":"pivot-507","type":"blocks","created_at":"2026-01-08T12:01:03Z","created_by":"claude"}]}
{"id":"pivot-604","title":"Update and run full test suite","description":"# Update and Run Full Test Suite\n\n## Overview\n\nEnsure all tests pass with the new architecture.\n\n## Test Categories\n\n### Unit Tests\n- internal/types/*_test.go - New type tests\n- internal/orchestrator/*_test.go - Updated orchestrator tests\n- internal/template/*_test.go - Updated template tests\n\n### Integration Tests\n- End-to-end workflow execution\n- All 7 executor types\n- Crash recovery\n- Multi-agent coordination\n\n### Test Fixtures\n\nUpdate testdata/ with new format templates:\n```\ntestdata/\n├── templates/\n│   ├── simple-agent.meow.toml\n│   ├── sequential.meow.toml\n│   ├── branching.meow.toml\n│   ├── looping.meow.toml\n│   └── multi-agent.meow.toml\n└── workflows/\n    └── fixtures/\n        ├── running-workflow.yaml\n        └── completed-workflow.yaml\n```\n\n## Commands\n\n```bash\n# Run all tests\ngo test ./...\n\n# Run with coverage\ngo test -coverprofile=coverage.out ./...\ngo tool cover -html=coverage.out\n\n# Run integration tests\ngo test -tags=integration ./...\n```\n\n## Acceptance Criteria\n\n- [ ] All unit tests pass\n- [ ] All integration tests pass\n- [ ] Coverage \u003e= 70%\n- [ ] No test uses old bead types\n- [ ] Test fixtures use new format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:01:04Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-604","depends_on_id":"pivot-603","type":"blocks","created_at":"2026-01-08T12:01:04Z","created_by":"claude"},{"issue_id":"pivot-604","depends_on_id":"meow-603","type":"blocks","created_at":"2026-01-08T22:22:12.745590991-05:00","created_by":"ubuntu"}]}
{"id":"pivot-605","title":"End-to-end validation","description":"# End-to-End Validation\n\n## Purpose\n\nValidate the entire pivot works end-to-end before declaring complete.\n\n## Test Scenarios\n\n### 1. Simple Agent Workflow\n\n```bash\n# Create test template\ncat \u003e /tmp/test.meow.toml \u003c\u003c 'EOF'\n[main]\nname = \"simple-test\"\n\n[[main.steps]]\nid = \"greet\"\nexecutor = \"agent\"\nagent = \"test-agent\"\nprompt = \"Say hello and report the greeting\"\n\n[main.steps.outputs]\ngreeting = { required = true, type = \"string\" }\nEOF\n\n# Run workflow\nmeow run /tmp/test.meow.toml --var agent=test-agent\n\n# In another terminal, as agent:\nexport MEOW_AGENT=test-agent\nmeow prime  # Should show prompt\nmeow done --output greeting=\"Hello, World!\"\n```\n\n### 2. Branching Workflow\n\nTest branch executor with true/false paths.\n\n### 3. Looping Workflow\n\nTest recursive template expansion.\n\n### 4. Human Gate\n\nTest meow approve/reject flow.\n\n### 5. Crash Recovery\n\nKill orchestrator mid-workflow, restart, verify continuation.\n\n## Success Criteria\n\n- [ ] All 5 scenarios pass\n- [ ] No errors in logs\n- [ ] State persists correctly\n- [ ] Agents receive correct prompts\n- [ ] Outputs captured correctly\n\n## Declare Pivot Complete\n\nOnce all scenarios pass, the pivot is complete!","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:01:05Z","created_by":"claude","updated_at":"2026-01-08T20:24:44.591249753-05:00","dependencies":[{"issue_id":"pivot-605","depends_on_id":"pivot-604","type":"blocks","created_at":"2026-01-08T12:01:05Z","created_by":"claude"}]}
