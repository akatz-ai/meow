{"id":"pivot-000","title":"EPIC: MVP-SPEC-v2 Pivot - Workflow-Centric Architecture","description":"# The Big Pivot: Bead-Centric → Workflow-Centric\n\n## Background\n\nMEOW Stack started as a bead-aware orchestrator with three tiers (work/wisp/orchestrator). This created:\n- Tight coupling to beads task tracker\n- Conceptual confusion (are we a task tracker or workflow engine?)\n- Complex visibility model agents had to understand\n\n## The New Vision (MVP-SPEC-v2)\n\nMEOW is a **coordination language** for AI agents. Key shifts:\n\n1. **Task-tracking agnostic** - Users bring their own systems (beads, Jira, GitHub, sticky notes)\n2. **Single primitive** - Step with 7 executors (not 8 bead types)\n3. **No tiers** - Workflows are opaque to agents; they see prompts, not internals\n4. **Workflow state files** - YAML per-workflow, not JSONL bead store\n5. **meow done** - Signals step completion (not bead close)\n\n## Scope of This Pivot\n\n- Remove all bead integration code\n- Remove three-tier model (work/wisp/orchestrator)\n- Implement new Step/Workflow types\n- Switch persistence from JSONL to YAML\n- Update CLI commands\n- Update documentation\n\n## Key Documents\n\n- docs/MVP-SPEC-v2.md - The new specification\n- docs/IMPLEMENTATION-GUIDE.md - Detailed implementation guidance\n\n## Success Criteria\n\n- `meow run template.toml` starts a workflow stored in .meow/workflows/*.yaml\n- `meow prime` shows current step prompt to agents\n- `meow done` signals step completion with output validation\n- Workflows execute through all 7 executor types\n- No references to beads/tiers remain in core code","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:00Z","created_by":"claude"}
{"id":"pivot-100","title":"EPIC: Type System Refactor","description":"# Type System Refactor\n\n## Why This Comes First\n\nThe type system is the foundation. Every other component depends on Step, Workflow, and ExecutorType definitions. Getting this right enables parallel work on other epics.\n\n## What Changes\n\n### Remove (from internal/types/bead.go)\n- BeadType enum (8 types)\n- BeadTier enum (work/wisp/orchestrator)\n- HookBead, SourceWorkflow fields\n- All type-specific specs (ConditionSpec, etc.)\n- Bead struct entirely (after migration)\n\n### Add (new files)\n- internal/types/executor.go - ExecutorType enum (7 values)\n- internal/types/step.go - Step struct with executor configs\n- internal/types/workflow.go - Workflow struct with state\n\n## The 7 Executors\n\n| Executor | Category | Purpose |\n|----------|----------|--------|\n| shell | Orchestrator | Run shell command, capture outputs |\n| spawn | Orchestrator | Start agent in tmux session |\n| kill | Orchestrator | Stop agent's tmux session |\n| expand | Orchestrator | Inline another workflow's steps |\n| branch | Orchestrator | Conditional execution (was 'condition') |\n| agent | External | Assign work to agent, wait for meow done |\n| gate | External | Human approval, wait for meow approve |\n\n## Key Design Decisions\n\n1. **Executor configs as embedded structs** - Each step has optional config for its executor type (ShellConfig, SpawnConfig, etc.). Only one is populated.\n\n2. **Status on Step, not separate** - Step.Status tracks lifecycle (pending/running/done/failed).\n\n3. **Outputs stored on Step** - When step completes, outputs captured directly on step.\n\n4. **No Tier field** - Visibility is implicit. Agents see their prompts, period.\n\n## Mapping from Old to New\n\n| Old BeadType | New Executor | Notes |\n|--------------|--------------|-------|\n| task | agent | mode: autonomous |\n| collaborative | agent | mode: interactive |\n| gate | gate | Same concept |\n| condition | branch | Renamed for clarity |\n| code | shell | Renamed for clarity |\n| start | spawn | Renamed for clarity |\n| stop | kill | Renamed for clarity |\n| expand | expand | Same |","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:01Z","created_by":"claude","dependencies":[{"issue_id":"pivot-100","depends_on_id":"pivot-000","type":"blocks","created_at":"2026-01-08T12:00:01Z","created_by":"claude"}]}
{"id":"pivot-101","title":"Define ExecutorType enum","description":"# Define ExecutorType Enum\n\n## File: internal/types/executor.go\n\n## Implementation\n\n```go\npackage types\n\n// ExecutorType determines who runs a step and how.\ntype ExecutorType string\n\nconst (\n    // Orchestrator executors - run internally, complete synchronously\n    ExecutorShell  ExecutorType = \"shell\"  // Run shell command\n    ExecutorSpawn  ExecutorType = \"spawn\"  // Start agent in tmux\n    ExecutorKill   ExecutorType = \"kill\"   // Stop agent's tmux session\n    ExecutorExpand ExecutorType = \"expand\" // Inline another workflow\n    ExecutorBranch ExecutorType = \"branch\" // Conditional execution\n\n    // External executors - wait for external completion signal\n    ExecutorAgent ExecutorType = \"agent\" // Agent does work, signals meow done\n    ExecutorGate  ExecutorType = \"gate\"  // Human approval via meow approve\n)\n\n// IsOrchestrator returns true if this executor runs internally.\nfunc (e ExecutorType) IsOrchestrator() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch:\n        return true\n    }\n    return false\n}\n\n// IsExternal returns true if this executor waits for external signal.\nfunc (e ExecutorType) IsExternal() bool {\n    return e == ExecutorAgent || e == ExecutorGate\n}\n\n// Valid returns true if this is a recognized executor type.\nfunc (e ExecutorType) Valid() bool {\n    switch e {\n    case ExecutorShell, ExecutorSpawn, ExecutorKill, ExecutorExpand, ExecutorBranch, ExecutorAgent, ExecutorGate:\n        return true\n    }\n    return false\n}\n```\n\n## Rationale\n\n- **shell** not \"code\" - More intuitive, matches spec language\n- **spawn/kill** not \"start/stop\" - Clearer about what's happening (process lifecycle)\n- **branch** not \"condition\" - Describes what it does (branching), not what it evaluates\n- **agent** not \"task\" - Describes who runs it, consistent with other executors\n\n## Acceptance Criteria\n\n- [ ] ExecutorType enum with 7 values\n- [ ] IsOrchestrator() helper\n- [ ] IsExternal() helper\n- [ ] Valid() validation\n- [ ] Unit tests for all methods","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:02Z","created_by":"claude","dependencies":[{"issue_id":"pivot-101","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:02Z","created_by":"claude"}]}
{"id":"pivot-102","title":"Define StepStatus enum","description":"# Define StepStatus Enum\n\n## File: internal/types/step.go (or executor.go)\n\n## Implementation\n\n```go\n// StepStatus represents the lifecycle state of a step.\ntype StepStatus string\n\nconst (\n    StepStatusPending StepStatus = \"pending\" // Waiting for dependencies\n    StepStatusRunning StepStatus = \"running\" // Currently executing\n    StepStatusDone    StepStatus = \"done\"    // Completed successfully\n    StepStatusFailed  StepStatus = \"failed\"  // Execution failed\n)\n\n// Valid returns true if this is a recognized status.\nfunc (s StepStatus) Valid() bool {\n    switch s {\n    case StepStatusPending, StepStatusRunning, StepStatusDone, StepStatusFailed:\n        return true\n    }\n    return false\n}\n\n// IsTerminal returns true if this status is final (done or failed).\nfunc (s StepStatus) IsTerminal() bool {\n    return s == StepStatusDone || s == StepStatusFailed\n}\n\n// CanTransitionTo returns true if transitioning from s to target is valid.\nfunc (s StepStatus) CanTransitionTo(target StepStatus) bool {\n    switch s {\n    case StepStatusPending:\n        return target == StepStatusRunning\n    case StepStatusRunning:\n        return target == StepStatusDone || target == StepStatusFailed || target == StepStatusPending // Reset on crash\n    case StepStatusDone, StepStatusFailed:\n        return false // Terminal states\n    }\n    return false\n}\n```\n\n## Design Notes\n\n- **No 'hooked' status** - Previous design had intermediate states. Now: pending → running → done/failed.\n- **Reset allowed** - Running can go back to pending for crash recovery.\n- **Terminal states** - Once done/failed, no further transitions.\n\n## Acceptance Criteria\n\n- [ ] StepStatus enum with 4 values\n- [ ] Valid() validation\n- [ ] IsTerminal() helper\n- [ ] CanTransitionTo() state machine\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:03Z","created_by":"claude","dependencies":[{"issue_id":"pivot-102","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:03Z","created_by":"claude"}]}
{"id":"pivot-103","title":"Define executor config structs","description":"# Define Executor Config Structs\n\n## File: internal/types/step.go\n\n## Implementation\n\nEach executor has its own config struct. Only one is populated per step.\n\n```go\n// ShellConfig for executor: shell\ntype ShellConfig struct {\n    Command string            `yaml:\"command\" toml:\"command\"`\n    Workdir string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env     map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    OnError string            `yaml:\"on_error,omitempty\" toml:\"on_error,omitempty\"` // continue | fail\n}\n\n// SpawnConfig for executor: spawn\ntype SpawnConfig struct {\n    Agent         string            `yaml:\"agent\" toml:\"agent\"`\n    Workdir       string            `yaml:\"workdir,omitempty\" toml:\"workdir,omitempty\"`\n    Env           map[string]string `yaml:\"env,omitempty\" toml:\"env,omitempty\"`\n    Prompt        string            `yaml:\"prompt,omitempty\" toml:\"prompt,omitempty\"` // Default: \"meow prime\"\n    ResumeSession string            `yaml:\"resume_session,omitempty\" toml:\"resume_session,omitempty\"`\n}\n\n// KillConfig for executor: kill\ntype KillConfig struct {\n    Agent    string `yaml:\"agent\" toml:\"agent\"`\n    Graceful bool   `yaml:\"graceful,omitempty\" toml:\"graceful,omitempty\"` // Default: true\n    Timeout  int    `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"`   // Seconds, default: 10\n}\n\n// ExpandConfig for executor: expand\ntype ExpandConfig struct {\n    Template  string            `yaml:\"template\" toml:\"template\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n}\n\n// BranchTarget defines what to expand for a branch outcome.\ntype BranchTarget struct {\n    Template  string            `yaml:\"template,omitempty\" toml:\"template,omitempty\"`\n    Variables map[string]string `yaml:\"variables,omitempty\" toml:\"variables,omitempty\"`\n    Inline    []*InlineStep     `yaml:\"inline,omitempty\" toml:\"inline,omitempty\"`\n}\n\n// BranchConfig for executor: branch\ntype BranchConfig struct {\n    Condition string        `yaml:\"condition\" toml:\"condition\"` // Shell command, exit 0 = true\n    OnTrue    *BranchTarget `yaml:\"on_true,omitempty\" toml:\"on_true,omitempty\"`\n    OnFalse   *BranchTarget `yaml:\"on_false,omitempty\" toml:\"on_false,omitempty\"`\n    OnTimeout *BranchTarget `yaml:\"on_timeout,omitempty\" toml:\"on_timeout,omitempty\"`\n    Timeout   string        `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"` // Duration string\n}\n\n// AgentMode determines auto-continuation behavior.\ntype AgentMode string\n\nconst (\n    AgentModeAutonomous  AgentMode = \"autonomous\"  // Stop-hook continues\n    AgentModeInteractive AgentMode = \"interactive\" // Pauses for conversation\n)\n\n// OutputDef defines an expected output from an agent step.\ntype OutputDef struct {\n    Required    bool   `yaml:\"required\" toml:\"required\"`\n    Type        string `yaml:\"type\" toml:\"type\"` // string, number, boolean, json, file_path\n    Description string `yaml:\"description,omitempty\" toml:\"description,omitempty\"`\n}\n\n// AgentConfig for executor: agent\ntype AgentConfig struct {\n    Agent   string               `yaml:\"agent\" toml:\"agent\"`\n    Prompt  string               `yaml:\"prompt\" toml:\"prompt\"`\n    Mode    AgentMode            `yaml:\"mode,omitempty\" toml:\"mode,omitempty\"` // Default: autonomous\n    Outputs map[string]OutputDef `yaml:\"outputs,omitempty\" toml:\"outputs,omitempty\"`\n}\n\n// GateConfig for executor: gate\ntype GateConfig struct {\n    Prompt  string `yaml:\"prompt\" toml:\"prompt\"`\n    Timeout string `yaml:\"timeout,omitempty\" toml:\"timeout,omitempty\"`\n}\n```\n\n## Design Notes\n\n- **Both YAML and TOML tags** - Config structs are used for both template parsing (TOML) and state persistence (YAML).\n- **AgentMode enum** - Replaces separate 'collaborative' type with a mode field.\n- **OutputDef simplified** - Type is string, validation happens at runtime.\n\n## Acceptance Criteria\n\n- [ ] All 7 executor config structs defined\n- [ ] AgentMode enum (autonomous/interactive)\n- [ ] OutputDef for agent outputs\n- [ ] BranchTarget for conditional expansion\n- [ ] Unit tests for serialization","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:04Z","created_by":"claude","dependencies":[{"issue_id":"pivot-103","depends_on_id":"pivot-101","type":"blocks","created_at":"2026-01-08T12:00:04Z","created_by":"claude"}]}
{"id":"pivot-104","title":"Define Step struct","description":"# Define Step Struct\n\n## File: internal/types/step.go\n\n## Implementation\n\n```go\n// Step is the single primitive in MEOW. Everything is a step.\ntype Step struct {\n    // Identity\n    ID       string       `yaml:\"id\"`\n    Executor ExecutorType `yaml:\"executor\"`\n\n    // Lifecycle\n    Status    StepStatus `yaml:\"status\"`\n    StartedAt *time.Time `yaml:\"started_at,omitempty\"`\n    DoneAt    *time.Time `yaml:\"done_at,omitempty\"`\n\n    // Dependencies\n    Needs []string `yaml:\"needs,omitempty\"`\n\n    // Data\n    Outputs map[string]any `yaml:\"outputs,omitempty\"`\n    Error   *StepError     `yaml:\"error,omitempty\"`\n\n    // Executor-specific config (exactly one populated based on Executor)\n    Shell  *ShellConfig  `yaml:\"shell,omitempty\"`\n    Spawn  *SpawnConfig  `yaml:\"spawn,omitempty\"`\n    Kill   *KillConfig   `yaml:\"kill,omitempty\"`\n    Expand *ExpandConfig `yaml:\"expand,omitempty\"`\n    Branch *BranchConfig `yaml:\"branch,omitempty\"`\n    Agent  *AgentConfig  `yaml:\"agent,omitempty\"`\n    Gate   *GateConfig   `yaml:\"gate,omitempty\"`\n}\n\n// StepError captures failure information.\ntype StepError struct {\n    Message string `yaml:\"message\"`\n    Code    int    `yaml:\"code,omitempty\"`    // Exit code for shell\n    Output  string `yaml:\"output,omitempty\"` // stderr or other context\n}\n\n// InlineStep is used for inline step definitions in branch targets.\n// Simplified version of Step for template parsing.\ntype InlineStep struct {\n    ID       string            `yaml:\"id\" toml:\"id\"`\n    Executor ExecutorType      `yaml:\"executor\" toml:\"executor\"`\n    Prompt   string            `yaml:\"prompt,omitempty\" toml:\"prompt,omitempty\"` // For agent steps\n    Agent    string            `yaml:\"agent,omitempty\" toml:\"agent,omitempty\"`\n    Needs    []string          `yaml:\"needs,omitempty\" toml:\"needs,omitempty\"`\n}\n```\n\n## Helper Methods\n\n```go\n// IsReady returns true if all dependencies are done.\nfunc (s *Step) IsReady(steps map[string]*Step) bool {\n    if s.Status != StepStatusPending {\n        return false\n    }\n    for _, depID := range s.Needs {\n        dep, ok := steps[depID]\n        if !ok || dep.Status != StepStatusDone {\n            return false\n        }\n    }\n    return true\n}\n\n// Validate checks the step is well-formed.\nfunc (s *Step) Validate() error {\n    if s.ID == \"\" {\n        return fmt.Errorf(\"step ID is required\")\n    }\n    if !s.Executor.Valid() {\n        return fmt.Errorf(\"invalid executor: %s\", s.Executor)\n    }\n    // Verify exactly one config is set for the executor\n    return s.validateConfig()\n}\n\n// Complete marks the step as done with outputs.\nfunc (s *Step) Complete(outputs map[string]any) error {\n    if !s.Status.CanTransitionTo(StepStatusDone) {\n        return fmt.Errorf(\"cannot complete step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusDone\n    s.DoneAt = &now\n    s.Outputs = outputs\n    return nil\n}\n\n// Fail marks the step as failed with error info.\nfunc (s *Step) Fail(err *StepError) error {\n    if !s.Status.CanTransitionTo(StepStatusFailed) {\n        return fmt.Errorf(\"cannot fail step in status %s\", s.Status)\n    }\n    now := time.Now()\n    s.Status = StepStatusFailed\n    s.DoneAt = &now\n    s.Error = err\n    return nil\n}\n```\n\n## Design Notes\n\n- **Flat config fields** - Each executor config is a direct field on Step, not nested in a generic Config field. This makes YAML output cleaner.\n- **Outputs as map[string]any** - Flexible for different output types. Validation happens at completion time.\n- **No Title field** - Steps are identified by ID. Prompts contain the human-readable description.\n\n## Acceptance Criteria\n\n- [ ] Step struct with all fields\n- [ ] StepError struct\n- [ ] InlineStep for branch targets\n- [ ] IsReady() helper\n- [ ] Validate() method\n- [ ] Complete() and Fail() methods\n- [ ] Unit tests for all methods","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:05Z","created_by":"claude","dependencies":[{"issue_id":"pivot-104","depends_on_id":"pivot-102","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"},{"issue_id":"pivot-104","depends_on_id":"pivot-103","type":"blocks","created_at":"2026-01-08T12:00:05Z","created_by":"claude"}]}
{"id":"pivot-105","title":"Define Workflow struct","description":"# Define Workflow Struct\n\n## File: internal/types/workflow.go\n\n## Implementation\n\n```go\npackage types\n\nimport \"time\"\n\n// WorkflowStatus represents the lifecycle state of a workflow.\ntype WorkflowStatus string\n\nconst (\n    WorkflowStatusPending WorkflowStatus = \"pending\" // Created but not started\n    WorkflowStatusRunning WorkflowStatus = \"running\" // Orchestrator is processing\n    WorkflowStatusDone    WorkflowStatus = \"done\"    // All steps completed\n    WorkflowStatusFailed  WorkflowStatus = \"failed\"  // A step failed\n)\n\n// Workflow represents a running workflow instance.\ntype Workflow struct {\n    // Identity\n    ID       string `yaml:\"id\"`       // Unique identifier (e.g., \"wf-abc123\")\n    Template string `yaml:\"template\"` // Source template path\n\n    // Lifecycle\n    Status    WorkflowStatus `yaml:\"status\"`\n    StartedAt time.Time      `yaml:\"started_at\"`\n    DoneAt    *time.Time     `yaml:\"done_at,omitempty\"`\n\n    // Configuration\n    Variables map[string]string `yaml:\"variables,omitempty\"`\n\n    // State - all steps with their current state\n    Steps map[string]*Step `yaml:\"steps\"`\n}\n\n// NewWorkflow creates a new workflow instance.\nfunc NewWorkflow(id, template string, vars map[string]string) *Workflow {\n    return &Workflow{\n        ID:        id,\n        Template:  template,\n        Status:    WorkflowStatusPending,\n        StartedAt: time.Now(),\n        Variables: vars,\n        Steps:     make(map[string]*Step),\n    }\n}\n\n// AddStep adds a step to the workflow.\nfunc (w *Workflow) AddStep(step *Step) error {\n    if _, exists := w.Steps[step.ID]; exists {\n        return fmt.Errorf(\"step %s already exists\", step.ID)\n    }\n    w.Steps[step.ID] = step\n    return nil\n}\n\n// GetReadySteps returns all steps that are ready to execute.\nfunc (w *Workflow) GetReadySteps() []*Step {\n    var ready []*Step\n    for _, step := range w.Steps {\n        if step.IsReady(w.Steps) {\n            ready = append(ready, step)\n        }\n    }\n    return ready\n}\n\n// AllDone returns true if all steps are in terminal state.\nfunc (w *Workflow) AllDone() bool {\n    for _, step := range w.Steps {\n        if !step.Status.IsTerminal() {\n            return false\n        }\n    }\n    return true\n}\n\n// HasFailed returns true if any step has failed.\nfunc (w *Workflow) HasFailed() bool {\n    for _, step := range w.Steps {\n        if step.Status == StepStatusFailed {\n            return true\n        }\n    }\n    return false\n}\n\n// Complete marks the workflow as done.\nfunc (w *Workflow) Complete() {\n    now := time.Now()\n    w.Status = WorkflowStatusDone\n    w.DoneAt = &now\n}\n\n// Fail marks the workflow as failed.\nfunc (w *Workflow) Fail() {\n    now := time.Now()\n    w.Status = WorkflowStatusFailed\n    w.DoneAt = &now\n}\n\n// GetStep retrieves a step by ID.\nfunc (w *Workflow) GetStep(id string) (*Step, bool) {\n    step, ok := w.Steps[id]\n    return step, ok\n}\n\n// GetStepsForAgent returns steps assigned to the given agent.\nfunc (w *Workflow) GetStepsForAgent(agentID string) []*Step {\n    var result []*Step\n    for _, step := range w.Steps {\n        if step.Executor == ExecutorAgent && step.Agent != nil && step.Agent.Agent == agentID {\n            result = append(result, step)\n        }\n    }\n    return result\n}\n```\n\n## Design Notes\n\n- **Steps as map** - O(1) lookup by ID, which is common during dependency resolution.\n- **Variables stored** - The resolved variables are saved so we can reconstruct context on restart.\n- **No parent/child relationship** - Expanded steps are just more steps in the map with dependency links.\n\n## Acceptance Criteria\n\n- [ ] WorkflowStatus enum\n- [ ] Workflow struct with all fields\n- [ ] NewWorkflow() constructor\n- [ ] AddStep() method\n- [ ] GetReadySteps() helper\n- [ ] AllDone() and HasFailed() helpers\n- [ ] GetStepsForAgent() for agent queries\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:06Z","created_by":"claude","dependencies":[{"issue_id":"pivot-105","depends_on_id":"pivot-104","type":"blocks","created_at":"2026-01-08T12:00:06Z","created_by":"claude"}]}
{"id":"pivot-106","title":"Remove old bead types","description":"# Remove Old Bead Types\n\n## Context\n\nOnce new types are in place and the orchestrator is updated, we can remove the old bead-centric types. This is the cleanup step.\n\n## Files to Modify\n\n### internal/types/bead.go - DELETE ENTIRELY\n\nRemove:\n- BeadType enum\n- BeadTier enum\n- BeadStatus enum (replaced by StepStatus)\n- Bead struct\n- All spec structs (ConditionSpec, StartSpec, etc.)\n- All validation methods\n\n### internal/types/agent.go - KEEP\n\nAgent type is still needed for agent state tracking.\n\n## Migration Strategy\n\n1. First, implement new types alongside old\n2. Update orchestrator to use new types\n3. Update CLI to use new types\n4. Only then delete old types\n\nThis task should be done LAST in the type system epic.\n\n## Acceptance Criteria\n\n- [ ] internal/types/bead.go deleted\n- [ ] No imports of old bead types remain\n- [ ] All tests pass with new types\n- [ ] No references to BeadType, BeadTier, etc.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:07Z","created_by":"claude","dependencies":[{"issue_id":"pivot-106","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"pivot-106","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"},{"issue_id":"pivot-106","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:07Z","created_by":"claude"}]}
{"id":"pivot-200","title":"EPIC: Workflow State Persistence","description":"# Workflow State Persistence\n\n## The Big Change\n\nPreviously: All state in `.beads/issues.jsonl` (JSONL format, shared with bd CLI)\nNow: Per-workflow YAML files in `.meow/workflows/`\n\n## Why YAML?\n\n1. **Human-readable** - Easy to debug, inspect, manually edit if needed\n2. **Per-workflow files** - No giant monolithic file, easy cleanup\n3. **Atomic writes** - Write to temp, rename (no partial states)\n4. **Git-trackable** - Can version control workflow state if desired\n5. **No lock contention** - Each workflow is independent\n\n## Directory Structure\n\n```\n.meow/\n├── config.toml              # User configuration\n├── agents.yaml              # Active agent sessions\n├── orchestrator.lock        # Prevents concurrent instances\n└── workflows/\n    ├── wf-abc123.yaml       # Workflow instance state\n    └── wf-def456.yaml\n```\n\n## Workflow State File Format\n\n```yaml\n# .meow/workflows/wf-abc123.yaml\nid: wf-abc123\ntemplate: work-loop.meow.toml\nstatus: running\nstarted_at: 2026-01-08T21:00:00Z\n\nvariables:\n  agent: claude-1\n\nsteps:\n  select:\n    executor: agent\n    status: done\n    done_at: 2026-01-08T21:02:00Z\n    agent:\n      agent: claude-1\n      prompt: \"Select the next task...\"\n    outputs:\n      task_id: \"PROJ-123\"\n\n  implement:\n    executor: expand\n    status: done\n    expand:\n      template: \".tdd\"\n\n  implement.load-context:\n    executor: agent\n    status: running\n    needs: [\"implement\"]\n    agent:\n      agent: claude-1\n      prompt: \"Load context...\"\n```\n\n## Key Operations\n\n- **Create** - New workflow from template\n- **Load** - Read workflow state from YAML\n- **Save** - Write workflow state to YAML (atomic)\n- **List** - Enumerate all workflow files\n- **Delete** - Remove completed workflow file\n\n## No More Bead Store\n\nThe BeadStore interface is replaced by WorkflowStore. No more:\n- Tier filtering\n- HookBead queries\n- JSONL parsing","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:10Z","created_by":"claude","dependencies":[{"issue_id":"pivot-200","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:10Z","created_by":"claude"}]}
{"id":"pivot-201","title":"Define WorkflowStore interface","description":"# Define WorkflowStore Interface\n\n## File: internal/orchestrator/workflowstore.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// WorkflowStore provides persistence for workflow state.\ntype WorkflowStore interface {\n    // Create persists a new workflow.\n    Create(ctx context.Context, wf *types.Workflow) error\n\n    // Get retrieves a workflow by ID.\n    Get(ctx context.Context, id string) (*types.Workflow, error)\n\n    // Save persists workflow state (atomic write).\n    Save(ctx context.Context, wf *types.Workflow) error\n\n    // Delete removes a workflow.\n    Delete(ctx context.Context, id string) error\n\n    // List returns all workflows matching filter.\n    List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error)\n\n    // GetByAgent returns workflows with steps assigned to agent.\n    GetByAgent(ctx context.Context, agentID string) ([]*types.Workflow, error)\n}\n\n// WorkflowFilter for listing workflows.\ntype WorkflowFilter struct {\n    Status types.WorkflowStatus // Filter by status\n}\n```\n\n## Design Notes\n\n- **Simple interface** - Just CRUD + listing\n- **No tier filtering** - Tiers don't exist in new model\n- **GetByAgent** - Needed for `meow prime` to find agent's work\n- **Atomic Save** - Implementation must be atomic (temp file + rename)\n\n## Acceptance Criteria\n\n- [ ] WorkflowStore interface defined\n- [ ] WorkflowFilter struct\n- [ ] Interface documented","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:11Z","created_by":"claude","dependencies":[{"issue_id":"pivot-201","depends_on_id":"pivot-105","type":"blocks","created_at":"2026-01-08T12:00:11Z","created_by":"claude"}]}
{"id":"pivot-202","title":"Implement YAMLWorkflowStore","description":"# Implement YAMLWorkflowStore\n\n## File: internal/orchestrator/yamlstore.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"gopkg.in/yaml.v3\"\n    \"github.com/meow-stack/meow-machine/internal/types\"\n)\n\n// YAMLWorkflowStore persists workflows as YAML files.\ntype YAMLWorkflowStore struct {\n    dir string // .meow/workflows\n}\n\n// NewYAMLWorkflowStore creates a new store.\nfunc NewYAMLWorkflowStore(dir string) (*YAMLWorkflowStore, error) {\n    if err := os.MkdirAll(dir, 0755); err != nil {\n        return nil, fmt.Errorf(\"creating workflow dir: %w\", err)\n    }\n    return &YAMLWorkflowStore{dir: dir}, nil\n}\n\nfunc (s *YAMLWorkflowStore) path(id string) string {\n    return filepath.Join(s.dir, id+\".yaml\")\n}\n\n// Create persists a new workflow.\nfunc (s *YAMLWorkflowStore) Create(ctx context.Context, wf *types.Workflow) error {\n    path := s.path(wf.ID)\n    if _, err := os.Stat(path); err == nil {\n        return fmt.Errorf(\"workflow %s already exists\", wf.ID)\n    }\n    return s.Save(ctx, wf)\n}\n\n// Get retrieves a workflow by ID.\nfunc (s *YAMLWorkflowStore) Get(ctx context.Context, id string) (*types.Workflow, error) {\n    path := s.path(id)\n    data, err := os.ReadFile(path)\n    if err != nil {\n        if os.IsNotExist(err) {\n            return nil, nil\n        }\n        return nil, fmt.Errorf(\"reading workflow: %w\", err)\n    }\n\n    var wf types.Workflow\n    if err := yaml.Unmarshal(data, &wf); err != nil {\n        return nil, fmt.Errorf(\"parsing workflow: %w\", err)\n    }\n    return &wf, nil\n}\n\n// Save persists workflow state atomically.\nfunc (s *YAMLWorkflowStore) Save(ctx context.Context, wf *types.Workflow) error {\n    data, err := yaml.Marshal(wf)\n    if err != nil {\n        return fmt.Errorf(\"marshaling workflow: %w\", err)\n    }\n\n    path := s.path(wf.ID)\n    tmpPath := path + \".tmp\"\n\n    if err := os.WriteFile(tmpPath, data, 0644); err != nil {\n        return fmt.Errorf(\"writing temp file: %w\", err)\n    }\n\n    if err := os.Rename(tmpPath, path); err != nil {\n        os.Remove(tmpPath) // Cleanup on failure\n        return fmt.Errorf(\"renaming to final: %w\", err)\n    }\n\n    return nil\n}\n\n// Delete removes a workflow.\nfunc (s *YAMLWorkflowStore) Delete(ctx context.Context, id string) error {\n    return os.Remove(s.path(id))\n}\n\n// List returns workflows matching filter.\nfunc (s *YAMLWorkflowStore) List(ctx context.Context, filter WorkflowFilter) ([]*types.Workflow, error) {\n    entries, err := os.ReadDir(s.dir)\n    if err != nil {\n        return nil, fmt.Errorf(\"reading workflow dir: %w\", err)\n    }\n\n    var workflows []*types.Workflow\n    for _, entry := range entries {\n        if entry.IsDir() || !strings.HasSuffix(entry.Name(), \".yaml\") {\n            continue\n        }\n\n        id := strings.TrimSuffix(entry.Name(), \".yaml\")\n        wf, err := s.Get(ctx, id)\n        if err != nil {\n            continue // Skip malformed files\n        }\n\n        if filter.Status != \"\" && wf.Status != filter.Status {\n            continue\n        }\n\n        workflows = append(workflows, wf)\n    }\n\n    return workflows, nil\n}\n\n// GetByAgent returns workflows with steps for agent.\nfunc (s *YAMLWorkflowStore) GetByAgent(ctx context.Context, agentID string) ([]*types.Workflow, error) {\n    all, err := s.List(ctx, WorkflowFilter{})\n    if err != nil {\n        return nil, err\n    }\n\n    var result []*types.Workflow\n    for _, wf := range all {\n        for _, step := range wf.Steps {\n            if step.Agent != nil && step.Agent.Agent == agentID {\n                result = append(result, wf)\n                break\n            }\n        }\n    }\n    return result, nil\n}\n```\n\n## Key Features\n\n- **Atomic writes** - Write to .tmp, then rename\n- **Error handling** - Graceful handling of missing/malformed files\n- **Simple filtering** - By status, by agent\n\n## Acceptance Criteria\n\n- [ ] Create/Get/Save/Delete/List implemented\n- [ ] Atomic writes (temp file + rename)\n- [ ] GetByAgent query\n- [ ] Unit tests with temp directory\n- [ ] Integration test with real files","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:12Z","created_by":"claude","dependencies":[{"issue_id":"pivot-202","depends_on_id":"pivot-201","type":"blocks","created_at":"2026-01-08T12:00:12Z","created_by":"claude"}]}
{"id":"pivot-203","title":"Implement workflow ID generation","description":"# Implement Workflow ID Generation\n\n## File: internal/orchestrator/id.go\n\n## Implementation\n\n```go\npackage orchestrator\n\nimport (\n    \"crypto/rand\"\n    \"encoding/hex\"\n    \"fmt\"\n    \"time\"\n)\n\n// GenerateWorkflowID creates a unique workflow identifier.\n// Format: wf-{timestamp_hex}-{random_hex}\n// Example: wf-1a2b3c4d-e5f6g7h8\nfunc GenerateWorkflowID() string {\n    ts := time.Now().UnixNano()\n    randBytes := make([]byte, 4)\n    rand.Read(randBytes)\n    return fmt.Sprintf(\"wf-%x-%s\", ts, hex.EncodeToString(randBytes))\n}\n\n// GenerateStepID creates a unique step identifier within a workflow.\n// Format: {parent}.{step_id}\n// Example: implement.load-context (from expand step \"implement\")\nfunc GenerateExpandedStepID(parentID, stepID string) string {\n    if parentID == \"\" {\n        return stepID\n    }\n    return parentID + \".\" + stepID\n}\n```\n\n## Design Notes\n\n- **Timestamp prefix** - Makes IDs roughly sortable by creation time\n- **Random suffix** - Prevents collisions for rapid creation\n- **Dot notation for expanded steps** - Makes hierarchy visible in IDs\n\n## Acceptance Criteria\n\n- [ ] GenerateWorkflowID() creates unique IDs\n- [ ] GenerateExpandedStepID() handles parent.child notation\n- [ ] IDs are filesystem-safe (no special chars)\n- [ ] Unit tests verify uniqueness","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:13Z","created_by":"claude","dependencies":[{"issue_id":"pivot-203","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T12:00:13Z","created_by":"claude"}]}
{"id":"pivot-204","title":"Remove BeadStore and bead persistence","description":"# Remove BeadStore and Bead Persistence\n\n## Context\n\nOnce WorkflowStore is implemented and the orchestrator is using it, we can remove all bead persistence code.\n\n## Files to Remove/Modify\n\n### Remove entirely:\n- internal/orchestrator/beadstore.go\n- Any JSONL parsing code for beads\n\n### Modify:\n- internal/orchestrator/orchestrator.go - Remove BeadStore dependency\n- cmd/meow/cmd/*.go - Remove bead-specific queries\n\n## What We're NOT Removing\n\n- `.beads/` directory itself - Users may still use beads for task tracking\n- bd CLI integration - Templates can still prompt agents to use `bd`\n\nWe're just removing MEOW's internal use of beads as its state store.\n\n## Migration Strategy\n\n1. Implement WorkflowStore\n2. Update orchestrator to use WorkflowStore\n3. Update CLI to use WorkflowStore\n4. Remove BeadStore code\n\n## Acceptance Criteria\n\n- [ ] BeadStore interface removed\n- [ ] No JSONL parsing for beads\n- [ ] Orchestrator uses WorkflowStore\n- [ ] All tests pass without bead store","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:14Z","created_by":"claude","dependencies":[{"issue_id":"pivot-204","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:14Z","created_by":"claude"},{"issue_id":"pivot-204","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:14Z","created_by":"claude"}]}
{"id":"pivot-300","title":"EPIC: Template System Alignment","description":"# Template System Alignment\n\n## What's Changing\n\nThe template system is largely correct but needs updates for the new model:\n\n1. **executor field** instead of **type field**\n2. **Remove ephemeral/hooks_to** - No more tier detection\n3. **Remove legacy format** - Clean break, module format only\n4. **Agent mode field** - Replace collaborative type\n\n## Template Format (Before vs After)\n\n### Before (bead-centric)\n```toml\n[main]\nephemeral = true        # ← REMOVE\nhooks_to = \"work_bead\"  # ← REMOVE\n\n[[main.steps]]\nid = \"do-work\"\ntype = \"task\"           # ← CHANGE TO executor\nassignee = \"{{agent}}\"  # ← CHANGE TO agent field in config\ninstructions = \"...\"    # ← CHANGE TO prompt field in config\n```\n\n### After (workflow-centric)\n```toml\n[main]\nname = \"work-loop\"\ndescription = \"...\"\n\n[[main.steps]]\nid = \"do-work\"\nexecutor = \"agent\"      # ← executor, not type\nagent = \"{{agent}}\"\nprompt = \"...\"          # ← prompt, not instructions\nmode = \"autonomous\"     # ← optional, default\n\n[main.steps.outputs]\ntask_id = { required = true, type = \"string\" }\n```\n\n## Parser Changes\n\n- Parse `executor` field instead of `type`\n- Map TOML fields to executor config structs\n- Remove tier detection logic from baker\n- Remove HookBead assignment\n\n## Files Affected\n\n- internal/template/module.go - Parser\n- internal/template/baker.go - Bead→Step creation\n- internal/template/vars.go - Variable substitution (mostly unchanged)\n- internal/template/loader.go - Template loading (mostly unchanged)","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:20Z","created_by":"claude","dependencies":[{"issue_id":"pivot-300","depends_on_id":"pivot-100","type":"blocks","created_at":"2026-01-08T12:00:20Z","created_by":"claude"}]}
{"id":"pivot-301","title":"Update template parser for executor field","description":"# Update Template Parser for Executor Field\n\n## File: internal/template/module.go\n\n## Changes\n\n### Step struct update\n\n```go\n// Before\ntype Step struct {\n    ID           string   `toml:\"id\"`\n    Type         string   `toml:\"type\"`  // ← Remove\n    Instructions string   `toml:\"instructions\"`\n    Assignee     string   `toml:\"assignee\"`\n    // ...\n}\n\n// After\ntype Step struct {\n    ID       string `toml:\"id\"`\n    Executor string `toml:\"executor\"` // ← Add\n\n    // Agent executor fields\n    Agent  string `toml:\"agent,omitempty\"`\n    Prompt string `toml:\"prompt,omitempty\"`\n    Mode   string `toml:\"mode,omitempty\"` // autonomous | interactive\n\n    // Shell executor fields\n    Command string `toml:\"command,omitempty\"`\n    Workdir string `toml:\"workdir,omitempty\"`\n    OnError string `toml:\"on_error,omitempty\"`\n\n    // Spawn executor fields (also uses Agent, Workdir)\n    ResumeSession string `toml:\"resume_session,omitempty\"`\n\n    // Kill executor fields (uses Agent)\n    Graceful *bool `toml:\"graceful,omitempty\"`\n    Timeout  int   `toml:\"timeout,omitempty\"`\n\n    // Expand executor fields\n    Template  string            `toml:\"template,omitempty\"`\n    Variables map[string]string `toml:\"variables,omitempty\"`\n\n    // Branch executor fields\n    Condition string               `toml:\"condition,omitempty\"`\n    OnTrue    *ExpansionTarget     `toml:\"on_true,omitempty\"`\n    OnFalse   *ExpansionTarget     `toml:\"on_false,omitempty\"`\n    OnTimeout *ExpansionTarget     `toml:\"on_timeout,omitempty\"`\n\n    // Gate executor fields (uses Prompt)\n    // Timeout already defined above\n\n    // Shared\n    Needs   []string          `toml:\"needs,omitempty\"`\n    Env     map[string]string `toml:\"env,omitempty\"`\n    Outputs map[string]any    `toml:\"outputs,omitempty\"`\n}\n```\n\n### Validation update\n\nValidate that required fields are present based on executor:\n\n```go\nfunc (s *Step) Validate() error {\n    switch s.Executor {\n    case \"shell\":\n        if s.Command == \"\" {\n            return fmt.Errorf(\"shell executor requires command\")\n        }\n    case \"agent\":\n        if s.Agent == \"\" {\n            return fmt.Errorf(\"agent executor requires agent\")\n        }\n        if s.Prompt == \"\" {\n            return fmt.Errorf(\"agent executor requires prompt\")\n        }\n    // ... etc\n    }\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Step struct uses executor field\n- [ ] All executor-specific fields present\n- [ ] Validation checks required fields per executor\n- [ ] Old 'type' field no longer parsed\n- [ ] Update all test templates\n- [ ] Unit tests for each executor type","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:21Z","created_by":"claude","dependencies":[{"issue_id":"pivot-301","depends_on_id":"pivot-103","type":"blocks","created_at":"2026-01-08T12:00:21Z","created_by":"claude"}]}
{"id":"pivot-302","title":"Remove ephemeral and hooks_to from workflow","description":"# Remove ephemeral and hooks_to from Workflow\n\n## File: internal/template/module.go\n\n## Changes\n\n### Remove from Workflow struct\n\n```go\n// Before\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Ephemeral   bool            `toml:\"ephemeral,omitempty\"`   // ← Remove\n    Internal    bool            `toml:\"internal,omitempty\"`\n    HooksTo     string          `toml:\"hooks_to,omitempty\"`    // ← Remove\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n\n// After\ntype Workflow struct {\n    Name        string          `toml:\"name\"`\n    Description string          `toml:\"description,omitempty\"`\n    Internal    bool            `toml:\"internal,omitempty\"`\n    Variables   map[string]*Var `toml:\"variables,omitempty\"`\n    Steps       []*Step         `toml:\"steps\"`\n}\n```\n\n### Why These Are Removed\n\n**ephemeral**: Was used to mark workflows whose steps become \"wisps\" (agent-visible ephemeral steps). In the new model, there's no tier distinction - all steps are just steps.\n\n**hooks_to**: Was used to link wisp steps to a work bead ID. In the new model, MEOW is task-tracking agnostic - it doesn't know about beads.\n\n## Migration Note\n\nExisting templates with these fields will have them ignored (TOML parsing allows extra fields). We should update example templates to remove them.\n\n## Acceptance Criteria\n\n- [ ] ephemeral field removed from Workflow struct\n- [ ] hooks_to field removed from Workflow struct\n- [ ] Update all example templates\n- [ ] Update tests that used these fields\n- [ ] No runtime errors if old templates have these fields","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:22Z","created_by":"claude","dependencies":[{"issue_id":"pivot-302","depends_on_id":"pivot-300","type":"blocks","created_at":"2026-01-08T12:00:22Z","created_by":"claude"}]}
{"id":"pivot-303","title":"Refactor baker to create Steps instead of Beads","description":"# Refactor Baker to Create Steps Instead of Beads\n\n## File: internal/template/baker.go\n\n## The Big Change\n\nThe baker currently transforms template workflows into Bead objects. It needs to transform them into Step objects instead.\n\n### Before\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Bead, error) {\n    var beads []*types.Bead\n    for _, step := range workflow.Steps {\n        bead := b.workflowStepToBead(step, vars)\n        beads = append(beads, bead)\n    }\n    return beads, nil\n}\n```\n\n### After\n\n```go\nfunc (b *Baker) Bake(ctx context.Context, workflow *Workflow, vars map[string]string) ([]*types.Step, error) {\n    var steps []*types.Step\n    for _, templateStep := range workflow.Steps {\n        step := b.templateStepToStep(templateStep, vars)\n        steps = append(steps, step)\n    }\n    return steps, nil\n}\n\nfunc (b *Baker) templateStepToStep(ts *Step, vars map[string]string) *types.Step {\n    step := &types.Step{\n        ID:       ts.ID,\n        Executor: types.ExecutorType(ts.Executor),\n        Status:   types.StepStatusPending,\n        Needs:    ts.Needs,\n    }\n\n    // Set executor-specific config\n    switch step.Executor {\n    case types.ExecutorShell:\n        step.Shell = &types.ShellConfig{\n            Command: substitute(ts.Command, vars),\n            Workdir: substitute(ts.Workdir, vars),\n            Env:     substituteMap(ts.Env, vars),\n            OnError: ts.OnError,\n        }\n    case types.ExecutorAgent:\n        step.Agent = &types.AgentConfig{\n            Agent:  substitute(ts.Agent, vars),\n            Prompt: substitute(ts.Prompt, vars),\n            Mode:   types.AgentMode(ts.Mode),\n        }\n    // ... other executors\n    }\n\n    return step\n}\n```\n\n## What to Remove\n\n- Tier detection logic (determineTier)\n- HookBead assignment\n- SourceWorkflow assignment\n- All bead-specific field setting\n\n## Acceptance Criteria\n\n- [ ] Baker.Bake() returns []*types.Step\n- [ ] All 7 executor types create correct config\n- [ ] Variable substitution works in all fields\n- [ ] No tier/HookBead logic remains\n- [ ] Unit tests for each executor type","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:23Z","created_by":"claude","dependencies":[{"issue_id":"pivot-303","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"},{"issue_id":"pivot-303","depends_on_id":"pivot-302","type":"blocks","created_at":"2026-01-08T12:00:23Z","created_by":"claude"}]}
{"id":"pivot-304","title":"Remove legacy [meta] format support","description":"# Remove Legacy [meta] Format Support\n\n## Context\n\nThe template system currently supports two formats:\n1. Legacy: `[meta]` section + `[[steps]]` array\n2. Module: `[workflow-name]` sections\n\nPer the clean break decision, we're removing legacy format support.\n\n## Files to Modify\n\n### internal/template/parser.go\n\n- Remove `ParseLegacy()` function\n- Remove format detection logic\n- Remove any `[meta]` parsing code\n\n### internal/template/module.go\n\n- Remove `IsLegacyFormat()` detection\n- Parser should only handle module format\n\n## Error Handling\n\nIf someone tries to use a legacy template:\n```\nError: Legacy template format ([meta] section) is no longer supported.\nPlease convert to module format. See docs/MVP-SPEC-v2.md for format.\n```\n\n## Acceptance Criteria\n\n- [ ] Legacy parser removed\n- [ ] Clear error for legacy templates\n- [ ] All example templates use module format\n- [ ] Tests updated to use module format only","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:24Z","created_by":"claude","dependencies":[{"issue_id":"pivot-304","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:24Z","created_by":"claude"}]}
{"id":"pivot-305","title":"Update example templates for new format","description":"# Update Example Templates for New Format\n\n## Files to Update\n\nAll templates in:\n- cmd/meow/cmd/templates/\n- examples/templates/\n- testdata/templates/\n\n## Changes Required\n\n1. `type` → `executor`\n2. `assignee` → `agent` (in step, for agent executor)\n3. `instructions` → `prompt`\n4. Remove `ephemeral` and `hooks_to`\n5. Add `mode` field for interactive steps (was `collaborative` type)\n\n## Example Conversion\n\n### Before\n```toml\n[main]\nephemeral = true\nhooks_to = \"work_bead\"\n\n[[main.steps]]\nid = \"do-work\"\ntype = \"task\"\nassignee = \"{{agent}}\"\ninstructions = \"Do the work\"\n```\n\n### After\n```toml\n[main]\nname = \"work\"\n\n[[main.steps]]\nid = \"do-work\"\nexecutor = \"agent\"\nagent = \"{{agent}}\"\nprompt = \"Do the work\"\nmode = \"autonomous\"\n```\n\n## Templates to Create\n\nNew canonical examples:\n- simple-agent.meow.toml - Single agent step\n- sequential.meow.toml - A → B → C\n- branching.meow.toml - Conditional flow\n- looping.meow.toml - Recursive expansion\n- multi-agent.meow.toml - Parallel agents\n- human-gate.meow.toml - Human approval flow\n\n## Acceptance Criteria\n\n- [ ] All existing templates converted\n- [ ] New canonical examples created\n- [ ] All templates validate successfully\n- [ ] README updated with new format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:25Z","created_by":"claude","dependencies":[{"issue_id":"pivot-305","depends_on_id":"pivot-301","type":"blocks","created_at":"2026-01-08T12:00:25Z","created_by":"claude"}]}
{"id":"pivot-400","title":"EPIC: Orchestrator Refactor","description":"# Orchestrator Refactor\n\n## Current State\n\nThe orchestrator (`internal/orchestrator/orchestrator.go`) currently:\n- Uses BeadStore for state\n- Dispatches by BeadType (8 types)\n- Has tier-based priority sorting\n- Manages bead lifecycle\n\n## New Model\n\nThe orchestrator will:\n- Use WorkflowStore for state\n- Dispatch by ExecutorType (7 executors)\n- Simple priority: orchestrator executors before external\n- Manage step lifecycle within workflows\n\n## Key Changes\n\n### Main Loop\n\n```go\n// Before\nfor {\n    bead, _ := store.GetNextReady(ctx)\n    if bead == nil {\n        if store.AllDone(ctx) { break }\n        continue\n    }\n    dispatch(bead)\n}\n\n// After\nfor {\n    // Process all active workflows\n    for _, wf := range store.List(ctx, WorkflowFilter{Status: Running}) {\n        step := getNextReadyStep(wf)\n        if step == nil {\n            if wf.AllDone() {\n                wf.Complete()\n                store.Save(ctx, wf)\n            }\n            continue\n        }\n        dispatch(ctx, wf, step)\n        store.Save(ctx, wf)  // Persist after each step\n    }\n}\n```\n\n### Dispatch\n\n```go\n// Before\nswitch bead.Type {\ncase BeadTypeTask: handleTask(bead)\ncase BeadTypeCode: handleCode(bead)\n// ... 8 cases\n}\n\n// After\nswitch step.Executor {\ncase ExecutorShell:  handleShell(ctx, wf, step)\ncase ExecutorSpawn:  handleSpawn(ctx, wf, step)\ncase ExecutorKill:   handleKill(ctx, wf, step)\ncase ExecutorExpand: handleExpand(ctx, wf, step)\ncase ExecutorBranch: handleBranch(ctx, wf, step)\ncase ExecutorAgent:  handleAgent(ctx, wf, step)\ncase ExecutorGate:   handleGate(ctx, wf, step)\n}\n```\n\n## Files Affected\n\n- internal/orchestrator/orchestrator.go - Main refactor\n- internal/orchestrator/state.go - Use WorkflowStore\n- internal/orchestrator/expander.go - Update for Step model","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:30Z","created_by":"claude","dependencies":[{"issue_id":"pivot-400","depends_on_id":"pivot-200","type":"blocks","created_at":"2026-01-08T12:00:30Z","created_by":"claude"},{"issue_id":"pivot-400","depends_on_id":"pivot-300","type":"blocks","created_at":"2026-01-08T12:00:30Z","created_by":"claude"}]}
{"id":"pivot-401","title":"Refactor orchestrator for WorkflowStore","description":"# Refactor Orchestrator for WorkflowStore\n\n## File: internal/orchestrator/orchestrator.go\n\n## Changes\n\n### Constructor\n\n```go\n// Before\nfunc New(cfg *config.Config, store BeadStore, agents AgentManager, ...) *Orchestrator\n\n// After\nfunc New(cfg *config.Config, store WorkflowStore, agents AgentManager, ...) *Orchestrator\n```\n\n### Main Loop\n\n```go\nfunc (o *Orchestrator) Run(ctx context.Context) error {\n    ticker := time.NewTicker(o.cfg.PollInterval)\n    defer ticker.Stop()\n\n    for {\n        select {\n        case <-ctx.Done():\n            return ctx.Err()\n        case <-ticker.C:\n            if err := o.tick(ctx); err != nil {\n                if err == errAllDone {\n                    return nil\n                }\n                o.logger.Error(\"tick error\", \"error\", err)\n            }\n        }\n    }\n}\n\nfunc (o *Orchestrator) tick(ctx context.Context) error {\n    // Get all running workflows\n    workflows, _ := o.store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n\n    allComplete := true\n    for _, wf := range workflows {\n        if err := o.processWorkflow(ctx, wf); err != nil {\n            return err\n        }\n        if wf.Status == types.WorkflowStatusRunning {\n            allComplete = false\n        }\n    }\n\n    if allComplete && len(workflows) > 0 {\n        return errAllDone\n    }\n    return nil\n}\n\nfunc (o *Orchestrator) processWorkflow(ctx context.Context, wf *types.Workflow) error {\n    readySteps := wf.GetReadySteps()\n    if len(readySteps) == 0 {\n        if wf.AllDone() {\n            wf.Complete()\n            return o.store.Save(ctx, wf)\n        }\n        if wf.HasFailed() {\n            wf.Fail()\n            return o.store.Save(ctx, wf)\n        }\n        return nil // Waiting for external completion\n    }\n\n    // Sort by priority: orchestrator executors first\n    sort.Slice(readySteps, func(i, j int) bool {\n        return readySteps[i].Executor.IsOrchestrator() && !readySteps[j].Executor.IsOrchestrator()\n    })\n\n    // Process first ready step\n    step := readySteps[0]\n    if err := o.dispatch(ctx, wf, step); err != nil {\n        return err\n    }\n\n    return o.store.Save(ctx, wf)\n}\n```\n\n### Dispatch\n\n```go\nfunc (o *Orchestrator) dispatch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    o.logger.Info(\"dispatching step\", \"id\", step.ID, \"executor\", step.Executor)\n\n    switch step.Executor {\n    case types.ExecutorShell:\n        return o.handleShell(ctx, wf, step)\n    case types.ExecutorSpawn:\n        return o.handleSpawn(ctx, wf, step)\n    case types.ExecutorKill:\n        return o.handleKill(ctx, wf, step)\n    case types.ExecutorExpand:\n        return o.handleExpand(ctx, wf, step)\n    case types.ExecutorBranch:\n        return o.handleBranch(ctx, wf, step)\n    case types.ExecutorAgent:\n        return o.handleAgent(ctx, wf, step)\n    case types.ExecutorGate:\n        return o.handleGate(ctx, wf, step)\n    default:\n        return fmt.Errorf(\"unknown executor: %s\", step.Executor)\n    }\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Constructor takes WorkflowStore\n- [ ] Main loop processes workflows not beads\n- [ ] Dispatch uses ExecutorType\n- [ ] Save workflow after each step\n- [ ] All 7 handlers updated\n- [ ] Tests use WorkflowStore","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:31Z","created_by":"claude","dependencies":[{"issue_id":"pivot-401","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"},{"issue_id":"pivot-401","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T12:00:31Z","created_by":"claude"}]}
{"id":"pivot-402","title":"Implement shell executor handler","description":"# Implement Shell Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleShell(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Shell == nil {\n        return fmt.Errorf(\"shell step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = &now\n\n    // Execute command\n    outputs, err := o.executor.Execute(ctx, step.Shell)\n    if err != nil {\n        if step.Shell.OnError == \"continue\" {\n            o.logger.Warn(\"shell failed, continuing\", \"step\", step.ID, \"error\", err)\n            step.Complete(outputs)\n            return nil\n        }\n        step.Fail(&types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(outputs)\n    return nil\n}\n```\n\n## Shell Executor Interface\n\n```go\ntype ShellExecutor interface {\n    Execute(ctx context.Context, cfg *types.ShellConfig) (map[string]any, error)\n}\n```\n\nThis should already exist from the old CodeExecutor - just needs interface rename.\n\n## Output Capture\n\nOutputs captured based on outputs config in template:\n- `stdout` - trimmed stdout\n- `stderr` - trimmed stderr\n- `exit_code` - integer exit code\n- `file:/path` - file contents\n\n## Acceptance Criteria\n\n- [ ] handleShell implementation\n- [ ] Uses ShellConfig from step\n- [ ] Respects on_error setting\n- [ ] Captures outputs correctly\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:32Z","created_by":"claude","dependencies":[{"issue_id":"pivot-402","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:32Z","created_by":"claude"}]}
{"id":"pivot-403","title":"Implement spawn executor handler","description":"# Implement Spawn Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleSpawn(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Spawn == nil {\n        return fmt.Errorf(\"spawn step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = &now\n\n    // Build agent start config\n    cfg := &agent.StartConfig{\n        AgentID:       step.Spawn.Agent,\n        Workdir:       step.Spawn.Workdir,\n        Env:           step.Spawn.Env,\n        Prompt:        step.Spawn.Prompt,\n        ResumeSession: step.Spawn.ResumeSession,\n    }\n\n    // Set default prompt\n    if cfg.Prompt == \"\" {\n        cfg.Prompt = \"meow prime\"\n    }\n\n    // Always set MEOW_AGENT env var\n    if cfg.Env == nil {\n        cfg.Env = make(map[string]string)\n    }\n    cfg.Env[\"MEOW_AGENT\"] = step.Spawn.Agent\n    cfg.Env[\"MEOW_WORKFLOW\"] = wf.ID\n\n    // Start agent\n    if err := o.agents.Start(ctx, cfg); err != nil {\n        step.Fail(&types.StepError{Message: err.Error()})\n        return nil\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Agent Manager Interface\n\n```go\ntype AgentManager interface {\n    Start(ctx context.Context, cfg *agent.StartConfig) error\n    Stop(ctx context.Context, cfg *agent.StopConfig) error\n    IsRunning(ctx context.Context, agentID string) (bool, error)\n}\n```\n\n## Key Behaviors\n\n1. Sets MEOW_AGENT and MEOW_WORKFLOW env vars\n2. Default prompt is \"meow prime\"\n3. Creates tmux session meow-{agent}\n4. Auto-completes when agent starts\n\n## Acceptance Criteria\n\n- [ ] handleSpawn implementation\n- [ ] Sets MEOW_AGENT env var\n- [ ] Sets MEOW_WORKFLOW env var\n- [ ] Default prompt handling\n- [ ] Resume session support\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:33Z","created_by":"claude","dependencies":[{"issue_id":"pivot-403","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:33Z","created_by":"claude"}]}
{"id":"pivot-404","title":"Implement kill executor handler","description":"# Implement Kill Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleKill(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Kill == nil {\n        return fmt.Errorf(\"kill step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = &now\n\n    cfg := &agent.StopConfig{\n        AgentID:  step.Kill.Agent,\n        Graceful: step.Kill.Graceful,\n        Timeout:  step.Kill.Timeout,\n    }\n\n    // Defaults\n    if cfg.Timeout == 0 {\n        cfg.Timeout = 10\n    }\n\n    if err := o.agents.Stop(ctx, cfg); err != nil {\n        // Log but don't fail - agent might already be dead\n        o.logger.Warn(\"kill step error\", \"step\", step.ID, \"error\", err)\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Graceful shutdown by default (SIGTERM, wait, SIGKILL)\n2. Default timeout 10 seconds\n3. Doesn't fail if agent already dead\n\n## Acceptance Criteria\n\n- [ ] handleKill implementation\n- [ ] Graceful shutdown support\n- [ ] Default timeout handling\n- [ ] Handles already-dead agents\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:34Z","created_by":"claude","dependencies":[{"issue_id":"pivot-404","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:34Z","created_by":"claude"}]}
{"id":"pivot-405","title":"Implement expand executor handler","description":"# Implement Expand Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleExpand(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Expand == nil {\n        return fmt.Errorf(\"expand step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = &now\n\n    // Merge workflow variables with expand variables\n    vars := make(map[string]string)\n    for k, v := range wf.Variables {\n        vars[k] = v\n    }\n    for k, v := range step.Expand.Variables {\n        vars[k] = v\n    }\n\n    // Add step outputs to variables\n    for stepID, s := range wf.Steps {\n        if s.Status == types.StepStatusDone && s.Outputs != nil {\n            for k, v := range s.Outputs {\n                vars[fmt.Sprintf(\"%s.outputs.%s\", stepID, k)] = fmt.Sprint(v)\n            }\n        }\n    }\n\n    // Load and bake template\n    _, workflow, err := o.loader.Load(ctx, step.Expand.Template)\n    if err != nil {\n        step.Fail(&types.StepError{Message: fmt.Sprintf(\"loading template: %v\", err)})\n        return nil\n    }\n\n    newSteps, err := o.baker.Bake(ctx, workflow, vars)\n    if err != nil {\n        step.Fail(&types.StepError{Message: fmt.Sprintf(\"baking template: %v\", err)})\n        return nil\n    }\n\n    // Add expanded steps to workflow with prefixed IDs\n    for _, newStep := range newSteps {\n        newStep.ID = GenerateExpandedStepID(step.ID, newStep.ID)\n\n        // Update needs to reference prefixed IDs within expansion\n        for i, need := range newStep.Needs {\n            newStep.Needs[i] = GenerateExpandedStepID(step.ID, need)\n        }\n\n        // Steps without internal deps need to depend on expand step\n        if len(newStep.Needs) == 0 {\n            newStep.Needs = []string{step.ID}\n        }\n\n        wf.AddStep(newStep)\n    }\n\n    step.Complete(nil)\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Merge workflow + expand variables\n2. Include step outputs as variables (for {{step.outputs.field}} refs)\n3. Prefix expanded step IDs to avoid collisions\n4. Update internal dependencies to use prefixed IDs\n5. Root steps depend on expand step\n\n## Acceptance Criteria\n\n- [ ] handleExpand implementation\n- [ ] Variable merging\n- [ ] Step ID prefixing\n- [ ] Dependency rewiring\n- [ ] Output variable injection\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:35Z","created_by":"claude","dependencies":[{"issue_id":"pivot-405","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:35Z","created_by":"claude"}]}
{"id":"pivot-406","title":"Implement branch executor handler","description":"# Implement Branch Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\nBranch evaluation runs in a goroutine because the condition may block.\n\n```go\nfunc (o *Orchestrator) handleBranch(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Branch == nil {\n        return fmt.Errorf(\"branch step %s missing config\", step.ID)\n    }\n\n    // Mark running\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = &now\n\n    // Save initial state\n    o.store.Save(ctx, wf)\n\n    // Run condition in goroutine (may block)\n    go o.evalBranch(ctx, wf.ID, step.ID)\n\n    return nil\n}\n\nfunc (o *Orchestrator) evalBranch(ctx context.Context, workflowID, stepID string) {\n    // Load fresh workflow state\n    wf, err := o.store.Get(ctx, workflowID)\n    if err != nil {\n        o.logger.Error(\"loading workflow for branch\", \"error\", err)\n        return\n    }\n    step := wf.Steps[stepID]\n\n    // Parse timeout\n    var timeout time.Duration\n    if step.Branch.Timeout != \"\" {\n        timeout, _ = time.ParseDuration(step.Branch.Timeout)\n    }\n\n    // Execute condition\n    execCtx := ctx\n    if timeout > 0 {\n        var cancel context.CancelFunc\n        execCtx, cancel = context.WithTimeout(ctx, timeout)\n        defer cancel()\n    }\n\n    shellCfg := &types.ShellConfig{Command: step.Branch.Condition}\n    outputs, err := o.executor.Execute(execCtx, shellCfg)\n\n    // Determine which branch to take\n    var target *types.BranchTarget\n    if execCtx.Err() == context.DeadlineExceeded {\n        target = step.Branch.OnTimeout\n        if target == nil {\n            target = step.Branch.OnFalse\n        }\n    } else if err != nil {\n        target = step.Branch.OnFalse\n    } else {\n        exitCode, _ := outputs[\"exit_code\"].(int)\n        if exitCode == 0 {\n            target = step.Branch.OnTrue\n        } else {\n            target = step.Branch.OnFalse\n        }\n    }\n\n    // Expand target\n    if target != nil {\n        if err := o.expandBranchTarget(ctx, wf, step, target); err != nil {\n            o.logger.Error(\"expanding branch\", \"step\", stepID, \"error\", err)\n        }\n    }\n\n    // Complete step\n    step.Complete(nil)\n    o.store.Save(ctx, wf)\n}\n```\n\n## Key Behaviors\n\n1. Condition runs in goroutine (non-blocking)\n2. Timeout support with fallback to on_false\n3. Exit code 0 = true, anything else = false\n4. Expand either template or inline steps\n\n## Acceptance Criteria\n\n- [ ] handleBranch implementation\n- [ ] Goroutine execution\n- [ ] Timeout handling\n- [ ] True/false/timeout branching\n- [ ] Template expansion\n- [ ] Inline step expansion\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:36Z","created_by":"claude","dependencies":[{"issue_id":"pivot-406","depends_on_id":"pivot-405","type":"blocks","created_at":"2026-01-08T12:00:36Z","created_by":"claude"}]}
{"id":"pivot-407","title":"Implement agent executor handler","description":"# Implement Agent Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleAgent(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Agent == nil {\n        return fmt.Errorf(\"agent step %s missing config\", step.ID)\n    }\n\n    // Check if agent is running\n    running, err := o.agents.IsRunning(ctx, step.Agent.Agent)\n    if err != nil {\n        o.logger.Warn(\"checking agent\", \"agent\", step.Agent.Agent, \"error\", err)\n    }\n    if !running {\n        o.logger.Warn(\"agent not running\", \"step\", step.ID, \"agent\", step.Agent.Agent)\n        // Don't fail - the workflow might spawn the agent later\n    }\n\n    // Mark running - agent will complete via meow done\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = &now\n\n    return nil\n}\n```\n\n## Key Points\n\n1. **External completion** - Orchestrator just marks running. Agent completes via `meow done`.\n2. **No automatic spawn** - If agent isn't running, we warn but don't fail. The workflow should have a spawn step.\n3. **Mode handling** - The `mode` field affects `meow prime` behavior, not the orchestrator.\n\n## Completion Flow\n\n```\n1. handleAgent marks step running\n2. Agent polls with meow prime, sees step\n3. Agent does work\n4. Agent runs meow done --output ...\n5. meow done finds step, validates outputs, marks done\n6. Next tick, orchestrator sees step is done\n```\n\n## Acceptance Criteria\n\n- [ ] handleAgent implementation\n- [ ] Marks step running\n- [ ] Warns if agent not running\n- [ ] Doesn't auto-spawn\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:37Z","created_by":"claude","dependencies":[{"issue_id":"pivot-407","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:37Z","created_by":"claude"}]}
{"id":"pivot-408","title":"Implement gate executor handler","description":"# Implement Gate Executor Handler\n\n## File: internal/orchestrator/orchestrator.go\n\n## Implementation\n\n```go\nfunc (o *Orchestrator) handleGate(ctx context.Context, wf *types.Workflow, step *types.Step) error {\n    if step.Gate == nil {\n        return fmt.Errorf(\"gate step %s missing config\", step.ID)\n    }\n\n    // Mark running - human will complete via meow approve/reject\n    step.Status = types.StepStatusRunning\n    now := time.Now()\n    step.StartedAt = &now\n\n    o.logger.Info(\"gate awaiting approval\",\n        \"workflow\", wf.ID,\n        \"step\", step.ID,\n    )\n\n    return nil\n}\n```\n\n## Key Points\n\n1. **External completion** - Human runs `meow approve` or `meow reject`\n2. **No assignee** - Gates are human-facing, not agent-facing\n3. **Timeout handling** - Future enhancement (auto-reject after timeout)\n\n## Completion Flow\n\n```\n1. handleGate marks step running\n2. Human sees gate via meow gates\n3. Human runs meow approve wf-xxx step-id\n4. meow approve finds step, marks done\n5. Next tick, orchestrator sees step is done\n\nOR\n\n3. Human runs meow reject wf-xxx step-id --reason \"...\"\n4. meow reject finds step, marks failed with reason\n5. Workflow may fail depending on error handling\n```\n\n## Acceptance Criteria\n\n- [ ] handleGate implementation\n- [ ] Marks step running\n- [ ] Logs for visibility\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:38Z","created_by":"claude","dependencies":[{"issue_id":"pivot-408","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:38Z","created_by":"claude"}]}
{"id":"pivot-409","title":"Implement crash recovery for workflows","description":"# Implement Crash Recovery for Workflows\n\n## File: internal/orchestrator/orchestrator.go\n\n## Recovery Protocol\n\nOn orchestrator startup:\n\n```go\nfunc (o *Orchestrator) Recover(ctx context.Context) error {\n    // Load all running workflows\n    workflows, err := o.store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n    if err != nil {\n        return err\n    }\n\n    for _, wf := range workflows {\n        modified := false\n        for _, step := range wf.Steps {\n            if step.Status != types.StepStatusRunning {\n                continue\n            }\n\n            // Handle based on executor type\n            if step.Executor.IsOrchestrator() {\n                // Orchestrator step was mid-execution - reset\n                o.logger.Info(\"resetting orchestrator step\", \"step\", step.ID)\n                step.Status = types.StepStatusPending\n                step.StartedAt = nil\n                modified = true\n            } else if step.Executor == types.ExecutorAgent {\n                // Check if agent is still alive\n                running, _ := o.agents.IsRunning(ctx, step.Agent.Agent)\n                if !running {\n                    o.logger.Info(\"resetting step from dead agent\",\n                        \"step\", step.ID,\n                        \"agent\", step.Agent.Agent,\n                    )\n                    step.Status = types.StepStatusPending\n                    step.StartedAt = nil\n                    modified = true\n                }\n            }\n            // Gates stay running - human might still approve\n        }\n\n        if modified {\n            o.store.Save(ctx, wf)\n        }\n    }\n\n    return nil\n}\n```\n\n## Recovery Rules\n\n| Executor | Recovery Action |\n|----------|----------------|\n| shell, spawn, kill, expand, branch | Reset to pending |\n| agent | Check tmux session; reset if dead |\n| gate | Keep running (human might approve) |\n\n## Acceptance Criteria\n\n- [ ] Recover() method\n- [ ] Resets orchestrator steps\n- [ ] Checks agent tmux sessions\n- [ ] Preserves gate steps\n- [ ] Integration test with simulated crash","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:39Z","created_by":"claude","dependencies":[{"issue_id":"pivot-409","depends_on_id":"pivot-408","type":"blocks","created_at":"2026-01-08T12:00:39Z","created_by":"claude"}]}
{"id":"pivot-410","title":"Remove tier-based logic from orchestrator","description":"# Remove Tier-Based Logic from Orchestrator\n\n## Context\n\nThe current orchestrator has tier-aware logic:\n- Priority sorting by tier\n- Wisp burning/cleanup\n- Tier filtering in queries\n\nAll of this should be removed.\n\n## Code to Remove\n\n### internal/orchestrator/orchestrator.go\n\n```go\n// Remove these functions\nfunc (o *Orchestrator) cleanupWorkflow(...)\nfunc (o *Orchestrator) burnWisps(...)\nfunc (o *Orchestrator) squashWisps(...)\nfunc (o *Orchestrator) generateWispDigest(...)\n\n// Remove tier-based priority in GetNextReady\nfunc tierPriority(tier BeadTier) int { ... }\n```\n\n### internal/orchestrator/beadstore.go\n\nThis entire file is removed in pivot-204.\n\n## New Priority Logic\n\nSimpler: orchestrator executors before external.\n\n```go\nsort.Slice(readySteps, func(i, j int) bool {\n    return readySteps[i].Executor.IsOrchestrator() && \n           !readySteps[j].Executor.IsOrchestrator()\n})\n```\n\n## Acceptance Criteria\n\n- [ ] No references to BeadTier\n- [ ] No wisp burning code\n- [ ] Simple priority logic\n- [ ] All tests pass","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:40Z","created_by":"claude","dependencies":[{"issue_id":"pivot-410","depends_on_id":"pivot-409","type":"blocks","created_at":"2026-01-08T12:00:40Z","created_by":"claude"}]}
{"id":"pivot-500","title":"EPIC: CLI Alignment","description":"# CLI Alignment\n\n## Overview\n\nThe CLI commands need updates to work with the new workflow model.\n\n## Key Changes\n\n| Old | New | Notes |\n|-----|-----|-------|\n| meow close | meow done | Signals step completion |\n| meow prime (bead-centric) | meow prime (step-centric) | Shows current step |\n| meow approve/reject | Same | Works with workflow/step IDs |\n| meow status | Same | Shows workflow status |\n| meow run | Same | Creates and runs workflow |\n\n## New Behaviors\n\n### meow done\n\n```bash\n# Before (bead-centric)\nmeow close meow-abc.step-1 --output key=value\n\n# After (agent-centric)\nmeow done --output key=value\n# Uses MEOW_AGENT env var to find current step\n```\n\n### meow prime\n\n```bash\n# Returns prompt for current step only\n# No tier filtering - just finds running agent step\n# Returns empty for interactive mode or no work\n```\n\n### meow approve/reject\n\n```bash\nmeow approve wf-abc123 gate-step-id\nmeow reject wf-abc123 gate-step-id --reason \"...\"\n```\n\n## Files Affected\n\n- cmd/meow/cmd/done.go (rename from close.go)\n- cmd/meow/cmd/prime.go\n- cmd/meow/cmd/approve.go\n- cmd/meow/cmd/reject.go\n- cmd/meow/cmd/run.go\n- cmd/meow/cmd/status.go","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:50Z","created_by":"claude","dependencies":[{"issue_id":"pivot-500","depends_on_id":"pivot-400","type":"blocks","created_at":"2026-01-08T12:00:50Z","created_by":"claude"}]}
{"id":"pivot-501","title":"Implement meow done command","description":"# Implement meow done Command\n\n## File: cmd/meow/cmd/done.go (rename from close.go)\n\n## Usage\n\n```bash\n# Simple completion\nmeow done\n\n# With outputs\nmeow done --output key=value --output other=value2\n\n# With JSON outputs\nmeow done --output-json '{\"key\": \"value\"}'\n\n# With notes\nmeow done --notes \"Completed successfully\"\n```\n\n## Implementation\n\n```go\nvar doneCmd = &cobra.Command{\n    Use:   \"done\",\n    Short: \"Signal step completion\",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        // Get agent ID from environment\n        agentID := os.Getenv(\"MEOW_AGENT\")\n        if agentID == \"\" {\n            return fmt.Errorf(\"MEOW_AGENT not set - are you running in a MEOW session?\")\n        }\n\n        // Find workflow with running step for this agent\n        store := getWorkflowStore()\n        workflows, _ := store.GetByAgent(ctx, agentID)\n\n        var targetWf *types.Workflow\n        var targetStep *types.Step\n        for _, wf := range workflows {\n            for _, step := range wf.Steps {\n                if step.Executor == types.ExecutorAgent &&\n                   step.Status == types.StepStatusRunning &&\n                   step.Agent.Agent == agentID {\n                    targetWf = wf\n                    targetStep = step\n                    break\n                }\n            }\n        }\n\n        if targetStep == nil {\n            return fmt.Errorf(\"no running step found for agent %s\", agentID)\n        }\n\n        // Parse outputs\n        outputs := parseOutputs(outputFlags, outputJSON)\n\n        // Validate outputs against step definition\n        if err := validateOutputs(targetStep.Agent.Outputs, outputs); err != nil {\n            return err\n        }\n\n        // Complete step\n        targetStep.Complete(outputs)\n        return store.Save(ctx, targetWf)\n    },\n}\n```\n\n## Output Validation\n\n```go\nfunc validateOutputs(defs map[string]types.OutputDef, outputs map[string]any) error {\n    for name, def := range defs {\n        val, ok := outputs[name]\n        if !ok && def.Required {\n            return fmt.Errorf(\"missing required output: %s\", name)\n        }\n        if ok {\n            if err := validateType(val, def.Type); err != nil {\n                return fmt.Errorf(\"output %s: %w\", name, err)\n            }\n        }\n    }\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Rename close.go to done.go\n- [ ] Uses MEOW_AGENT env var\n- [ ] Finds running step for agent\n- [ ] Parses --output and --output-json\n- [ ] Validates required outputs\n- [ ] Completes step\n- [ ] Clear error messages\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:51Z","created_by":"claude","dependencies":[{"issue_id":"pivot-501","depends_on_id":"pivot-407","type":"blocks","created_at":"2026-01-08T12:00:51Z","created_by":"claude"}]}
{"id":"pivot-502","title":"Update meow prime for workflow model","description":"# Update meow prime for Workflow Model\n\n## File: cmd/meow/cmd/prime.go\n\n## Usage\n\n```bash\n# Default - uses MEOW_AGENT env var\nmeow prime\n\n# Explicit agent\nmeow prime --agent claude-1\n\n# For stop-hook injection\nmeow prime --format prompt\n\n# Machine-readable\nmeow prime --format json\n```\n\n## Output Format (Human)\n\n```markdown\n## Write Tests\n\nWrite failing tests that define the expected behavior for PROJ-123.\n\n### Required Outputs\n- `test_file` (string): Path to the test file\n\n### When Done\nmeow done --output test_file=<path>\n```\n\n## Implementation\n\n```go\nfunc runPrime(cmd *cobra.Command, args []string) error {\n    agentID := agentFlag\n    if agentID == \"\" {\n        agentID = os.Getenv(\"MEOW_AGENT\")\n    }\n    if agentID == \"\" {\n        return fmt.Errorf(\"agent not specified and MEOW_AGENT not set\")\n    }\n\n    store := getWorkflowStore()\n    workflows, _ := store.GetByAgent(ctx, agentID)\n\n    // Find running agent step for this agent\n    var step *types.Step\n    for _, wf := range workflows {\n        for _, s := range wf.Steps {\n            if s.Executor == types.ExecutorAgent &&\n               s.Status == types.StepStatusRunning &&\n               s.Agent.Agent == agentID {\n                step = s\n                break\n            }\n        }\n    }\n\n    if step == nil {\n        // No work - return empty for stop-hook\n        if format == \"prompt\" {\n            return nil\n        }\n        fmt.Println(\"No work assigned\")\n        return nil\n    }\n\n    // Check interactive mode\n    if step.Agent.Mode == types.AgentModeInteractive {\n        // Interactive mode - return empty to break auto-loop\n        if format == \"prompt\" {\n            return nil\n        }\n        fmt.Println(\"Interactive mode - waiting for conversation\")\n        return nil\n    }\n\n    // Format output\n    switch format {\n    case \"prompt\":\n        fmt.Print(formatPrompt(step))\n    case \"json\":\n        json.NewEncoder(os.Stdout).Encode(step)\n    default:\n        fmt.Print(formatHuman(step))\n    }\n\n    return nil\n}\n```\n\n## Key Behaviors\n\n1. Uses MEOW_AGENT env var by default\n2. Returns empty for interactive mode (breaks stop-hook loop)\n3. Returns empty if no work (workflow complete)\n4. Shows prompt and expected outputs\n\n## Acceptance Criteria\n\n- [ ] Uses MEOW_AGENT env var\n- [ ] Finds running agent step\n- [ ] Returns empty for interactive mode\n- [ ] Returns empty if no work\n- [ ] Formats prompt with outputs\n- [ ] --format prompt for stop-hook\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:52Z","created_by":"claude","dependencies":[{"issue_id":"pivot-502","depends_on_id":"pivot-407","type":"blocks","created_at":"2026-01-08T12:00:52Z","created_by":"claude"}]}
{"id":"pivot-503","title":"Update meow run for workflow model","description":"# Update meow run for Workflow Model\n\n## File: cmd/meow/cmd/run.go\n\n## Usage\n\n```bash\n# Run template\nmeow run template.meow.toml\n\n# Run specific workflow in module\nmeow run template.meow.toml#tdd\n\n# With variables\nmeow run template.meow.toml --var agent=claude-1 --var task_id=PROJ-123\n```\n\n## Implementation\n\n```go\nfunc runRun(cmd *cobra.Command, args []string) error {\n    templateRef := args[0]\n\n    // Parse variables\n    vars := parseVarFlags(varFlags)\n\n    // Load template\n    loader := template.NewLoader(searchPaths)\n    _, workflow, err := loader.Load(ctx, templateRef)\n    if err != nil {\n        return fmt.Errorf(\"loading template: %w\", err)\n    }\n\n    // Validate required variables\n    if err := validateVars(workflow.Variables, vars); err != nil {\n        return err\n    }\n\n    // Bake into steps\n    baker := template.NewBaker()\n    steps, err := baker.Bake(ctx, workflow, vars)\n    if err != nil {\n        return fmt.Errorf(\"baking template: %w\", err)\n    }\n\n    // Create workflow\n    wf := types.NewWorkflow(\n        orchestrator.GenerateWorkflowID(),\n        templateRef,\n        vars,\n    )\n    for _, step := range steps {\n        wf.AddStep(step)\n    }\n    wf.Status = types.WorkflowStatusRunning\n\n    // Persist workflow\n    store := getWorkflowStore()\n    if err := store.Create(ctx, wf); err != nil {\n        return fmt.Errorf(\"creating workflow: %w\", err)\n    }\n\n    fmt.Printf(\"Started workflow: %s\\n\", wf.ID)\n    fmt.Printf(\"Steps: %d\\n\", len(wf.Steps))\n\n    // Start orchestrator\n    orch := orchestrator.New(cfg, store, agents, loader, baker, executor, logger)\n    return orch.Run(ctx)\n}\n```\n\n## Key Changes from Old Version\n\n1. Creates Workflow not beads\n2. Uses WorkflowStore\n3. Starts orchestrator loop (was missing!)\n\n## Acceptance Criteria\n\n- [ ] Loads template\n- [ ] Validates variables\n- [ ] Bakes into steps\n- [ ] Creates workflow\n- [ ] Starts orchestrator\n- [ ] Prints workflow ID\n- [ ] Unit tests","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:53Z","created_by":"claude","dependencies":[{"issue_id":"pivot-503","depends_on_id":"pivot-401","type":"blocks","created_at":"2026-01-08T12:00:53Z","created_by":"claude"},{"issue_id":"pivot-503","depends_on_id":"pivot-303","type":"blocks","created_at":"2026-01-08T12:00:53Z","created_by":"claude"}]}
{"id":"pivot-504","title":"Update meow approve/reject for workflow model","description":"# Update meow approve/reject for Workflow Model\n\n## Files:\n- cmd/meow/cmd/approve.go\n- cmd/meow/cmd/reject.go\n\n## Usage\n\n```bash\nmeow approve wf-abc123 gate-step-id\nmeow approve wf-abc123 gate-step-id --notes \"LGTM\"\n\nmeow reject wf-abc123 gate-step-id --reason \"Missing tests\"\n```\n\n## Implementation (approve)\n\n```go\nvar approveCmd = &cobra.Command{\n    Use:   \"approve <workflow-id> <step-id>\",\n    Short: \"Approve a gate step\",\n    Args:  cobra.ExactArgs(2),\n    RunE: func(cmd *cobra.Command, args []string) error {\n        workflowID := args[0]\n        stepID := args[1]\n\n        store := getWorkflowStore()\n        wf, err := store.Get(ctx, workflowID)\n        if err != nil {\n            return fmt.Errorf(\"loading workflow: %w\", err)\n        }\n        if wf == nil {\n            return fmt.Errorf(\"workflow not found: %s\", workflowID)\n        }\n\n        step, ok := wf.Steps[stepID]\n        if !ok {\n            return fmt.Errorf(\"step not found: %s\", stepID)\n        }\n\n        if step.Executor != types.ExecutorGate {\n            return fmt.Errorf(\"step %s is not a gate (executor: %s)\", stepID, step.Executor)\n        }\n\n        if step.Status != types.StepStatusRunning {\n            return fmt.Errorf(\"gate not pending approval (status: %s)\", step.Status)\n        }\n\n        step.Complete(map[string]any{\"approved\": true, \"notes\": notes})\n        if err := store.Save(ctx, wf); err != nil {\n            return fmt.Errorf(\"saving workflow: %w\", err)\n        }\n\n        fmt.Printf(\"Approved: %s\\n\", stepID)\n        return nil\n    },\n}\n```\n\n## Implementation (reject)\n\nSimilar but marks step as failed:\n\n```go\nstep.Fail(&types.StepError{\n    Message: reason,\n})\n```\n\n## Acceptance Criteria\n\n- [ ] approve loads workflow and step\n- [ ] Validates step is a gate\n- [ ] Validates gate is running\n- [ ] Marks step done with approval info\n- [ ] reject marks step failed with reason\n- [ ] Unit tests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:54Z","created_by":"claude","dependencies":[{"issue_id":"pivot-504","depends_on_id":"pivot-408","type":"blocks","created_at":"2026-01-08T12:00:54Z","created_by":"claude"}]}
{"id":"pivot-505","title":"Update meow status for workflow model","description":"# Update meow status for Workflow Model\n\n## File: cmd/meow/cmd/status.go\n\n## Usage\n\n```bash\n# List all workflows\nmeow status\n\n# Show specific workflow\nmeow status wf-abc123\n\n# Show with steps\nmeow status wf-abc123 --steps\n\n# JSON output\nmeow status --json\n```\n\n## Output Format\n\n```\nWorkflows:\n  wf-abc123  running   work-loop.meow.toml    5/10 steps done\n  wf-def456  done      deploy.meow.toml       12/12 steps done\n\n$ meow status wf-abc123 --steps\nWorkflow: wf-abc123\nTemplate: work-loop.meow.toml\nStatus:   running\nStarted:  2026-01-08 21:00:00\n\nSteps:\n  ✓ select              done      agent      00:02:00\n  ✓ implement           done      expand     00:00:01\n  ✓ implement.load      done      agent      00:03:00\n  → implement.tests     running   agent      00:05:00\n  ○ implement.impl      pending   agent\n  ○ implement.commit    pending   agent\n```\n\n## Implementation\n\nUpdate to use WorkflowStore and show workflow/step structure.\n\n## Acceptance Criteria\n\n- [ ] Lists all workflows\n- [ ] Shows workflow details\n- [ ] Shows steps with --steps flag\n- [ ] JSON output format\n- [ ] No tier/bead references\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:55Z","created_by":"claude","dependencies":[{"issue_id":"pivot-505","depends_on_id":"pivot-202","type":"blocks","created_at":"2026-01-08T12:00:55Z","created_by":"claude"}]}
{"id":"pivot-506","title":"Update meow gates command","description":"# Update meow gates Command\n\n## File: cmd/meow/cmd/gates.go (may need to create)\n\n## Usage\n\n```bash\n# List all pending gates\nmeow gates\n\n# Filter by workflow\nmeow gates --workflow wf-abc123\n```\n\n## Output Format\n\n```\nPending Gates:\n\nWorkflow: wf-abc123\nStep:     review-gate\nPrompt:\n  Review the implementation for PROJ-123.\n  Changes: Added auth endpoint\n  Approve if ready to merge.\n\nCommands:\n  meow approve wf-abc123 review-gate\n  meow reject wf-abc123 review-gate --reason \"...\"\n\n---\n\nWorkflow: wf-def456\nStep:     deploy-approval\n...\n```\n\n## Implementation\n\n```go\nfunc runGates(cmd *cobra.Command, args []string) error {\n    store := getWorkflowStore()\n    workflows, _ := store.List(ctx, WorkflowFilter{Status: types.WorkflowStatusRunning})\n\n    var gates []*gateInfo\n    for _, wf := range workflows {\n        if workflowFilter != \"\" && wf.ID != workflowFilter {\n            continue\n        }\n        for _, step := range wf.Steps {\n            if step.Executor == types.ExecutorGate && step.Status == types.StepStatusRunning {\n                gates = append(gates, &gateInfo{wf, step})\n            }\n        }\n    }\n\n    if len(gates) == 0 {\n        fmt.Println(\"No pending gates\")\n        return nil\n    }\n\n    for _, g := range gates {\n        formatGate(g)\n    }\n    return nil\n}\n```\n\n## Acceptance Criteria\n\n- [ ] Lists pending gates\n- [ ] Shows prompt for each gate\n- [ ] Shows approve/reject commands\n- [ ] Filter by workflow\n- [ ] Unit tests","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:56Z","created_by":"claude","dependencies":[{"issue_id":"pivot-506","depends_on_id":"pivot-408","type":"blocks","created_at":"2026-01-08T12:00:56Z","created_by":"claude"}]}
{"id":"pivot-507","title":"Remove bead-specific CLI code","description":"# Remove Bead-Specific CLI Code\n\n## Context\n\nOnce all CLI commands are updated, remove any remaining bead-specific code.\n\n## Files to Clean Up\n\n- Remove references to BeadStore\n- Remove tier filtering in queries\n- Remove HookBead display\n- Remove bead ID parsing\n\n## Specifically\n\n- cmd/meow/cmd/close.go - DELETE (renamed to done.go)\n- Any helper functions for bead queries\n- Any formatting code for bead output\n\n## Acceptance Criteria\n\n- [ ] No BeadStore references in CLI\n- [ ] No tier filtering\n- [ ] close.go removed\n- [ ] All CLI tests pass","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-08T12:00:57Z","created_by":"claude","dependencies":[{"issue_id":"pivot-507","depends_on_id":"pivot-501","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-502","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-503","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-504","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"},{"issue_id":"pivot-507","depends_on_id":"pivot-505","type":"blocks","created_at":"2026-01-08T12:00:57Z","created_by":"claude"}]}
{"id":"pivot-600","title":"EPIC: Documentation & Cleanup","description":"# Documentation & Cleanup\n\n## Overview\n\nFinal phase: update all documentation and clean up dead code.\n\n## Documentation Updates\n\n1. **ARCHITECTURE.md** - Complete rewrite\n   - Remove three-tier model\n   - Document 7 executors\n   - Update component diagram\n   - Update interfaces\n\n2. **CLAUDE.md** - Update agent instructions\n   - Remove molecule/wisp references\n   - Simplify to: meow prime, meow done\n   - Update command reference\n\n3. **README.md** - Update getting started\n   - New template format\n   - New CLI commands\n   - New concepts\n\n4. **MVP-SPEC-v2.md** - Already done (the source of this pivot)\n\n5. **IMPLEMENTATION-GUIDE.md** - Already done\n\n## Code Cleanup\n\n1. Delete internal/types/bead.go\n2. Delete internal/orchestrator/beadstore.go\n3. Delete tier-related code\n4. Delete legacy template parser\n5. Clean up unused imports\n\n## Testing Cleanup\n\n1. Update all tests to use new types\n2. Remove bead-based test fixtures\n3. Add workflow-based test fixtures\n4. Ensure full coverage","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-08T12:00:60Z","created_by":"claude","dependencies":[{"issue_id":"pivot-600","depends_on_id":"pivot-500","type":"blocks","created_at":"2026-01-08T12:00:60Z","created_by":"claude"}]}
{"id":"pivot-601","title":"Rewrite ARCHITECTURE.md","description":"# Rewrite ARCHITECTURE.md\n\n## File: ARCHITECTURE.md\n\n## New Structure\n\n1. **The One Sentence** - MEOW is a workflow execution engine that coordinates AI agents through programmable templates.\n\n2. **Core Concepts**\n   - Templates = Programs (TOML)\n   - Workflows = Running instances (YAML state)\n   - Steps = Instructions\n   - Executors = Who runs each step\n\n3. **The 7 Executors**\n   - Table with orchestrator vs external\n   - Each executor's purpose and config\n\n4. **Data Flow**\n   - Template → Parse → Bake → Workflow → Execute\n   - Step outputs → Variable substitution\n\n5. **Component Diagram**\n   - Updated for new architecture\n   - No BeadStore, no tiers\n\n6. **Key Interfaces**\n   - WorkflowStore\n   - AgentManager\n   - ShellExecutor\n   - TemplateLoader\n   - Baker\n\n7. **File Layout**\n   - Updated directory structure\n\n## What to Remove\n\n- Three-tier model section\n- Bead types table\n- Wisp lifecycle section\n- HookBead concept\n- Beads integration section\n\n## Acceptance Criteria\n\n- [ ] New architecture documented\n- [ ] No tier references\n- [ ] No bead references\n- [ ] Accurate component diagram\n- [ ] Accurate interfaces","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:61Z","created_by":"claude","dependencies":[{"issue_id":"pivot-601","depends_on_id":"pivot-410","type":"blocks","created_at":"2026-01-08T12:00:61Z","created_by":"claude"}]}
{"id":"pivot-602","title":"Update CLAUDE.md for new model","description":"# Update CLAUDE.md for New Model\n\n## File: CLAUDE.md\n\n## Key Changes\n\n### Remove\n- References to molecules\n- References to wisps\n- References to tiers\n- `bd mol stack`, `bd mol current` commands\n- HookBead concept\n\n### Update\n- \"At Session Start\" - Use `meow prime` to see current work\n- \"During Execution\" - Run `meow done` when complete\n- \"Commands Reference\" - Update for new CLI\n\n### New Content\n\n```markdown\n## Execution Protocol\n\n### At Session Start\n\n1. **Check for work**:\n   ```bash\n   meow prime\n   ```\n   This shows your current step with instructions.\n\n2. **Read the instructions** and execute them.\n\n### During Execution\n\n1. Follow the step instructions\n2. When done, signal completion:\n   ```bash\n   meow done --output key=value\n   ```\n\n### Environment Variables\n\nMEOW sets these when spawning agents:\n- `MEOW_AGENT` - Your agent identifier\n- `MEOW_WORKFLOW` - Current workflow ID (for debugging)\n\n### Commands\n\n| Command | Purpose |\n|---------|--------|\n| `meow prime` | See current work |\n| `meow done` | Signal completion |\n| `meow done --output k=v` | Complete with outputs |\n```\n\n## Acceptance Criteria\n\n- [ ] No molecule references\n- [ ] No wisp references\n- [ ] No tier references\n- [ ] Updated command reference\n- [ ] Accurate execution protocol","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:62Z","created_by":"claude","dependencies":[{"issue_id":"pivot-602","depends_on_id":"pivot-501","type":"blocks","created_at":"2026-01-08T12:00:62Z","created_by":"claude"}]}
{"id":"pivot-603","title":"Delete dead code","description":"# Delete Dead Code\n\n## Files to Delete\n\n### internal/types/\n- bead.go - Entire file (after verification)\n\n### internal/orchestrator/\n- beadstore.go - Entire file\n\n### internal/template/\n- parser.go - If only legacy parsing (check first)\n\n### cmd/meow/cmd/\n- close.go - Replaced by done.go\n\n## Code to Remove from Files\n\n### internal/orchestrator/orchestrator.go\n- `cleanupWorkflow()`\n- `burnWisps()`\n- `squashWisps()`\n- `generateWispDigest()`\n- `cleanupEphemeralBeads()`\n- Any tier-related helper functions\n\n### internal/template/baker.go\n- `determineTier()`\n- HookBead assignment code\n- Any tier/wisp logic\n\n### internal/template/module.go\n- `Ephemeral` field handling\n- `HooksTo` field handling\n\n## Verification Process\n\n1. Run full test suite\n2. Grep for removed identifiers\n3. Check for unused imports\n4. Run `go build` to verify no references\n\n## Acceptance Criteria\n\n- [ ] All dead code deleted\n- [ ] No dangling references\n- [ ] Tests still pass\n- [ ] Clean build","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-08T12:00:63Z","created_by":"claude","dependencies":[{"issue_id":"pivot-603","depends_on_id":"pivot-106","type":"blocks","created_at":"2026-01-08T12:00:63Z","created_by":"claude"},{"issue_id":"pivot-603","depends_on_id":"pivot-204","type":"blocks","created_at":"2026-01-08T12:00:63Z","created_by":"claude"},{"issue_id":"pivot-603","depends_on_id":"pivot-507","type":"blocks","created_at":"2026-01-08T12:00:63Z","created_by":"claude"}]}
{"id":"pivot-604","title":"Update and run full test suite","description":"# Update and Run Full Test Suite\n\n## Overview\n\nEnsure all tests pass with the new architecture.\n\n## Test Categories\n\n### Unit Tests\n- internal/types/*_test.go - New type tests\n- internal/orchestrator/*_test.go - Updated orchestrator tests\n- internal/template/*_test.go - Updated template tests\n\n### Integration Tests\n- End-to-end workflow execution\n- All 7 executor types\n- Crash recovery\n- Multi-agent coordination\n\n### Test Fixtures\n\nUpdate testdata/ with new format templates:\n```\ntestdata/\n├── templates/\n│   ├── simple-agent.meow.toml\n│   ├── sequential.meow.toml\n│   ├── branching.meow.toml\n│   ├── looping.meow.toml\n│   └── multi-agent.meow.toml\n└── workflows/\n    └── fixtures/\n        ├── running-workflow.yaml\n        └── completed-workflow.yaml\n```\n\n## Commands\n\n```bash\n# Run all tests\ngo test ./...\n\n# Run with coverage\ngo test -coverprofile=coverage.out ./...\ngo tool cover -html=coverage.out\n\n# Run integration tests\ngo test -tags=integration ./...\n```\n\n## Acceptance Criteria\n\n- [ ] All unit tests pass\n- [ ] All integration tests pass\n- [ ] Coverage >= 70%\n- [ ] No test uses old bead types\n- [ ] Test fixtures use new format","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-08T12:00:64Z","created_by":"claude","dependencies":[{"issue_id":"pivot-604","depends_on_id":"pivot-603","type":"blocks","created_at":"2026-01-08T12:00:64Z","created_by":"claude"}]}
{"id":"pivot-605","title":"End-to-end validation","description":"# End-to-End Validation\n\n## Purpose\n\nValidate the entire pivot works end-to-end before declaring complete.\n\n## Test Scenarios\n\n### 1. Simple Agent Workflow\n\n```bash\n# Create test template\ncat > /tmp/test.meow.toml << 'EOF'\n[main]\nname = \"simple-test\"\n\n[[main.steps]]\nid = \"greet\"\nexecutor = \"agent\"\nagent = \"test-agent\"\nprompt = \"Say hello and report the greeting\"\n\n[main.steps.outputs]\ngreeting = { required = true, type = \"string\" }\nEOF\n\n# Run workflow\nmeow run /tmp/test.meow.toml --var agent=test-agent\n\n# In another terminal, as agent:\nexport MEOW_AGENT=test-agent\nmeow prime  # Should show prompt\nmeow done --output greeting=\"Hello, World!\"\n```\n\n### 2. Branching Workflow\n\nTest branch executor with true/false paths.\n\n### 3. Looping Workflow\n\nTest recursive template expansion.\n\n### 4. Human Gate\n\nTest meow approve/reject flow.\n\n### 5. Crash Recovery\n\nKill orchestrator mid-workflow, restart, verify continuation.\n\n## Success Criteria\n\n- [ ] All 5 scenarios pass\n- [ ] No errors in logs\n- [ ] State persists correctly\n- [ ] Agents receive correct prompts\n- [ ] Outputs captured correctly\n\n## Declare Pivot Complete\n\nOnce all scenarios pass, the pivot is complete!","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-08T12:00:65Z","created_by":"claude","dependencies":[{"issue_id":"pivot-605","depends_on_id":"pivot-604","type":"blocks","created_at":"2026-01-08T12:00:65Z","created_by":"claude"}]}
